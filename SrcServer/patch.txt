--- AxisAlignedBB.java	Sun Dec 16 21:51:42 2018
+++ AxisAlignedBB.java	Fri Apr 20 22:33:06 2018
@@ -1,11 +1,6 @@
 package net.minecraft.src;
 
-import java.util.List;
-
-// FCMOD: Changed
-//public class AxisAlignedBB
-public class AxisAlignedBB extends FCUtilsPrimitiveGeometric
-// END FCMOD
+public class AxisAlignedBB
 {
     /** ThreadLocal AABBPool */
     private static final ThreadLocal theAABBLocalPool = new AABBLocalPool();
@@ -480,111 +475,4 @@
     {
         return "box[" + this.minX + ", " + this.minY + ", " + this.minZ + " -> " + this.maxX + ", " + this.maxY + ", " + this.maxZ + "]";
     }
-    
-    // FCMOD: Added New
-	/**
-	 * Yaws the box around the J axis. Assumes that the box's initial facing is along the negative K axis (facing 2)
-	 */
-    @Override
-	public void RotateAroundJToFacing( int iFacing )
-    {
-		if ( iFacing > 2 )
-		{
-	    	if ( iFacing == 5 ) // i + 1
-	    	{
-	        	setBounds( 1.0D - maxZ, minY, 1.0D - maxX, 1.0D - minZ, maxY, 1.0D - minX );
-	    	}
-	    	else if ( iFacing == 4 ) // i - 1
-	    	{
-	        	setBounds( minZ, minY, minX, maxZ, maxY, maxX );
-	    	}
-	    	else // if ( iFacing == 3 ) // k + 1
-	    	{
-	        	setBounds( 1.0D - maxX, minY, 1.0D - maxZ, 1.0D - minX, maxY, 1.0D - minZ );
-	    	}
-		}    	
-    }
-	
-	/**
-	 * "Tilts" the box towards the desired facing.  Takes the up vector and either yaws or rolls it towards the specified axis.
-	 */	
-    @Override
-	public void TiltToFacingAlongJ( int iFacing )
-    {
-    	double newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ;
-    	
-		if ( iFacing == 0 ) // j - 1
-		{
-			// rotating around k axis here to point downwards
-			
-	    	setBounds( 1D - maxX, 1D - maxY, minZ, 1D - minX, 1D - minY, maxZ );
-		}
-		else if ( iFacing == 2 ) // k - 1
-		{
-			setBounds( minX, minZ, 1D - maxY, maxX, maxZ, 1D - minY );
-		}			
-		else if ( iFacing == 3 ) // k + 1
-		{
-			setBounds( minX, 1D - maxZ, minY, maxX, 1D - minZ, maxY );
-		}
-		else if ( iFacing == 4 ) // i - 1
-		{
-			setBounds( 1D - maxY, minX, minZ, 1D - minY, maxX, maxZ );
-		}			
-		else if ( iFacing == 5 ) // i + 1
-		{
-			setBounds( minY, 1D - maxX, minZ, maxY, 1D - minX, maxZ );
-		}			
-    }
-
-    @Override
-	public void Translate( double dDeltaX, double dDeltaY, double dDeltaZ )
-    {
-    	offset( dDeltaX, dDeltaY, dDeltaZ );
-    }
-    
-    @Override
-	public void AddToRayTrace( FCUtilsRayTraceVsComplexBlock rayTrace )
-    {
-    	rayTrace.AddBoxWithLocalCoordsToIntersectionList( minX, minY, minZ, maxX, maxY, maxZ );
-    }
-	
-    @Override
-	public AxisAlignedBB MakeTemporaryCopy()
-	{
-		return getAABBPool().getAABB( minX, minY, minZ, maxX, maxY, maxZ );
-	}
-	
-    @Override
-    public void AddIntersectingBoxesToCollisionList( World world, int i, int j, int k, AxisAlignedBB boxToIntersect, List collisionList )
-    {
-    	AxisAlignedBB offsetBox = MakeTemporaryCopy().offset( i, j, k );
-    	
-    	offsetBox.AddToListIfIntersects( boxToIntersect, collisionList );
-    }
-	
-    //------------- Class Specific Methods ------------//	
-    
-    public void ExpandToInclude( AxisAlignedBB box )
-    {
-    	minX = Math.min( minX, box.minX );
-    	maxX = Math.max( maxX, box.maxX );
-    	
-    	minY = Math.min( minY, box.minY );
-    	maxY = Math.max( maxY, box.maxY );
-    	
-    	minZ = Math.min( minZ, box.minZ );
-    	maxZ = Math.max( maxZ, box.maxZ );
-    }
-    
-    public void AddToListIfIntersects( AxisAlignedBB intersectingBox, List list )
-    {
-    	if ( intersectsWith( intersectingBox ) )
-    	{
-    		list.add( this );
-    	}
-    }
-	
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- BehaviorDispenseArmor.java	Fri Jun 14 12:31:52 2013
+++ BehaviorDispenseArmor.java	Fri Apr 20 22:33:06 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-	// FCMOD: Code removed to prevent usage
-	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -35,6 +33,4 @@
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
-    */
-    // END FCMOD
 }
--- BehaviorDispenseMinecart.java	Fri Jun 14 12:31:58 2013
+++ BehaviorDispenseMinecart.java	Fri Apr 20 22:33:06 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-	// FCMOD: Code removed to prevent usage
-    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -41,18 +39,12 @@
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
-    */
-    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
-	// FCMOD: Code removed
-    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
-    */
-    // END FCMOD
 }
--- BiomeGenBase.java	Mon Jan  7 00:33:57 2019
+++ BiomeGenBase.java	Fri Apr 20 22:33:06 2018
@@ -10,57 +10,41 @@
     public static final BiomeGenBase[] biomeList = new BiomeGenBase[256];
     public static final BiomeGenBase ocean = (new BiomeGenOcean(0)).setColor(112).setBiomeName("Ocean").setMinMaxHeight(-1.0F, 0.4F);
     public static final BiomeGenBase plains = (new BiomeGenPlains(1)).setColor(9286496).setBiomeName("Plains").setTemperatureRainfall(0.8F, 0.4F);
-    // FCMOD: Changed
-    //public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
-    //public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
-    //public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
-    //public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
-    public static final BiomeGenBase desert = (new FCBiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
-    public static final BiomeGenBase extremeHills = (new FCBiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
-    public static final BiomeGenBase forest = (new FCBiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
-    public static final BiomeGenBase taiga = (new FCBiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
-    // END FCMOD
+    public static final BiomeGenBase desert = (new BiomeGenDesert(2)).setColor(16421912).setBiomeName("Desert").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.1F, 0.2F);
+    public static final BiomeGenBase extremeHills = (new BiomeGenHills(3)).setColor(6316128).setBiomeName("Extreme Hills").setMinMaxHeight(0.3F, 1.5F).setTemperatureRainfall(0.2F, 0.3F);
+    public static final BiomeGenBase forest = (new BiomeGenForest(4)).setColor(353825).setBiomeName("Forest").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F);
+    public static final BiomeGenBase taiga = (new BiomeGenTaiga(5)).setColor(747097).setBiomeName("Taiga").func_76733_a(5159473).setEnableSnow().setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.1F, 0.4F);
     public static final BiomeGenBase swampland = (new BiomeGenSwamp(6)).setColor(522674).setBiomeName("Swampland").func_76733_a(9154376).setMinMaxHeight(-0.2F, 0.1F).setTemperatureRainfall(0.8F, 0.9F);
     public static final BiomeGenBase river = (new BiomeGenRiver(7)).setColor(255).setBiomeName("River").setMinMaxHeight(-0.5F, 0.0F);
-    // FCMOD: Changed
-    //public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
-    public static final BiomeGenBase hell = (new FCBiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
-    // END FCMOD
+    public static final BiomeGenBase hell = (new BiomeGenHell(8)).setColor(16711680).setBiomeName("Hell").setDisableRain().setTemperatureRainfall(2.0F, 0.0F);
 
     /** Is the biome used for sky world. */
-    // FCMOD: Changed
-    //public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
-    public static final BiomeGenBase sky = (new FCBiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
-    // END FCMOD
+    public static final BiomeGenBase sky = (new BiomeGenEnd(9)).setColor(8421631).setBiomeName("Sky").setDisableRain();
     public static final BiomeGenBase frozenOcean = (new BiomeGenOcean(10)).setColor(9474208).setBiomeName("FrozenOcean").setEnableSnow().setMinMaxHeight(-1.0F, 0.5F).setTemperatureRainfall(0.0F, 0.5F);
     public static final BiomeGenBase frozenRiver = (new BiomeGenRiver(11)).setColor(10526975).setBiomeName("FrozenRiver").setEnableSnow().setMinMaxHeight(-0.5F, 0.0F).setTemperatureRainfall(0.0F, 0.5F);
-    // FCMOD: Changed
-    //public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
-    //public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase icePlains = (new FCBiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
-    public static final BiomeGenBase iceMountains = (new FCBiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
-    // END FCMOD
+    public static final BiomeGenBase icePlains = (new BiomeGenSnow(12)).setColor(16777215).setBiomeName("Ice Plains").setEnableSnow().setTemperatureRainfall(0.0F, 0.5F);
+    public static final BiomeGenBase iceMountains = (new BiomeGenSnow(13)).setColor(10526880).setBiomeName("Ice Mountains").setEnableSnow().setMinMaxHeight(0.3F, 1.3F).setTemperatureRainfall(0.0F, 0.5F);
     public static final BiomeGenBase mushroomIsland = (new BiomeGenMushroomIsland(14)).setColor(16711935).setBiomeName("MushroomIsland").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(0.2F, 1.0F);
     public static final BiomeGenBase mushroomIslandShore = (new BiomeGenMushroomIsland(15)).setColor(10486015).setBiomeName("MushroomIslandShore").setTemperatureRainfall(0.9F, 1.0F).setMinMaxHeight(-1.0F, 0.1F);
 
     /** Beach biome. */
     public static final BiomeGenBase beach = (new BiomeGenBeach(16)).setColor(16440917).setBiomeName("Beach").setTemperatureRainfall(0.8F, 0.4F).setMinMaxHeight(0.0F, 0.1F);
 
-    // FCMOD: Changed
-    //public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
-    //public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
-    //public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
-    //public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
-    //public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
-    //public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
-    public static final BiomeGenBase desertHills = (new FCBiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
-    public static final BiomeGenBase forestHills = (new FCBiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
-    public static final BiomeGenBase taigaHills = (new FCBiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
-    public static final BiomeGenBase extremeHillsEdge = (new FCBiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
-    public static final BiomeGenBase jungle = (new FCBiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
-    public static final BiomeGenBase jungleHills = (new FCBiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
-    // END FCMOD
-    
+    /** Desert Hills biome. */
+    public static final BiomeGenBase desertHills = (new BiomeGenDesert(17)).setColor(13786898).setBiomeName("DesertHills").setDisableRain().setTemperatureRainfall(2.0F, 0.0F).setMinMaxHeight(0.3F, 0.8F);
+
+    /** Forest Hills biome. */
+    public static final BiomeGenBase forestHills = (new BiomeGenForest(18)).setColor(2250012).setBiomeName("ForestHills").func_76733_a(5159473).setTemperatureRainfall(0.7F, 0.8F).setMinMaxHeight(0.3F, 0.7F);
+
+    /** Taiga Hills biome. */
+    public static final BiomeGenBase taigaHills = (new BiomeGenTaiga(19)).setColor(1456435).setBiomeName("TaigaHills").setEnableSnow().func_76733_a(5159473).setTemperatureRainfall(0.05F, 0.8F).setMinMaxHeight(0.3F, 0.8F);
+
+    /** Extreme Hills Edge biome. */
+    public static final BiomeGenBase extremeHillsEdge = (new BiomeGenHills(20)).setColor(7501978).setBiomeName("Extreme Hills Edge").setMinMaxHeight(0.2F, 0.8F).setTemperatureRainfall(0.2F, 0.3F);
+
+    /** Jungle biome identifier */
+    public static final BiomeGenBase jungle = (new BiomeGenJungle(21)).setColor(5470985).setBiomeName("Jungle").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(0.2F, 0.4F);
+    public static final BiomeGenBase jungleHills = (new BiomeGenJungle(22)).setColor(2900485).setBiomeName("JungleHills").func_76733_a(5470985).setTemperatureRainfall(1.2F, 0.9F).setMinMaxHeight(1.8F, 0.5F);
     public String biomeName;
     public int color;
 
@@ -150,35 +134,18 @@
         this.biomeID = par1;
         biomeList[par1] = this;
         this.theBiomeDecorator = this.createBiomeDecorator();
-        // FCMOD: Changed 
-        //this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
-        //this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
-        //this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
-        //this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
-        //this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
-        //this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
-        //this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
-        spawnableCreatureList.add( new SpawnListEntry( FCEntitySheep.class, 12, 4, 4 ) );
-        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 4, 4 ) );
-        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 4, 4 ) );
-        spawnableCreatureList.add( new SpawnListEntry( FCEntityCow.class, 8, 4, 4 ) );
-        
-        spawnableMonsterList.add( new SpawnListEntry( FCEntitySpider.class, 10, 4, 4 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntityZombie.class, 10, 4, 4 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntitySkeleton.class, 10, 4, 4 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntityCreeper.class, 10, 4, 4 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 10, 4, 4 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntityEnderman.class, 1, 1, 4 ) );
-        
-        spawnableWaterCreatureList.add( new SpawnListEntry( FCEntitySquid.class, 10, 4, 4 ) );
-        
-        spawnableCaveCreatureList.add( new SpawnListEntry( FCEntityBat.class, 10, 8, 8 ) );
-        // END FCMOD
+        this.spawnableCreatureList.add(new SpawnListEntry(EntitySheep.class, 12, 4, 4));
+        this.spawnableCreatureList.add(new SpawnListEntry(EntityPig.class, 10, 4, 4));
+        this.spawnableCreatureList.add(new SpawnListEntry(EntityChicken.class, 10, 4, 4));
+        this.spawnableCreatureList.add(new SpawnListEntry(EntityCow.class, 8, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntitySpider.class, 10, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntityZombie.class, 10, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntitySkeleton.class, 10, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntityCreeper.class, 10, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 10, 4, 4));
+        this.spawnableMonsterList.add(new SpawnListEntry(EntityEnderman.class, 1, 1, 4));
+        this.spawnableWaterCreatureList.add(new SpawnListEntry(EntitySquid.class, 10, 4, 4));
+        this.spawnableCaveCreatureList.add(new SpawnListEntry(EntityBat.class, 10, 8, 8));
     }
 
     /**
@@ -287,15 +254,10 @@
     /**
      * Return true if the biome supports lightning bolt spawn, either by have the bolts enabled and have rain enabled.
      */
-    // FCMOD: Removed and replaced due to ambiguous naming and use.  It was used in vanilla
-    // both for determining whether lightning could strike in a biome, and whether it could rain there.
-    /*
     public boolean canSpawnLightningBolt()
     {
         return this.enableSnow ? false : this.enableRain;
     }
-    */
-    // END FCMOD
 
     /**
      * Checks to see if the rainfall level of the biome is extremely high
@@ -341,16 +303,4 @@
     {
         this.theBiomeDecorator.decorate(par1World, par2Random, par3, par4);
     }
-    
-    // FCMOD: Added
-    public boolean CanRainInBiome()
-    {
-        return enableSnow ? false : enableRain;
-    }
-    
-    public boolean CanLightningStrikeInBiome()
-    {
-    	return CanRainInBiome();
-    }
-    // END FCMOD
 }
--- BiomeGenHell.java	Fri Sep 28 14:57:47 2018
+++ BiomeGenHell.java	Fri Apr 20 22:33:06 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/28/2018
-
 package net.minecraft.src;
 
 public class BiomeGenHell extends BiomeGenBase
--- BiomeGenMushroomIsland.java	Fri Jun 14 12:32:07 2013
+++ BiomeGenMushroomIsland.java	Fri Apr 20 22:33:06 2018
@@ -11,11 +11,7 @@
         this.theBiomeDecorator.mushroomsPerChunk = 1;
         this.theBiomeDecorator.bigMushroomsPerChunk = 1;
         this.topBlock = (byte)Block.mycelium.blockID;
-        // FCMOD: Code removed so mobs can spawn in mushroom biomes
-        /*
         this.spawnableMonsterList.clear();
-        */
-        // END FCMOD
         this.spawnableCreatureList.clear();
         this.spawnableWaterCreatureList.clear();
         this.spawnableCreatureList.add(new SpawnListEntry(EntityMooshroom.class, 8, 4, 8));
--- BiomeGenSwamp.java	Mon Sep 24 14:49:48 2018
+++ BiomeGenSwamp.java	Fri Apr 20 22:33:06 2018
@@ -15,21 +15,7 @@
         this.theBiomeDecorator.clayPerChunk = 1;
         this.theBiomeDecorator.waterlilyPerChunk = 4;
         this.waterColorMultiplier = 14745518;
-        
-        // FCMOD: Changed
-        /*
         this.spawnableMonsterList.add(new SpawnListEntry(EntitySlime.class, 1, 1, 1));
-        */
-        spawnableMonsterList.add( new SpawnListEntry( FCEntitySlime.class, 1, 1, 1 ) );
-        spawnableMonsterList.add( new SpawnListEntry( FCEntityWitch.class, 1, 1, 1 ) );
-        
-        // get rid of cows and sheep and cause other animals to spawn in lower numbers
-        
-        spawnableCreatureList.clear();
-        
-        spawnableCreatureList.add( new SpawnListEntry( FCEntityChicken.class, 10, 2, 2 ) );
-        spawnableCreatureList.add( new SpawnListEntry( FCEntityPig.class, 10, 2, 2 ) );
-        // END FCMOD
     }
 
     /**
--- Block.java	Fri Dec 18 17:43:28 2020
+++ Block.java	Fri Apr 20 22:33:06 2018
@@ -3,10 +3,6 @@
 import java.util.List;
 import java.util.Random;
 
-//FCMOD: Added
-//import net.minecraft.client.Minecraft; //client only
-// END FCMOD
-
 public class Block
 {
     /**
@@ -37,9 +33,7 @@
     /** How much light is subtracted for going through this block */
     public static final int[] lightOpacity = new int[4096];
 
-    /** Array of booleans that tells if a block can grass
-     * FCNOTE: Misleading name.  This is actually wether grass can grow under the block
-     */
+    /** Array of booleans that tells if a block can grass */
     public static final boolean[] canBlockGrass = new boolean[4096];
 
     /** Amount of light emitted */
@@ -47,12 +41,8 @@
 
     /**
      * Flag if block ID should use the brightest neighbor light value as its own
-     * FCNOTE: Misleading name in that this does not apply to the neighbor below the block,
-     * only to sides and top
      */
     public static boolean[] useNeighborBrightness = new boolean[4096];
-    // FCMOD: Changed
-    /*
     public static final Block stone = (new BlockStone(1)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stone");
     public static final BlockGrass grass = (BlockGrass)(new BlockGrass(2)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("grass");
     public static final Block dirt = (new BlockDirt(3)).setHardness(0.5F).setStepSound(soundGravelFootstep).setUnlocalizedName("dirt");
@@ -63,6 +53,8 @@
     public static final BlockFluid waterMoving = (BlockFluid)(new BlockFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
     public static final Block waterStill = (new BlockStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
     public static final BlockFluid lavaMoving = (BlockFluid)(new BlockFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
+
+    /** Stationary lava source block */
     public static final Block lavaStill = (new BlockStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
     public static final Block sand = (new BlockSand(12)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("sand");
     public static final Block gravel = (new BlockGravel(13)).setHardness(0.6F).setStepSound(soundGravelFootstep).setUnlocalizedName("gravel");
@@ -71,29 +63,7 @@
     public static final Block oreCoal = (new BlockOre(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
     public static final Block wood = (new BlockLog(17)).setHardness(2.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("log");
     public static final BlockLeaves leaves = (BlockLeaves)(new BlockLeaves(18)).setHardness(0.2F).setLightOpacity(1).setStepSound(soundGrassFootstep).setUnlocalizedName("leaves");
-    */
-    public static final Block stone = new FCBlockStone( 1 );
-    public static final BlockGrass grass = new FCBlockGrass( 2 );
-    public static final Block dirt = new FCBlockDirt( 3 );
-    public static final Block cobblestone = (new FCBlockCobblestone(4)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebrick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block planks = new FCBlockPlanks( 5 );
-    public static final Block sapling = (new FCBlockSapling(6)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("sapling");
-    public static final Block bedrock = new FCBlockBedrock( 7 );
-    public static final BlockFluid waterMoving = (BlockFluid)(new FCBlockWaterFlowing(8, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final Block waterStill = (new FCBlockWaterStationary(9, Material.water)).setHardness(100.0F).setLightOpacity(3).setUnlocalizedName("water").disableStats();
-    public static final BlockFluid lavaMoving = (BlockFluid)(new FCBlockLavaFlowing(10, Material.lava)).setHardness(0.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-    public static final Block lavaStill = (new FCBlockLavaStationary(11, Material.lava)).setHardness(100.0F).setLightValue(1.0F).setUnlocalizedName("lava").disableStats();
-    public static final Block sand = new FCBlockSand( 12 );
-    public static final Block gravel = new FCBlockGravel( 13 );
-    public static final Block oreGold = (new FCBlockOreGold(14)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreGold");
-    public static final Block oreIron = (new FCBlockOreIron(15)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreIron");
-    public static final Block oreCoal = (new FCBlockOreCoal(16)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreCoal");
-    public static final Block wood = new FCBlockLog( 17 );
-    public static final BlockLeaves leaves = new FCBlockLeaves( 18 );
-    // END FCMOD
     public static final Block sponge = (new BlockSponge(19)).setHardness(0.6F).setStepSound(soundGrassFootstep).setUnlocalizedName("sponge");
-    // FCMOD: Changed
-    /*
     public static final Block glass = (new BlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
     public static final Block oreLapis = (new BlockOre(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
     public static final Block blockLapis = (new Block(22, Material.rock)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
@@ -117,7 +87,11 @@
     public static final BlockFlower mushroomRed = (BlockFlower)(new BlockMushroom(40, "mushroom_red")).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
     public static final Block blockGold = (new BlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
     public static final Block blockIron = (new BlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
+
+    /** stoneDoubleSlab */
     public static final BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new BlockStep(43, true)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
+
+    /** stoneSingleSlab */
     public static final BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new BlockStep(44, false)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
     public static final Block brick = (new Block(45, Material.rock)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
     public static final Block tnt = (new BlockTNT(46)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("tnt");
@@ -164,95 +138,18 @@
     public static final Block netherrack = (new BlockNetherrack(87)).setHardness(0.4F).setStepSound(soundStoneFootstep).setUnlocalizedName("hellrock");
     public static final Block slowSand = (new BlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
     public static final Block glowStone = (new BlockGlowStone(89, Material.glass)).setHardness(0.3F).setStepSound(soundGlassFootstep).setLightValue(1.0F).setUnlocalizedName("lightgem");
+
+    /** The purple teleport blocks inside the obsidian circle */
     public static final BlockPortal portal = (BlockPortal)(new BlockPortal(90)).setHardness(-1.0F).setStepSound(soundGlassFootstep).setLightValue(0.75F).setUnlocalizedName("portal");
     public static final Block pumpkinLantern = (new BlockPumpkin(91, true)).setHardness(1.0F).setStepSound(soundWoodFootstep).setLightValue(1.0F).setUnlocalizedName("litpumpkin");
     public static final Block cake = (new BlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
     public static final BlockRedstoneRepeater redstoneRepeaterIdle = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(93, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
     public static final BlockRedstoneRepeater redstoneRepeaterActive = (BlockRedstoneRepeater)(new BlockRedstoneRepeater(94, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("diode").disableStats();
-    */
-    public static final Block glass = (new FCBlockGlass(20, Material.glass, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("glass");
-    public static final Block oreLapis = (new FCBlockOreLapis(21)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreLapis");
-    public static final Block blockLapis = (new Block(22, Material.rock)).SetPicksEffectiveOn().setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("blockLapis").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dispenser = new FCBlockDispenserVanilla( 23 );
-    public static final Block sandStone = new FCBlockSandStone( 24 );
-    public static final Block music = new FCBlockNote( 25 );
-    public static final Block bed = (new FCBlockBed(26)).setHardness(0.2F).SetBuoyant().setUnlocalizedName("bed").disableStats();
-    public static final Block railPowered = (new BlockRailPowered(27)).SetPicksEffectiveOn().setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("goldenRail");
-    public static final Block railDetector = (new FCBlockDetectorRail(28)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("detectorRail");
-    public static final BlockPistonBase pistonStickyBase = (BlockPistonBase)(new FCBlockPistonBase(29, true)).setUnlocalizedName("pistonStickyBase");
-    public static final Block web = new FCBlockWeb( 30 );
-    public static final BlockTallGrass tallGrass = new FCBlockTallGrass( 31 );
-    public static final BlockDeadBush deadBush = new FCBlockDeadBush( 32 );
-    public static final BlockPistonBase pistonBase = (BlockPistonBase)(new FCBlockPistonBase(33, false)).setUnlocalizedName("pistonBase");
-    public static final BlockPistonExtension pistonExtension = new FCBlockPistonExtension(34);
-    public static final Block cloth = new FCBlockCloth(); // sets own blockID of 35
-    public static final BlockPistonMoving pistonMoving = new FCBlockPistonMoving( 36 );
-    public static final BlockFlower plantYellow = (BlockFlower)(new FCBlockFlowerBlossom( 37 )).setUnlocalizedName("flower");
-    public static final BlockFlower plantRed = (BlockFlower)(new FCBlockFlowerBlossom( 38 )).setUnlocalizedName("rose");
-    public static final BlockFlower mushroomBrown = (BlockFlower)(new FCBlockMushroomBrown(39, "mushroom_brown")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
-    public static final BlockFlower mushroomRed = (BlockFlower)(new FCBlockMushroom(40, "mushroom_red")).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("mushroom");
-    public static final Block blockGold = (new FCBlockOreStorage(41)).setHardness(3.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockGold");
-    public static final Block blockIron = (new FCBlockOreStorage(42)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockIron");
-    public static final BlockHalfSlab stoneDoubleSlab = (BlockHalfSlab)(new FCBlockStep(43, true)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-    public static final BlockHalfSlab stoneSingleSlab = (BlockHalfSlab)(new FCBlockStep(44, false)).SetPicksEffectiveOn().setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stoneSlab");
-    public static final Block brick = (new FCBlockBrick(45)).setHardness(2.0F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("brick").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block tnt = new FCBlockPowderKeg( 46 );
-    public static final Block bookShelf = new FCBlockBookshelf( 47 );
-    public static final Block cobblestoneMossy = new FCBlockCobblestoneMossy( 48 ); 
-    public static final Block obsidian = new FCBlockObsidian( 49 );
-    public static final Block torchWood = new FCBlockTorchLegacy( 50 );
-    public static final BlockFire fire = (BlockFire)(new FCBlockFire(51)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("fire").disableStats();
-    public static final Block mobSpawner = new FCBlockMobSpawner( 52 );
-    public static final Block stairsWoodOak = (new FCBlockStairsWood( 53, planks, 0 ) ).setUnlocalizedName( "stairsWood" );
-    public static final BlockChest chest = (BlockChest)( new FCBlockChest( 54 ) ).setCreativeTab( null );
-    public static final BlockRedstoneWire redstoneWire = (BlockRedstoneWire)(new FCBlockRedstoneWire(55)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("redstoneDust").disableStats();
-    public static final Block oreDiamond = (new FCBlockOreDiamond(56)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreDiamond");
-    public static final Block blockDiamond = (new FCBlockOreStorage(57)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockDiamond");
-    public static final Block workbench = new FCBlockWorkbench( 58 );
-    public static final Block crops = (new FCBlockWheatLegacy(59)).SetBuoyant().setUnlocalizedName("crops");
-    public static final Block tilledField = new FCBlockFarmlandLegacyUnfertilized( 60 );
-    public static final Block furnaceIdle = new FCBlockFurnace( 61, false );
-    public static final Block furnaceBurning = new FCBlockFurnace( 62, true );
-    public static final Block signPost = new FCBlockSign( 63, true );
-    public static final Block doorWood = new FCBlockDoorWood( 64 );
-    public static final Block ladder = new FCBlockLegacyLadder( 65 );
-    public static final Block rail = new FCBlockRailRegular( 66 );
-    public static final Block stairsCobblestone = new FCBlockStairsCobblestone( 67 );
-    public static final Block signWall = new FCBlockSignWall( 68 );
-    public static final Block lever = (new FCBlockLever(69)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("lever");
-    public static final Block pressurePlateStone = new FCBlockPressurePlateStone( 70 );
-    public static final Block doorIron = (new FCBlockDoor(71, Material.iron)).setHardness(5.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("doorIron").disableStats();
-    public static final Block pressurePlatePlanks = new FCBlockPressurePlatePlanks( 72 );
-    public static final Block oreRedstone = (new FCBlockRedstoneOre(73, false)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block oreRedstoneGlowing = (new FCBlockRedstoneOre(74, true)).setLightValue(0.625F).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreRedstone").setCreativeTab(null);
-    public static final Block torchRedstoneIdle = (new BlockRedstoneTorch( 75, false )).setUnlocalizedName("notGate");
-    public static final Block torchRedstoneActive = (new BlockRedstoneTorch( 76, true )).setLightValue(0.5F).setUnlocalizedName("notGate").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block stoneButton = (new FCBlockButtonStone(77)).setHardness(0.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("button");
-    public static final Block snow = new FCBlockSnowCover( 78 );
-    public static final Block ice = (new FCBlockIce(79)).setHardness(0.5F).SetBuoyant().setLightOpacity(3).setStepSound(soundGlassFootstep).setUnlocalizedName("ice");
-    public static final Block blockSnow = new FCBlockSnowLegacy( 80 );
-    public static final Block cactus = new FCBlockCactus( 81 );
-    public static final Block blockClay = (new FCBlockClay(82)).setHardness(0.6F).setUnlocalizedName("clay");
-    public static final Block reed = (new FCBlockReed(83)).setHardness(0.0F).SetBuoyant().setStepSound(soundGrassFootstep).setUnlocalizedName("reeds").disableStats();
-    public static final Block jukebox = new FCBlockJukebox( 84 );
-    public static final Block fence = new FCBlockFenceWood( 85 );
-    public static final Block pumpkin = new FCBlockPumpkinCarved( 86 );
-    public static final Block netherrack = new FCBlockNetherrack( 87 );
-    public static final Block slowSand = (new FCBlockSoulSand(88)).setHardness(0.5F).setStepSound(soundSandFootstep).setUnlocalizedName("hellsand");
-    public static final Block glowStone = new FCBlockGlowStone( 89 );
-    public static final BlockPortal portal = new FCBlockPortal( 90 );
-    public static final Block pumpkinLantern = new FCBlockJackOLantern( 91 );
-    public static final Block cake = (new FCBlockCake(92)).setHardness(0.5F).setStepSound(soundClothFootstep).setUnlocalizedName("cake").disableStats();
-    public static final BlockRedstoneRepeater redstoneRepeaterIdle = new FCBlockRedstoneRepeater( 93, false );
-    public static final BlockRedstoneRepeater redstoneRepeaterActive = new FCBlockRedstoneRepeater( 94, true );
-    // END FCMOD
 
     /**
      * April fools secret locked chest, only spawns on new chunks on 1st April.
      */
     public static final Block lockedChest = (new BlockLockedChest(95)).setHardness(0.0F).setLightValue(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("lockedchest").setTickRandomly(true);
-    // FCMOD: Changed
-    /*
     public static final Block trapdoor = (new BlockTrapDoor(96, Material.wood)).setHardness(3.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("trapdoor").disableStats();
     public static final Block silverfish = (new BlockSilverfish(97)).setHardness(0.75F).setUnlocalizedName("monsterStoneEgg");
     public static final Block stoneBrick = (new BlockStoneBrick(98)).setHardness(1.5F).setResistance(10.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("stonebricksmooth");
@@ -294,52 +191,7 @@
     public static final Block stairsWoodSpruce = (new BlockStairs(134, planks, 1)).setUnlocalizedName("stairsWoodSpruce");
     public static final Block stairsWoodBirch = (new BlockStairs(135, planks, 2)).setUnlocalizedName("stairsWoodBirch");
     public static final Block stairsWoodJungle = (new BlockStairs(136, planks, 3)).setUnlocalizedName("stairsWoodJungle");
-    */
-    public static final Block trapdoor = new FCBlockTrapDoor( 96 );
-    public static final Block silverfish = new FCBlockSilverfish( 97 );
-    public static final Block stoneBrick = new FCBlockStoneBrick( 98 );
-    public static final Block mushroomCapBrown = new FCBlockMushroomCapLegacy( 99, 0 );
-    public static final Block mushroomCapRed = new FCBlockMushroomCapLegacy( 100, 1 );
-    public static final Block fenceIron = new FCBlockIronBars( 101 );
-    public static final Block thinGlass = (new FCBlockPane(102, "glass", "thinglass_top", Material.glass, false)).setHardness(0.3F).SetPicksEffectiveOn().setStepSound(soundGlassFootstep).setUnlocalizedName("thinGlass");
-    public static final Block melon = (new FCBlockMelon(103)).setHardness(1.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("melon");
-    public static final Block pumpkinStem = new FCBlockStem( 104, pumpkin );
-    public static final Block melonStem = new FCBlockStem( 105, melon );
-    public static final Block vine = new FCBlockVine( 106 );
-    public static final Block fenceGate = new FCBlockFenceGate( 107 );
-    public static final Block stairsBrick = (new FCBlockStairsBrick(108)).setUnlocalizedName("stairsBrick");
-    public static final Block stairsStoneBrick = new FCBlockStairsStoneBrick( 109 );
-    public static final BlockMycelium mycelium = new FCBlockMycelium( 110 );
-    public static final Block waterlily = (new FCBlockLilyPad(111)).setHardness(0.0F).setStepSound(soundGrassFootstep).setUnlocalizedName("waterlily");
-    public static final Block netherBrick = new FCBlockNetherBrick( 112 );
-    public static final Block netherFence = (new FCBlockFence( 113, "netherBrick", FCBetterThanWolves.fcMaterialNetherRock )).setHardness(2F).setResistance(10F).setStepSound(soundStoneFootstep).setUnlocalizedName("netherFence");
-    public static final Block stairsNetherBrick = new FCBlockStairsNetherBrick( 114 );
-    public static final Block netherStalk = (new FCBlockNetherStalk(115)).setUnlocalizedName("netherStalk");
-    public static final Block enchantmentTable = (new FCBlockEnchantmentTable(116)).setHardness(5.0F).setResistance(2000.0F).setUnlocalizedName("enchantmentTable");
-    public static final Block brewingStand = (new FCBlockBrewingStand(117)).setHardness(0.5F).setLightValue(0.125F).setUnlocalizedName("brewingStand");
-    public static final BlockCauldron cauldron = (BlockCauldron)(new FCBlockVanillaCauldron(118)).setHardness(2.0F).setUnlocalizedName("cauldron");
-    public static final Block endPortal = (new FCBlockEndPortal(119, Material.portal)).setHardness(-1.0F).setResistance(6000000.0F);
-    public static final Block endPortalFrame = (new FCBlockEndPortalFrame(120)).setStepSound(soundGlassFootstep).setLightValue(0.125F).setHardness(-1.0F).setUnlocalizedName("endPortalFrame").setResistance(6000000.0F).setCreativeTab(CreativeTabs.tabDecorations);
-    public static final Block whiteStone = (new FCBlockEndStone(121, Material.rock)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("whiteStone").setCreativeTab(CreativeTabs.tabBlock);
-    public static final Block dragonEgg = (new FCBlockDragonEgg(122)).setHardness(3.0F).setResistance(15.0F).setStepSound(soundStoneFootstep).setLightValue(0.125F).setUnlocalizedName("dragonEgg");
-    public static final Block redstoneLampIdle = (new FCBlockRedstoneLight(123, false)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight").setCreativeTab(CreativeTabs.tabRedstone);
-    public static final Block redstoneLampActive = (new FCBlockRedstoneLight(124, true)).setHardness(0.3F).setStepSound(soundGlassFootstep).setUnlocalizedName("redstoneLight");
-    public static final BlockHalfSlab woodDoubleSlab = new FCBlockWoodSlab( 125, true );
-    public static final BlockHalfSlab woodSingleSlab = new FCBlockWoodSlab( 126, false );
-    public static final Block cocoaPlant = (new FCBlockCocoa(127)).setHardness(0.2F).setResistance(5.0F).SetBuoyant().setStepSound(soundWoodFootstep).setUnlocalizedName("cocoa");
-    public static final Block stairsSandStone = (new FCBlockStairsSandStone(128)).setUnlocalizedName("stairsSandStone");
-    public static final Block oreEmerald = (new FCBlockOreEmerald(129)).setHardness(3.0F).setResistance(5.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("oreEmerald");
-    public static final Block enderChest = (new FCBlockEnderChest(130)).setHardness(22.5F).setResistance(1000.0F).setStepSound(soundStoneFootstep).setUnlocalizedName("enderChest").setLightValue(0.5F);
-    public static final BlockTripWireSource tripWireSource = new FCBlockTripWireSource( 131 );
-    public static final Block tripWire = (new FCBlockTripWire(132)).setUnlocalizedName("tripWire");
-    public static final Block blockEmerald = (new FCBlockOreStorage(133)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockEmerald");
-    public static final Block stairsWoodSpruce = ( new FCBlockStairsWood( 134, planks, 1 ) ).setUnlocalizedName( "stairsWoodSpruce" );
-    public static final Block stairsWoodBirch = ( new FCBlockStairsWood( 135, planks, 2 ) ).setUnlocalizedName( "stairsWoodBirch" );
-    public static final Block stairsWoodJungle = ( new FCBlockStairsWood( 136, planks, 3 ) ).setUnlocalizedName( "stairsWoodJungle" );
-    // END FCMOD
     public static final Block commandBlock = (new BlockCommandBlock(137)).setUnlocalizedName("commandBlock");
-    // FCMOD: Changed
-    /*
     public static final BlockBeacon beacon = (BlockBeacon)(new BlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
     public static final Block cobblestoneWall = (new BlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
     public static final Block flowerPot = (new BlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
@@ -361,29 +213,6 @@
     public static final Block stairsNetherQuartz = (new BlockStairs(156, blockNetherQuartz, 0)).setUnlocalizedName("stairsQuartz");
     public static final Block railActivator = (new BlockRailPowered(157)).setHardness(0.7F).setStepSound(soundMetalFootstep).setUnlocalizedName("activatorRail");
     public static final Block dropper = (new BlockDropper(158)).setHardness(3.5F).setStepSound(soundStoneFootstep).setUnlocalizedName("dropper");
-    */
-    public static final BlockBeacon beacon = (BlockBeacon)(new FCBlockBeacon(138)).setUnlocalizedName("beacon").setLightValue(1.0F);
-    public static final Block cobblestoneWall = (new FCBlockWall(139, cobblestone)).setUnlocalizedName("cobbleWall");
-    public static final Block flowerPot = (new FCBlockFlowerPot(140)).setHardness(0.0F).setStepSound(soundPowderFootstep).setUnlocalizedName("flowerPot");
-    public static final Block carrot = (new FCBlockCarrot(141)).setUnlocalizedName("carrots");
-    public static final Block potato = (new FCBlockPotato(142)).setUnlocalizedName("potatoes");
-    public static final Block woodenButton = (new FCBlockButtonWood(143)).setHardness(0.5F).setStepSound(soundWoodFootstep).setUnlocalizedName("button");
-    public static final Block skull = new FCBlockSkull( 144 );
-    public static final Block anvil = new FCBlockAnvil( 145 );
-    public static final Block chestTrapped = new FCBlockStub( 146 ).setUnlocalizedName( "chestTrap" );
-    public static final Block pressurePlateGold = new FCBlockStub( 147 ).setUnlocalizedName( "weightedPlate_light" );
-    public static final Block pressurePlateIron = new FCBlockStub( 148 ).setUnlocalizedName( "weightedPlate_heavy" );
-    public static final BlockComparator redstoneComparatorIdle = (BlockComparator)(new FCBlockComparator(149, false)).setHardness(0.0F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockComparator redstoneComparatorActive = (BlockComparator)(new FCBlockComparator(150, true)).setHardness(0.0F).setLightValue(0.625F).setStepSound(soundWoodFootstep).setUnlocalizedName("comparator").disableStats();
-    public static final BlockDaylightDetector daylightSensor = (BlockDaylightDetector)(new FCBlockDaylightDetector(151)).setHardness(0.2F).setStepSound(soundWoodFootstep).setUnlocalizedName("daylightDetector");
-    public static final Block blockRedstone = (new BlockPoweredOre(152)).setHardness(5.0F).setResistance(10.0F).setStepSound(soundMetalFootstep).setUnlocalizedName("blockRedstone").setLightValue(0.75F);
-    public static final Block oreNetherQuartz = new FCBlockNetherQuartzOre( 153 );
-    public static final BlockHopper hopperBlock = new FCBlockVanillaHopper( 154 );
-    public static final Block blockNetherQuartz = new FCBlockBlackStone( 155 );
-    public static final Block stairsNetherQuartz = new FCBlockBlackStoneStairs( 156 );
-    public static final Block railActivator = new FCBlockStub( 157 ).setUnlocalizedName( "activatorRail" );
-    public static final Block dropper = new FCBlockStub( 158 ).setUnlocalizedName( "dropper" );
-    // END FCMOD
 
     /** ID of the block. */
     public final int blockID;
@@ -413,36 +242,30 @@
     /** true if the Block contains a Tile Entity */
     protected boolean isBlockContainer;
 
-    // FCMOD: Changed
-    //protected double minX;
-    //protected double minY;
-    //protected double minZ;
-    //protected double maxX;
-    //protected double maxY;
-    //protected double maxZ;
-    /** FCNOTE: DEPRECATED */
-    protected double minX = 0D;
-    /** FCNOTE: DEPRECATED */
-    protected double minY = 0D;
-    /** FCNOTE: DEPRECATED */
-    protected double minZ = 0D;
-    /** FCNOTE: DEPRECATED */
-    protected double maxX = 1D;
-    /** FCNOTE: DEPRECATED */
-    protected double maxY = 1D;
-    /** FCNOTE: DEPRECATED */
-    protected double maxZ = 1D;
-    // END FCMOD
-    
+    /** minimum X for the block bounds (local coordinates) */
+    protected double minX;
+
+    /** minimum Y for the block bounds (local coordinates) */
+    protected double minY;
+
+    /** minimum Z for the block bounds (local coordinates) */
+    protected double minZ;
+
+    /** maximum X for the block bounds (local coordinates) */
+    protected double maxX;
+
+    /** maximum Y for the block bounds (local coordinates) */
+    protected double maxY;
+
+    /** maximum Z for the block bounds (local coordinates) */
+    protected double maxZ;
+
     /** Sound of stepping on the block */
     public StepSound stepSound;
     public float blockParticleGravity;
 
     /** Block material definition. */
-    // FCMOD: Changed
-    //public final Material blockMaterial;
-    public Material blockMaterial;
-    // END FCMOD
+    public final Material blockMaterial;
 
     /**
      * Determines how much velocity is maintained while moving on top of this block
@@ -471,10 +294,6 @@
             opaqueCubeLookup[par1] = this.isOpaqueCube();
             lightOpacity[par1] = this.isOpaqueCube() ? 255 : 0;
             canBlockGrass[par1] = !par2Material.getCanBlockGrass();
-            // FCMOD: Added
-            useNeighborBrightness[par1] = false;
-            SetFilterableProperties( Item.m_iFilterable_SolidBlock );
-            // END FCMOD
         }
     }
 
@@ -524,12 +343,7 @@
     public static boolean isNormalCube(int par0)
     {
         Block var1 = blocksList[par0];
-        // FCMOD: Changed this to not care about providing power (this is the way it used to work)
-        /*
         return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock() && !var1.canProvidePower();
-        */
-        return var1 == null ? false : var1.blockMaterial.isOpaque() && var1.renderAsNormalBlock();
-        // END FCMOD
     }
 
     /**
@@ -540,9 +354,6 @@
         return true;
     }
 
-	/**
-	 * FCNOTE: This is misnamed and returns true if the block *doesn't* block movement
-	 */	
     public boolean getBlocksMovement(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         return !this.blockMaterial.blocksMovement();
@@ -612,20 +423,16 @@
     }
 
     /**
-     * FCNOTE: DEPRECATED 
+     * Sets the bounds of the block.  minX, minY, minZ, maxX, maxY, maxZ
      */
     protected final void setBlockBounds(float par1, float par2, float par3, float par4, float par5, float par6)
     {
-    	// FCMOD: Removed due to deprecating these variables to eliminate client/server race conditions
-    	/*
         this.minX = (double)par1;
         this.minY = (double)par2;
         this.minZ = (double)par3;
         this.maxX = (double)par4;
         this.maxY = (double)par5;
         this.maxZ = (double)par6;
-        */
-    	// END FCMOD
     }
 
     /**
@@ -640,7 +447,6 @@
     /**
      * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
      * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
-     * FCNOTE: The "mask" referred to above is just the bounding box to check for intersection with
      */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
@@ -656,14 +462,10 @@
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
      * cleared to be reused)
      */
-    // FCMOD: Removed and replaced
-    /*
     public AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)
     {
         return AxisAlignedBB.getAABBPool().getAABB((double)par2 + this.minX, (double)par3 + this.minY, (double)par4 + this.minZ, (double)par2 + this.maxX, (double)par3 + this.maxY, (double)par4 + this.maxZ);
     }
-    */
-    // END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -692,20 +494,17 @@
 
     /**
      * Ticks the block if it's been scheduled
-     * FCNOTE: Called on server only
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random) {}
 
     /**
      * Called right before the block is destroyed by a player.  Args: world, x, y, z, metaData
-     * FCNOTE: Called AFTER block is set to air, not before
      */
     public void onBlockDestroyedByPlayer(World par1World, int par2, int par3, int par4, int par5) {}
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
-     * FCNOTE: Only called on server
      */
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5) {}
 
@@ -719,13 +518,11 @@
 
     /**
      * Called whenever the block is added into the world. Args: world, x, y, z
-     * FCNOTE: Called on server only
      */
     public void onBlockAdded(World par1World, int par2, int par3, int par4) {}
 
     /**
      * ejects contained items into the world, and notifies neighbours of an update, as appropriate
-     * FCNOTE: Called on server only.  Called AFTER block is set, so it is no longer valid at pos.
      */
     public void breakBlock(World par1World, int par2, int par3, int par4, int par5, int par6) {}
 
@@ -749,15 +546,11 @@
      * Gets the hardness of block at the given coordinates in the given world, relative to the ability of the given
      * EntityPlayer.
      */
-    // FCMOD: Removed and replaced later
-    /*
     public float getPlayerRelativeBlockHardness(EntityPlayer par1EntityPlayer, World par2World, int par3, int par4, int par5)
     {
         float var6 = this.getBlockHardness(par2World, par3, par4, par5);
         return var6 < 0.0F ? 0.0F : (!par1EntityPlayer.canHarvestBlock(this) ? par1EntityPlayer.getCurrentPlayerStrVsBlock(this, false) / var6 / 100.0F : par1EntityPlayer.getCurrentPlayerStrVsBlock(this, true) / var6 / 30.0F);
     }
-    */
-    // END FCMOD
 
     /**
      * Drops the specified block items
@@ -813,8 +606,6 @@
      */
     protected void dropXpOnBlockBreak(World par1World, int par2, int par3, int par4, int par5)
     {
-    	// FCMOD: Code removed
-    	/*
         if (!par1World.isRemote)
         {
             while (par5 > 0)
@@ -824,8 +615,6 @@
                 par1World.spawnEntityInWorld(new EntityXPOrb(par1World, (double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, var6));
             }
         }
-        */
-    	// END FCMOD
     }
 
     /**
@@ -848,8 +637,6 @@
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
-    // FCMOD: Removed and replaced
-    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
@@ -966,22 +753,29 @@
         }
     }
 
+    /**
+     * Checks if a vector is within the Y and Z bounds of the block.
+     */
     private boolean isVecInsideYZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
+    /**
+     * Checks if a vector is within the X and Z bounds of the block.
+     */
     private boolean isVecInsideXZBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.zCoord >= this.minZ && par1Vec3.zCoord <= this.maxZ;
     }
 
+    /**
+     * Checks if a vector is within the X and Y bounds of the block.
+     */
     private boolean isVecInsideXYBounds(Vec3 par1Vec3)
     {
         return par1Vec3 == null ? false : par1Vec3.xCoord >= this.minX && par1Vec3.xCoord <= this.maxX && par1Vec3.yCoord >= this.minY && par1Vec3.yCoord <= this.maxY;
     }
-    */
-    // END FCMOD 
 
     /**
      * Called upon the block being destroyed by an explosion
@@ -1041,7 +835,9 @@
      */
     public void velocityToAddToEntity(World par1World, int par2, int par3, int par4, Entity par5Entity, Vec3 par6Vec3) {}
 
-    /** FCNOTE: DEPRECATED */
+    /**
+     * Updates the blocks bounds based on its current state. Args: world, x, y, z
+     */
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4) {}
 
     /**
@@ -1132,22 +928,13 @@
     /**
      * Called when the player destroys a block with an item that can harvest it. (i, j, k) are the coordinates of the
      * block and l is the block's subtype/damage.
-     * FCNOTE: Only called on server
      */
     public void harvestBlock(World par1World, EntityPlayer par2EntityPlayer, int par3, int par4, int par5, int par6)
     {
         par2EntityPlayer.addStat(StatList.mineBlockStatArray[this.blockID], 1);
-        
-        // FCMOD: Changed
-        /*
         par2EntityPlayer.addExhaustion(0.025F);
 
         if (this.canSilkHarvest() && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
-        */
-        par2EntityPlayer.AddHarvestBlockExhaustion( blockID, par3, par4, par5, par6 );        
-        
-        if ( this.canSilkHarvest( par6 ) && EnchantmentHelper.getSilkTouchModifier(par2EntityPlayer))
-    	// END FCMOD
         {
             ItemStack var8 = this.createStackedBlock(par6);
 
@@ -1174,7 +961,6 @@
     /**
      * Returns an item stack containing a single instance of the current block type. 'i' is the block's subtype/damage
      * and is ignored for blocks which do not support subtypes. Blocks which cannot be harvested should return null.
-     * FCNOTE: This is the function used to create the silk-touch drop
      */
     protected ItemStack createStackedBlock(int par1)
     {
@@ -1206,7 +992,6 @@
 
     /**
      * Called when the block is placed in the world.
-     * FCNOTE: Called AFTER the block is placed, unlike onBlockPlaced()
      */
     public void onBlockPlacedBy(World par1World, int par2, int par3, int par4, EntityLiving par5EntityLiving, ItemStack par6ItemStack) {}
 
@@ -1266,7 +1051,6 @@
     /**
      * Returns the mobility information of the block, 0 = free, 1 = can't push but can move over, 2 = total immobility
      * and stop pistons
-     * FCMOD: 3 = can be piston shoveled, but free otherwise 
      */
     public int getMobilityFlag()
     {
@@ -1285,13 +1069,6 @@
     {
         return this.damageDropped(par1World.getBlockMetadata(par2, par3, par4));
     }
-    
-    // FCMOD: Added from client to avoid nuisance
-    public CreativeTabs getCreativeTabToDisplayOn()
-    {
-        return this.displayOnCreativeTab;
-    }
-    // END FCMOD    
 
     /**
      * Sets the CreativeTab to display this block on.
@@ -1399,12 +1176,8 @@
                     blocksList[var0].initializeBlock();
                 }
 
-                // FCMOD: Changed to not overwrite settings in block classes and to instead set
-                // useNeighborBrightness[] in block classes for most cases instead.
-                /*
                 boolean var1 = false;
 
-                // FCNOTE: renderType 10 is used by vanilla stairs
                 if (var0 > 0 && blocksList[var0].getRenderType() == 10)
                 {
                     var1 = true;
@@ -1431,2017 +1204,10 @@
                 }
 
                 useNeighborBrightness[var0] = var1;
-                */
-                if ( canBlockGrass[var0] || lightOpacity[var0] == 0 )
-                {
-                	useNeighborBrightness[var0] = true;
-                }
-                // END FCMOD
             }
         }
 
         canBlockGrass[0] = true;
         StatList.initBreakableStats();
     }
-    
-    // FCMOD: Added New
-	private static final int[] m_iRotatedFacingsAroundJClockwise = 
-		new int[] { 0, 1, 4, 5, 3, 2 };
-	
-	private static final int[] m_iRotatedFacingsAroundJCounterclockwise = 
-		new int[] { 0, 1, 5, 4, 2, 3 };
-	
-	private static final int[] m_iCycledFacings = 
-		new int[] { 4, 0, 1, 5, 3, 2 };
-	
-	private static final int[] m_iCycledFacingsReversed = 
-		new int[] { 1, 2, 5, 4, 0, 3 };
-	
-    public boolean IsNormalCube( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return blockMaterial.isOpaque() && renderAsNormalBlock();
-    }
-    
-    /**
-     * Similar to onBlockPlacedBy() but called before the block is placed rather than after
-     */
-    public int PreBlockPlacedBy( World world, int i, int j, int k, int iMetadata, EntityLiving entityBy ) 
-    {
-    	return iMetadata;    	
-    }
-
-    public void SetBlockMaterial( Material material )
-    {
-    	blockMaterial = material;
-    	
-        canBlockGrass[blockID] = !material.getCanBlockGrass();    	
-    }
-    
-    /**
-     * Called on server only
-     */
-    public void RandomUpdateTick( World world, int i, int j, int k, Random rand )
-    {
-    	updateTick( world, i, j, k, rand );
-    }
-    
-	public void ClientNotificationOfMetadataChange( World world, int i, int j, int k, int iOldMetadata, int iNewMetadata )
-	{
-	}
-	
-    public void OnArrowImpact( World world, int i, int j, int k, EntityArrow arrow )
-    {
-    }
-    
-    public void OnArrowCollide( World world, int i, int j, int k, EntityArrow arrow )
-    {
-    }
-    
-    public float GetMovementModifier( World world, int i, int j, int k )
-    {
-    	float fModifier = 1.0F;
-    	
-		if ( blockMaterial != Material.ground && blockMaterial != Material.grass )
-		{
-			fModifier *= 1.2F;
-		}
-    	
-    	return fModifier;
-    }
-    
-    public void OnPlayerWalksOnBlock( World world, int i, int j, int k, EntityPlayer player )
-    {
-		// Disabled Hardcore sinkholes
-    	/*
-    	if ( IsFallingBlock( world, i, j, k ) )
-    	{
-    		CheckForUnstableGround( world, i, j, k );
-    	}
-    	*/
-    }
-    
-    /**
-     * Applies to Hopper ejecting items into the world, not inserting into the block itself
-     */
-    public boolean DoesBlockHopperEject( World world, int i, int j, int k )
-    {
-    	return blockMaterial.isSolid();
-    }
-    
-    /**
-     * Applies to Hopper inserting items directly into the block's inventory.  This
-     * does not ensure the block has a valid inventory, it's just a first-pass chance
-     * to block such behavior.
-     */
-    public boolean DoesBlockHopperInsert( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    /**
-     * Returns true if the block is warm enough to melt nearby snow or ice
-     */
-    public boolean GetIsBlockWarm( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public StepSound GetStepSound( World world, int i, int j, int k )
-    {
-    	return stepSound;
-    }
-    
-    public void ClientBreakBlock( World world, int i, int j, int k, int iBlockID, int iMetadata )
-    {
-    }
-    
-    public void ClientBlockAdded( World world, int i, int j, int k )
-    {
-    }
-    
-    public boolean HasStrata()
-    {
-    	return false;
-    }
-    
-    public int GetMetadataConversionForStrataLevel( int iLevel, int iMetadata )
-    {
-    	return iMetadata;
-    }
-    
-    public float getExplosionResistance( Entity entity, World world, int i, int j, int k )
-    {
-        return getExplosionResistance( entity );
-    }
-    
-    public boolean CanBlockStayDuringGenerate( World world, int i, int j, int k )
-    {
-    	// breaking this off into a separate function so that we can prevent certain blocks (like mushrooms) spawning under certain conditions without messing up worldgen or
-    	// its usual growth conditions
-    	
-    	// NOTE: This function isn't called for all types of WorldGen to avoid excessive base class changes where not needed.  If you want to override it, make sure it is called
-    	// appropriately for the block in question first.
-    	
-    	return canBlockStay( world, i, j, k );
-    }
-    
-    /**
-     * Used to determine if this is a stair block for purposes of connecting visually to others
-     */
-    public boolean IsStairBlock()
-    {
-    	return false;
-    }
-    
-    public boolean ShouldDeleteTileEntityOnBlockChange( int iNewBlockID )
-    {
-    	return true;
-    }
-
-    /** 
-     * Determines whether other stone will "connect" to this block for purposes of determing whether
-     * a stone block can be individually harvested without breaking apart
-     */
-    public boolean IsNaturalStone( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-
-    static public AxisAlignedBB GetFulBlockBoundingBoxFromPool( World world, int i, int j, int k )
-    {
-    	return AxisAlignedBB.getAABBPool().getAABB(
-    		(float)i, (float)j, (float)k, 
-    		(float)i + 1.0F, (float)j + 1.0F, (float)k + 1.0F );	    	
-    }
-    
-    public boolean CanSpitWebReplaceBlock( World world, int i, int j, int k )
-    {
-    	return IsGroundCover( ) || IsAirBlock();
-    }
-    
-    public boolean IsAirBlock()
-    {
-    	return false;
-    }
-    
-    public boolean IsReplaceableVegetation( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-	public boolean HasWaterToSidesOrTop( World world, int i, int j, int k )
-	{
-		for ( int iFacing = 1; iFacing <= 5; iFacing++ )
-		{		
-			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iFacing );
-		
-			int iTempBlockID = world.getBlockId( tempPos.i, tempPos.j, tempPos.k );
-			Block tempBlock = Block.blocksList[iTempBlockID];
-			
-			if ( tempBlock != null && tempBlock.blockMaterial == Material.water )
-			{
-				return true;
-			}			
-		}
-		
-		return false;
-	}
-
-	public boolean GetPreventsFluidFlow( World world, int i, int j, int k, Block fluidBlock )
-	{
-        return blockMaterial == Material.portal ? true : blockMaterial.blocksMovement();
-	}
-
-	public void OnFluidFlowIntoBlock( World world, int i, int j, int k, BlockFluid fluidBlock )
-	{
-        dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
-	}
-
-	public boolean IsBlockClimbable( World world, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	/** 
-	 * Whether or not the block sets off Buddy Blocks.  Set to false for stuff like redstone blocks
-	 * that can cause feedback loops.
-	 */
-	public boolean TriggersBuddy()
-	{
-		return true;
-	}
-	
-    //------------ Harvesting related functionality ----------//
-    
-    protected boolean canSilkHarvest( int iMetadata )
-    {
-    	return canSilkHarvest();
-    }
-    
-    /**
-     * Called on server only, after the block is removed from the world
-     */
-    public void OnBlockDestroyedWithImproperTool( World world, EntityPlayer player, int i, int j, int k, int iMetadata )
-    {
-        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyedWithImproperToolAuxFXID, i, j, k, blockID + ( iMetadata << 12 ) );
-    	
-    	DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, 1F );
-    }
-    
-    protected void DropItemsIndividualy( World world, int i, int j, int k, int iIDDropped, int iPileCount, int iDamageDropped, float fChanceOfPileDrop )
-	{
-    	for ( int iTempCount = 0; iTempCount < iPileCount; iTempCount++ )
-    	{
-    		if ( world.rand.nextFloat() <= fChanceOfPileDrop )
-    		{
-	    		ItemStack stack = new ItemStack( iIDDropped, 1, iDamageDropped );
-	    		
-	            dropBlockAsItem_do( world, i, j, k, stack );
-    		}
-    	}
-	}
-    
-    /**
-     * Called by explosions and improper tool use.  
-     * Should return true if the block processes its own drops through this method, false otherwise
-     * Note that the block may no longer be at the specified position when this is called
-     */
-    public boolean DropComponentItemsOnBadBreak( World world, int i, int j, int k, int iMetadata, float fChanceOfDrop )
-    {
-    	return false;
-    }
-	
-    /**
-     * Explosion may be null if this is called by a mining charge
-     */
-    public void DropItemsOnDestroyedByExplosion( World world, int i, int j, int k, Explosion explosion )
-    {
-        if ( !world.isRemote && canDropFromExplosion( explosion ) )
-        {
-        	float fChance = 1F;
-        	
-        	if ( explosion != null )
-        	{
-        		fChance /= explosion.explosionSize;
-        	}
-        	
-        	int iMetadata = world.getBlockMetadata( i, j, k );
-
-        	if ( !DropComponentItemsOnBadBreak( world, i, j, k, iMetadata, fChance ) )
-        	{
-        		dropBlockAsItemWithChance( world, i, j, k, iMetadata, fChance, 0 );
-        	}
-        }
-    }
-	
-    /**
-     * Notifies neighbors of dirt blocks that they should be loosened
-     */
-    protected void OnDirtDugWithImproperTool( World world, int i, int j, int k )
-    {
-    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
-    	{
-    		NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );    		    		
-    	}
-    }
-    
-    protected void OnDirtSlabDugWithImproperTool( World world, int i, int j, int k, 
-    	boolean bUpsideDown )
-    {
-    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
-    	{
-	        if ( !( bUpsideDown && iTempFacing == 0 ) && !( !bUpsideDown && iTempFacing == 1 ) )
-	        {
-	        	NotifyNeighborDirtDugWithImproperTool( world, i, j, k, iTempFacing );
-	        }
-    	}
-    }
-    
-    protected void NotifyNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
-    	int iToFacing )
-    {
-		FCUtilsBlockPos neighborPos = new FCUtilsBlockPos( i, j, k, iToFacing );
-		
-		int iTargetBlockID = world.getBlockId( neighborPos.i, neighborPos.j, neighborPos.k );
-		
-		Block targetBlock = blocksList[iTargetBlockID];
-		
-		if ( targetBlock != null )
-		{    	
-			targetBlock.OnNeighborDirtDugWithImproperTool( world, 
-				neighborPos.i, neighborPos.j, neighborPos.k, GetOppositeFacing( iToFacing ) );
-		}    		
-    }
-    
-    protected void OnNeighborDirtDugWithImproperTool( World world, int i, int j, int k, 
-    	int iToFacing )
-    {
-    }
-    
-    //------------ Hard Point related functionality ----------//
-    
-	/**
-	 * small attachment surfaces, like those required for the bottom of a torch (approx 1/8 block width)
-	 */
-	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
-	{
-		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
-	}
-	
-	public boolean HasSmallCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return HasSmallCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
-	}
-
-	/**
-	 * medium sized attachment points like the top of fence posts (approx 1/4 block width)
-	 */
-	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
-	{
-		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
-	}
-
-	public boolean HasCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return HasCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
-	}
-
-	/**
-	 * large attachment points that can support a full block width
-	 */	
-	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
-	{
-		return blockAccess.isBlockNormalCube( i, j, k );
-	}
-
-	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, false );
-	}
-	
-	/**
-	 * returns true if the block is sitting on the one below, like a torch resting on the ground
-	 */
-	public boolean IsBlockRestingOnThatBelow( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	/**
-	 * returns true if block is attached to a block in a particular direction.  Example: pumpkins attached to stems
-	 */
-	public boolean IsBlockAttachedToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return false;
-	}
-	
-	public void AttachToFacing( World world, int i, int j, int k, int iFacing )
-	{
-	}
-	
-	public boolean HasContactPointToFullFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return blockAccess.isBlockNormalCube( i, j, k );
-	}
-	
-	public boolean HasContactPointToSlabSideFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIsSlabUpsideDown )
-	{
-		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
-	}
-	
-	/**
-	 * This method refers to the 'L' shaped sides of stair blocks.  Other stair facings will refernce either the full face,
-	 * or slab methods, depending on their shape
-	 */
-	public boolean HasContactPointToStairShapedFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-	{
-		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
-	}
-	
-	/**
-	 * This method refers to the half-block shaped top or bottom of stair blocks.
-	 */
-	public boolean HasContactPointToStairNarrowVerticalFace( IBlockAccess blockAccess, int i, int j, int k, int iFacing, int iStairFacing )
-	{
-		return HasContactPointToFullFace( blockAccess, i, j, k, iFacing );
-	}
-	
-	/**
-	 * Should return true if mortar has been successfully applied to block.
-	 */
-	public boolean OnMortarApplied( World world, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	public boolean HasMortar( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return false;
-	}
-	
-    public boolean HasNeighborWithMortarInContact( World world, int i, int j, int k )
-    {
-    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
-    	{
-    		if ( FCUtilsWorld.HasNeighborWithMortarInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
-			{
-				return true;
-			}
-    	}
-    	
-    	return false;
-    }
-    
-	public boolean IsStickyToSnow( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return false;
-	}
-	
-    public boolean HasStickySnowNeighborInContact( World world, int i, int j, int k )
-    {
-    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
-    	{
-    		if ( FCUtilsWorld.HasStickySnowNeighborInFullFaceContactToFacing( world, i, j, k, iTempFacing ) )
-			{
-				return true;
-			}
-    	}
-    	
-    	return false;
-    }
-    
-    //--------------- Fire related functionality -------------//
-    
-    private int m_iDefaultFurnaceBurnTime = 0;
-    
-    public int GetFurnaceBurnTime( int iItemDamage )
-    {
-    	return m_iDefaultFurnaceBurnTime;
-    }
-    
-    public void SetFurnaceBurnTime( int iBurnTime )
-    {
-    	m_iDefaultFurnaceBurnTime = iBurnTime;
-    }
-    
-    public void SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
-    {
-    	SetFurnaceBurnTime( burnTime.m_iBurnTime );
-    }
-    
-    public boolean DoesInfiniteBurnToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing )
-    {
-    	return false;
-    }
-    
-    public boolean DoesExtinguishFireAbove( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public void OnDestroyedByFire( World world, int i, int j, int k, int iFireAge, boolean bForcedFireSpread )
-    {
-        if ( bForcedFireSpread || ( world.rand.nextInt( iFireAge + 10 ) < 5 && 
-        	!world.IsRainingAtPos( i, j, k ) ) )
-        {
-            int iNewFireMetadata = iFireAge + world.rand.nextInt( 5 ) / 4;
-
-            if ( iNewFireMetadata > 15 )
-            {
-                iNewFireMetadata = 15;
-            }
-
-            world.setBlockAndMetadataWithNotify( i, j, k, Block.fire.blockID, iNewFireMetadata );
-        }
-        else
-        {
-            world.setBlockWithNotify( i, j, k, 0 );
-        }
-    }    
-    
-    public Block SetFireProperties( int iChanceToEncourageFire, int iAbilityToCatchFire )
-    {
-    	BlockFire.chanceToEncourageFire[blockID] = iChanceToEncourageFire;
-    	BlockFire.abilityToCatchFire[blockID] = iAbilityToCatchFire;
-    	
-    	return this;
-    }
-    
-    public Block SetFireProperties( FCEnumFlammability flammability )
-    {
-    	return SetFireProperties( flammability.m_iChanceToEncourageFire, 
-    		flammability.m_iAbilityToCatchFire );
-    }
-    
-    /**
-     * Whether the block itself can be set on fire, rather than a neighboring block being set to a fire block
-     */
-    public boolean GetCanBeSetOnFireDirectly( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean GetCanBeSetOnFireDirectlyByItem( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return GetCanBeSetOnFireDirectly( blockAccess, i, j, k );
-    }
-    
-    public boolean SetOnFireDirectly( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public int GetChanceOfFireSpreadingDirectlyTo( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return 0;
-    }
-    
-    public boolean GetCanBlockLightItemOnFire( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k, Entity entity )
-    {
-    	return GetDoesFireDamageToEntities( world, i, j, k );
-    }
-    
-    public boolean GetDoesFireDamageToEntities( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-
-    /**
-     * Used by Hibachi to determine if it can remove the block above it when lit
-     */
-    public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
-    {
-		return Block.fire.canBlockCatchFire( world, i, j, k ) || !blockMaterial.blocksMovement();
-    }
-    
-    /** 
-     * Whether a fire block can be directly placed over this one, without first burning or catching fire, as if it were air.
-     */
-    public boolean GetCanBlockBeReplacedByFire( World world, int i, int j, int k )
-    {
-    	return IsAirBlock();
-    }
-    
-    public boolean IsIncineratedInCrucible()
-    {
-    	return FCBlockFire.CanBlockBeDestroyedByFire( blockID );
-    }
-    
-    //------------- Pathing related functionality ------------//
-    
-    public boolean CanPathThroughBlock( IBlockAccess blockAccess, int i, int j, int k, 
-    	Entity entity, PathFinder pathFinder )
-    {
-		// note: getBlocksMovement() is misnamed and returns if the block *doesn't* block movement
-    	
-    	return getBlocksMovement( blockAccess, i, j, k );
-    }
-    
-    /**
-     * Used to determine if entities who start their pathing from within this block
-     * should instead start pathing from a neighbor block instead, to prevent getting stuck
-     * in this one.  Mostly applies to stuff like chickens getting stuck in fences.
-     */
-    public boolean ShouldOffsetPositionIfPathingOutOf( IBlockAccess blockAccess, 
-    	int i, int j, int k, Entity entity, PathFinder pathFinder )
-    {
-    	return !CanPathThroughBlock( blockAccess, i, j, k, entity, pathFinder );
-    }
-    
-    public int GetWeightOnPathBlocked( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return 0;
-    }    
-    
-    public int AdjustPathWeightOnNotBlocked( int iPreviousWeight )
-    {
-    	return iPreviousWeight;
-    }
-    
-    public boolean IsBreakableBarricade( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-
-    public boolean IsBreakableBarricadeOpen( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    //------------- Kiln related functionality ------------//
-    
-    private boolean m_bCanBeCookedByKiln = false;
-    private int m_iItemIndexDroppedWhenCookedByKiln = -1;
-    private int m_iItemDamageDroppedWhenCookedByKiln = 0;
-    
-    public Block SetCanBeCookedByKiln( boolean bCanBeCooked )
-    {
-    	m_bCanBeCookedByKiln = bCanBeCooked;
-    	
-    	return this;
-    }
-    
-    public boolean GetCanBeCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return m_bCanBeCookedByKiln;
-    }    
-    
-    public int GetCookTimeMultiplierInKiln( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return 1;
-    }    
-    
-    public Block SetItemIndexDroppedWhenCookedByKiln( int iItemIndex )
-    {
-    	m_iItemIndexDroppedWhenCookedByKiln = iItemIndex;
-    	
-    	return this;
-    }
-    
-    public int GetItemIndexDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return m_iItemIndexDroppedWhenCookedByKiln;
-    }
-    
-    public Block SetItemDamageDroppedWhenCookedByKiln( int iItemDamage )
-    {
-    	m_iItemDamageDroppedWhenCookedByKiln = iItemDamage;
-    	
-    	return this;
-    }
-    
-    public int GetItemDamageDroppedWhenCookedByKiln( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return m_iItemDamageDroppedWhenCookedByKiln;
-    }
-    
-    public void OnCookedByKiln( World world, int i, int j, int k )
-    {
-    	int iItemDropped = GetItemIndexDroppedWhenCookedByKiln( world, i, j, k );
-    	
-    	if ( iItemDropped >= 0 )
-    	{
-    		int iDamageDropped = GetItemDamageDroppedWhenCookedByKiln( world, i, j, k );
-    		
-        	world.setBlockToAir( i, j, k );
-
-        	if ( iItemDropped > 0 )
-        	{
-        		FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, iItemDropped, iDamageDropped );
-        	}
-    	}
-    }
-    
-    //------------- Saw related functionality ------------//
-    
-    public boolean DoesBlockBreakSaw( World world, int i, int j, int k )
-    {
-    	if ( blockMaterial.isSolid() )
-    	{
-	    	if ( blockMaterial != Material.wood && 
-	    		blockMaterial != Material.cactus && 
-	    		blockMaterial != Material.pumpkin &&
-	    		blockMaterial != Material.leaves &&
-	    		blockMaterial != Material.plants &&
-	    		blockMaterial != Material.vine &&
-	    		blockMaterial != Material.snow &&
-	    		blockMaterial != Material.craftedSnow &&
-	    		blockMaterial != FCBetterThanWolves.fcMaterialLog &&
-	    		blockMaterial != FCBetterThanWolves.fcMaterialPlanks &&
-	    		blockMaterial != FCBetterThanWolves.fcMaterialAsh
-			)
-	    	{
-				return true;
-	    	}
-    	}
-    	
-    	return false;
-    }
-
-    /*
-     * returns true if the block has been sawed, false otherwise
-     */
-    public boolean OnBlockSawed( World world, int i, int j, int k, int iSawPosI, int iSawPosJ, int iSawPosK )
-    {
-    	return OnBlockSawed( world, i, j, k );
-    }
-    
-    /*
-     * returns true if the block has been sawed, false otherwise
-     */
-    public boolean OnBlockSawed( World world, int i, int j, int k )
-    {		
-    	int iItemIDDropped = GetItemIDDroppedOnSaw( world, i, j, k ); 
-    	
-    	if (  iItemIDDropped >= 0 )
-    	{
-    		int iItemCountDropped = GetItemCountDroppedOnSaw( world, i, j, k );
-    		int iItemDamageDropped = GetItemDamageDroppedOnSaw( world, i, j, k );
-    		
-    		for ( int iTempCount = 0; iTempCount < iItemCountDropped; iTempCount++ )
-    		{
-				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j, k, 
-					iItemIDDropped, iItemDamageDropped );
-    		}
-    	}
-    	else
-    	{
-    		if ( !DoesBlockDropAsItemOnSaw( world, i, j, k ) )
-        	{
-    			return false;
-        	}
-        	
-			dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
-    	}
-    	
-    	world.setBlockToAir( i, j, k );
-    	
-    	return true;
-    }
-    
-    public int GetItemIDDroppedOnSaw( World world, int i, int j, int k )
-    {
-    	return -1;
-    }
-    
-    public int GetItemCountDroppedOnSaw( World world, int i, int j, int k )
-    {
-    	return 0;
-    }
-    
-    public int GetItemDamageDroppedOnSaw( World world, int i, int j, int k )
-    {
-    	return 0;
-    }
-    
-    public boolean DoesBlockDropAsItemOnSaw( World world, int i, int j, int k )
-    {
-    	return blockMaterial.isSolid();
-    }
-    
-    //------------- Mechanical power related functionality ------------//
-    
-    public int GetMechanicalPowerLevelProvidedToAxleAtFacing( World world, int i, int j, int k, int iFacing )
-    {
-    	return 0;
-    }    
-    
-    //------------- Tool effectiveness functionality ------------//
-    
-    private boolean m_bShovelsEffectiveOn = false;
-    private boolean m_bPicksEffectiveOn = false;
-    private boolean m_bAxesEffectiveOn = false;
-    private boolean m_bHoesEffectiveOn = false;
-    
-    private boolean m_bChiselsEffectiveOn = false;
-    private boolean m_bChiselsCanHarvest = false;
-    
-    public boolean AreShovelsEffectiveOn()
-    {
-    	return m_bShovelsEffectiveOn;
-    }
-    
-    public boolean ArePicksEffectiveOn()
-    {
-    	return m_bPicksEffectiveOn;
-    }
-    
-    public boolean AreAxesEffectiveOn()
-    {
-    	return m_bAxesEffectiveOn;
-    }
-    
-    public boolean AreHoesEffectiveOn()
-    {
-    	return m_bHoesEffectiveOn;
-    }
-    
-    public boolean AreChiselsEffectiveOn()
-    {
-    	return m_bChiselsEffectiveOn;
-    }
-    
-    public boolean AreChiselsEffectiveOn( World world, int i, int j, int k )
-    {
-    	return AreChiselsEffectiveOn();
-    }
-    
-    public boolean CanChiselsHarvest()
-    {
-    	return m_bChiselsCanHarvest;
-    }
-    
-    public Block SetShovelsEffectiveOn() { return SetShovelsEffectiveOn( true ); }
-    public Block SetShovelsEffectiveOn( boolean bEffective )
-    {
-    	m_bShovelsEffectiveOn = bEffective;
-    	
-    	return this;
-    }
-    
-    public Block SetPicksEffectiveOn() { return SetPicksEffectiveOn( true ); }
-    public Block SetPicksEffectiveOn( boolean bEffective )
-    {
-    	m_bPicksEffectiveOn = bEffective;
-    	
-    	return this;
-    }
-    
-    public Block SetAxesEffectiveOn() { return SetAxesEffectiveOn( true ); }
-    public Block SetAxesEffectiveOn( boolean bEffective )
-    {
-    	m_bAxesEffectiveOn = bEffective;
-    	
-    	return this;
-    }
-    
-    public Block SetHoesEffectiveOn() { return SetHoesEffectiveOn( true ); }
-    public Block SetHoesEffectiveOn( boolean bEffective )
-    {
-    	m_bHoesEffectiveOn = bEffective;
-    	
-    	return this;
-    }
-    
-    public Block SetChiselsEffectiveOn() { return SetChiselsEffectiveOn( true ); }
-    public Block SetChiselsEffectiveOn( boolean bEffective )
-    {
-    	m_bChiselsEffectiveOn = bEffective;
-    	
-    	return this;
-    }
-    
-    public Block SetChiselsCanHarvest() { return SetChiselsCanHarvest( true ); }
-    public Block SetChiselsCanHarvest( boolean bCanHarvest )
-    {
-    	m_bChiselsCanHarvest = bCanHarvest;
-    	
-    	return this;
-    }
-    
-    public float getPlayerRelativeBlockHardness( EntityPlayer player, World world, int i, int j, int k )
-    {
-        float fBlockHardness = getBlockHardness( world, i, j, k );
-        
-        if ( fBlockHardness >= 0F )
-        {
-            float fRelativeHardness = player.getCurrentPlayerStrVsBlock( this, i, j, k ) / fBlockHardness;
-            
-        	if ( player.IsCurrentToolEffectiveOnBlock( this, i, j, k ) )
-        	{
-        		return fRelativeHardness / 30F;
-        	}
-        	else
-        	{
-        		return fRelativeHardness / 200F;
-        	}
-        }
-        else
-        {
-        	return 0F; 
-        }
-    }
-    
-    public boolean CanConvertBlock( ItemStack stack, World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    /**
-     * Returns false if the block has not been replaced with another, and should be removed
-     */
-    public boolean ConvertBlock( ItemStack stack, World world, int i, int j, int k, int iFromSide )
-    {
-    	return false;
-    }
-    
-    public int GetEfficientToolLevel( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return 0;
-    }
-    
-    public int GetHarvestToolLevel( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return GetEfficientToolLevel( blockAccess, i, j, k );
-    }
-    
-    /**
-     * The following is for stumps and such, which are a pain to remove regardless of whether their overall block has
-     * relevant tool effeciencies
-     */
-    public boolean GetIsProblemToRemove( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean GetDoesStumpRemoverWorkOnBlock( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean CanToolsStickInBlock( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return true;
-    }
-    
-    //------------- Buoyancy related functionality ------------//
-    
-	private float m_fBuoyancy = -1.0F;
-	
-    public Block SetBuoyancy( float fBuoyancy )
-    {
-    	m_fBuoyancy = fBuoyancy;
-    	
-    	return this;
-    }
-    
-    public Block SetBuoyant() { return SetBuoyancy( 1F ); }
-    public Block SetNonBuoyant() { return SetBuoyancy( -1F ); }
-    public Block SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
-    
-    public float GetBuoyancy( int iMetadata )
-    {
-    	return m_fBuoyancy;
-    }
-    
-    //------------- Ground cover related functionality ------------//
-    
-    public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
-    {
-    	if ( world.doesBlockHaveSolidTopSurface( i, j, k ) )
-    	{
-    		return true;
-    	}
-    	
-    	return false;
-    }
-
-    public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return 0F;
-    }
-    
-    public boolean IsGroundCover()
-    {
-    	return false;
-    }
-    
-    public boolean AttempToSpreadGrassToBlock( World world, int i, int j, int k )
-    {
-    	if ( GetCanGrassSpreadToBlock( world, i, j, k ) &&
-        	world.GetBlockNaturalLightValueMaximum( i, j + 1, k ) >= 
-    		FCBlockGrass.m_iGrassSpreadToLightLevel && 
-        	Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
-    		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
-    	{
-    		return SpreadGrassToBlock( world, i, j, k );
-    	}
-    	
-    	return false;
-    }
-    
-    public boolean GetCanGrassSpreadToBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean SpreadGrassToBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean GetCanGrassGrowUnderBlock( World world, int i, int j, int k, boolean bGrassOnHalfSlab )
-    {
-    	if ( !bGrassOnHalfSlab )
-    	{
-    		return !HasLargeCenterHardPointToFacing( world, i, j, k, 0 );
-    	}
-    	
-    	return true;
-    }
-    
-    public boolean AttempToSpreadMyceliumToBlock( World world, int i, int j, int k )
-    {
-    	if ( GetCanMyceliumSpreadToBlock( world, i, j, k ) &&
-    		world.getBlockLightValue( i, j + 1, k ) >= 
-    		FCBlockMycelium.m_iMyceliumSpreadToMinimumLightLevel &&
-    		Block.lightOpacity[world.getBlockId( i, j + 1, k )] <= 2 &&
-    		!FCBlockGroundCover.IsGroundCoverRestingOnBlock( world, i, j, k ) )    		
-    	{
-			return SpreadMyceliumToBlock( world, i, j, k );
-    	}
-    	
-    	return false;
-    }
-    
-    public boolean GetCanMyceliumSpreadToBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean SpreadMyceliumToBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean GetCanBlightSpreadToBlock( World world, int i, int j, int k, int iBlightLevel )
-    {
-    	return false;
-    }
-    
-    /**
-     * Used by blocks like grass and mycellium to determine if they should use a snow side
-     * texture.  Note that this refers to the top visible surface, not just the top facing,
-     * which means that stuff like half-slabs should only return true if they have ground cover
-     * actually on the top surface halfway up the block vertically.
-     */ 
-    public boolean IsSnowCoveringTopSurface( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	int iBlockAboveID = blockAccess.getBlockId( i, j + 1, k );
-    	
-    	if ( iBlockAboveID != 0 )
-    	{
-    		Block blockAbove = blocksList[iBlockAboveID];
-    		
-    		Material aboveMaterial = blockAbove.blockMaterial;
-    		
-	        if ( aboveMaterial == Material.snow || aboveMaterial == Material.craftedSnow && 
-	        	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 ) )
-	        {
-	        	return true;
-	        }
-	        else if ( 
-	        	blockAbove.GroundCoverRestingOnVisualOffset( blockAccess, i, j + 1, k ) < -0.99F && 
-	        	blockAccess.getBlockId( i, j + 2, k ) == snow.blockID )
-	        {
-	        	// consider snow resting on tall grass and such
-	        	
-	        	return true;
-	        }
-    	}
-    	
-    	return false;
-    }
-    
-    //---------- Piston Related Functionality ---------//
-    
-    /**
-     * Returns the metadata that will be placed
-     */
-    public int OnPreBlockPlacedByPiston( World world, int i, int j, int k, int iMetadata, int iDirectionMoved )
-    {
-    	return iMetadata;
-    }
-    
-    public boolean CanBlockBePulledByPiston( World world, int i, int j, int k, int iToFacing )
-    {
-    	if ( getMobilityFlag() != 1 ) // blocks destroyed on push can not be pulled
-    	{
-    		return CanBlockBePushedByPiston( world, i, j, k, iToFacing );
-    	}
-    	
-    	return false;    	                         
-    }
-    
-    public boolean CanBlockBePushedByPiston( World world, int i, int j, int k, int iToFacing )
-    {
-        int iMobility = getMobilityFlag();
-        
-        return iMobility == 1 || ( iMobility != 2 && !( this instanceof ITileEntityProvider ) );
-    }
-    
-    public boolean CanBePistonShoveled( World world, int i, int j, int k )
-    {
-    	return AreShovelsEffectiveOn();
-    }
-    
-    /**
-     * returns the direction the shoveled block will go in if this block is moving towards iToFacing.  
-     * return -1 if it's no shoveling is taking place.
-     */
-    public int GetPistonShovelEjectDirection( World world, int i, int j, int k, int iToFacing )
-    {
-    	return -1;
-    }
-    
-    public AxisAlignedBB GetAsPistonMovingBoundingBox( World world, int i, int j, int k )
-    {
-    	return getCollisionBoundingBoxFromPool( world, i, j, k );
-    }
-    
-    public int AdjustMetadataForPistonMove( int iMetadata )
-    {
-    	return iMetadata;
-    }
-    
-    public boolean CanContainPistonPackingToFacing( World world, int i, int j, int k, int iFacing )
-    {
-    	return HasLargeCenterHardPointToFacing( world, i, j, k, iFacing, true );
-    }
-    
-    public boolean IsPistonPackable( ItemStack stack )
-    {
-    	return false;
-    }
-    
-    public int GetRequiredItemCountToPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    public void OnBrokenByPistonPush( World world, int i, int j, int k, int iMetadata )
-    {
-    	dropBlockAsItem( world, i, j, k, iMetadata, 0 );
-    }
-    
-    //------------- Hopper Filtering Functionality -----------//
-    
-    protected int m_iFilterablePropertiesBitfield = 0;
-    
-    public boolean CanItemPassIfFilter( ItemStack filteredItem )
-    {
-    	return true;
-    }
-    
-    public int GetFilterableProperties( ItemStack stack )
-    {
-    	return m_iFilterablePropertiesBitfield;
-    }
-    
-    public void SetFilterableProperties( int iProperties )
-    {
-    	m_iFilterablePropertiesBitfield = iProperties;
-    }
-    
-    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
-    {
-    	return false;
-    }
-    
-    //---------- Falling Block Functionality ----------//
-    
-    private static final int m_iLoadedRangeToCheckFalling = 32;
-    
-    public boolean IsFallingBlock()
-    {
-    	return false;
-    }
-    
-    protected boolean CheckForFall( World world, int i, int j, int k)
-    {
-        if ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j >= 0 )
-        {
-            if ( !BlockSand.fallInstantly && world.checkChunksExist( 
-            	i - m_iLoadedRangeToCheckFalling, j - m_iLoadedRangeToCheckFalling, k - m_iLoadedRangeToCheckFalling, 
-            	i + m_iLoadedRangeToCheckFalling, j + m_iLoadedRangeToCheckFalling, k + m_iLoadedRangeToCheckFalling ) )
-            {
-                if ( !world.isRemote )
-                {
-                	FCEntityFallingBlock fallingEntity = new FCEntityFallingBlock( world, (double)i + 0.5D, (double)j + 0.5D, (double)k + 0.5D, 
-                    	blockID, world.getBlockMetadata( i, j, k ) );
-                    
-                    onStartFalling( fallingEntity );
-                    
-                    world.spawnEntityInWorld( fallingEntity );
-                }
-                
-                return true;
-            }
-            else
-            {
-                world.setBlockToAir( i, j, k );
-
-                while ( CanFallIntoBlockAtPos( world, i, j - 1, k ) && j > 0 )
-                {
-                    j--;
-                }
-
-                if ( j > 0 )
-                {
-                    world.setBlock( i, j, k, blockID );
-                }
-                
-                return true;
-            }
-        }
-        
-        return false;
-    }
-
-    /**
-     * Only called on server
-     */
-    protected void onStartFalling( EntityFallingSand entity ) {}
-    
-    /**
-     * This is actually called when a block lands safely.  Do not rename as BlockSand has a child method off of this
-     */
-    public void onFinishFalling( World world, int i, int j, int k, int iMetadata )
-    {
-    	NotifyNearbyAnimalsFinishedFalling( world, i, j, k );
-    }
-    
-    protected void OnFallingUpdate( FCEntityFallingBlock entity ) {}
-    
-    public void NotifyNearbyAnimalsFinishedFalling( World world, int i, int j, int k )
-    {
-    	if ( !world.isRemote )
-    	{
-            EntityPlayer entityPlayer = world.getClosestPlayer((float)i + 0.5F, (float)j + 0.5F, (float)k + 0.5F, 64D );
-            
-            if ( entityPlayer != null )
-            {
-            	world.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( entityPlayer, this, i, j, k );
-            }
-    	}
-    }
-    
-	/**
-	 * returns true if the block still exists
-	 */
-    public boolean OnFinishedFalling( EntityFallingSand entity, float fFallDistance )
-    {
-    	return true;
-    }
-    
-    /**
-     * returns true if the block has combined with the entity
-     */
-    public boolean AttemptToCombineWithFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
-    {
-    	return false;
-    }
-    
-    public boolean CanBeCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
-    {
-    	return false;
-    }
-    
-    public void OnCrushedByFallingEntity( World world, int i, int j, int k, EntityFallingSand entity )
-    {
-    }
-    
-    protected boolean CanFallIntoBlockAtPos( World world, int i, int j, int k )
-    {
-    	Block targetBlock = Block.blocksList[world.getBlockId( i, j, k )];
-
-    	return targetBlock == null || !targetBlock.CanSupportFallingBlocks( world, i, j, k );
-    }
-    
-    public boolean CanSupportFallingBlocks( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return HasCenterHardPointToFacing( blockAccess, i, j, k, 1, true );    	
-    }
-    
-    protected void CheckForUnstableGround( World world, int i, int j, int k )
-    {
-    	for ( int iJOffset = 1; iJOffset <= 16; iJOffset++ )
-    	{
-    		int iTempJ = j - iJOffset;
-    		
-    		if ( iTempJ <= 0 )
-    		{
-    			break;
-    		}
-    		else
-    		{
-    	        if( world.isAirBlock( i, iTempJ, k ) )
-    	        {
-    	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
-    	        	
-    	        	break;
-    	        }
-    	        else
-    	        {    	        	
-    	        	int iTempBlockID = world.getBlockId( i, iTempJ, k );
-    	        	
-    	        	if ( iTempBlockID == Block.fire.blockID )
-    	        	{
-        	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
-        	        	
-        	        	break;
-    	        	}
-    	        	else
-    	        	{
-    	        		Block tempBlock = Block.blocksList[iTempBlockID];
-    	        		
-    	        		if ( tempBlock.blockMaterial == Material.water || tempBlock.blockMaterial == Material.lava )
-    	        		{
-            	        	world.notifyBlockOfNeighborChange( i, iTempJ + 1, k, 0 );
-            	        	
-            	        	break;
-    	        		}
-    	        		else if ( !tempBlock.IsFallingBlock() )
-    	        		{
-    	        			break;
-    	        		}
-    	        	}
-    	        }    			
-    		}
-    	}
-    }
-    
-    protected void ScheduleCheckForFall( World world, int i, int j, int k )
-    {
-        world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
-    }
-    
-    /**
-     * Called on server only
-     */
-    public void OnBlockDestroyedLandingFromFall( World world, int i, int j, int k, int iMetadata )
-    {
-    	OnBlockDestroyedWithImproperTool( world, null, i, j, k, iMetadata );
-    }
-    
-    public boolean HasFallingBlockRestingOn( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	Block blockAbove = Block.blocksList[blockAccess.getBlockId( i, j + 1, k )];
-    	                                    
-        return blockAbove != null && blockAbove.IsFallingBlock() && 
-        	blockAbove.HasCenterHardPointToFacing( blockAccess, i, j + 1, k, 0 );
-    }
-    
-	//----------- Block Facing Functionality ----------//
-	
-	public int GetFacing( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return GetFacing( blockAccess.getBlockMetadata( i, j, k ) );
-	}
-	
-	public int GetFacing( int iMetadata )
-	{
-		return 0;
-	}
-	
-	public void SetFacing( World world, int i, int j, int k, int iFacing )
-	{
-		int iMetadata = world.getBlockMetadata( i, j, k );
-		
-		int iNewMetadata = SetFacing( iMetadata, iFacing );
-		
-		if ( iNewMetadata != iMetadata )
-		{
-			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
-		}
-	}
-	
-	public int SetFacing( int iMetadata, int iFacing )
-	{
-		return iMetadata;
-	}
-	
-	/**
-	 * Cycle through all the possible facings for a block 
-	 * returns true if the facing has actually changed as a result of this call
-	 */
-	public boolean ToggleFacing( World world, int i, int j, int k, boolean bReverse )
-	{
-		return RotateAroundJAxis( world, i, j, k, bReverse );
-	}
-	
-    public int ConvertFacingToTopTextureRotation( int iFacing )
-    {
-    	if ( iFacing >= 2 )
-    	{
-    		if ( iFacing <= 3 )
-    		{
-    			if ( iFacing == 3 )
-    			{
-    				return 3;
-    			}
-    		}
-    		else
-    		{
-    			if ( iFacing == 4 )
-    			{
-    				return 2;
-    			}
-    			else // iFacing == 5
-    			{
-    				return 1;
-    			}
-    		}
-    	}
-    	
-    	return 0;
-    }
-    
-    public int ConvertFacingToBottomTextureRotation( int iFacing )
-    {
-    	if ( iFacing >= 2 )
-    	{
-    		if ( iFacing <= 3 )
-    		{
-    			if ( iFacing == 3 )
-    			{
-    				return 3;
-    			}
-    		}
-    		else
-    		{
-    			if ( iFacing == 4 )
-    			{
-    				return 1;
-    			}
-    			else // iFacing == 5
-    			{
-    				return 2;
-    			}
-    		}
-    	}
-    	
-    	return 0;
-    }
-    
-	static public int GetOppositeFacing( int iFacing )
-	{
-		return iFacing ^ 1;
-	}
-	
-	static public int RotateFacingAroundJ( int iFacing, boolean bReverse )
-	{
-		if ( bReverse )
-		{
-			return m_iRotatedFacingsAroundJCounterclockwise[iFacing];
-		}
-		
-		return m_iRotatedFacingsAroundJClockwise[iFacing];
-	}
-
-	static public int CycleFacing( int iFacing, boolean bReverse )
-	{
-		if ( bReverse )
-		{
-			return m_iCycledFacingsReversed[iFacing];
-		}
-		
-		return m_iCycledFacings[iFacing];
-	}
-
-    //-------- Turntable Related Functionality --------//
-	
-	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return blockAccess.isBlockNormalCube( i, j, k );
-	}	
-	
-	public boolean CanTransmitRotationHorizontallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return blockAccess.isBlockNormalCube( i, j, k );
-	}
-	
-	public boolean CanTransmitRotationVerticallyOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return blockAccess.isBlockNormalCube( i, j, k );
-	}
-	
-	/**
-	 * Returns the new crafting counter after rotation.  It is unmodified if no crafting has taken place, 
-	 * incremented or reset on completion if it has.
-	 */
-	public int RotateOnTurntable( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
-	{
-		OnRotatedOnTurntable( world, i, j, k );
-		
-		if ( !RotateAroundJAxis( world, i, j, k, bReverse ) )
-		{
-			// notify the surrounding blocks of a change if no facing change actually takes place, so that buddy can pick up on it
-			// this is because solid blocks still "rotate" even if their facing doesn't change
-			
-	    	world.notifyBlocksOfNeighborChange( i, j, k, blockID );	    	
-		}
-		
-		return iCraftingCounter;
-	}
-
-	/*
-	 * Intended to play block specific FX and such
-	 */
-	protected void OnRotatedOnTurntable( World world, int i, int j, int k )
-	{
-	}
-
-	protected int TurntableCraftingRotation( World world, int i, int j, int k, boolean bReverse, int iCraftingCounter )
-	{
-		iCraftingCounter++;
-		
-		if ( iCraftingCounter >= GetRotationsToCraftOnTurntable( world, i, j, k ) )
-		{
-			OnCraftedOnTurntable( world, i, j, k );
-			
-			int iNewBlockID = GetNewBlockIDCraftedOnTurntable( world, i, j, k );
-			int iNewBlockMetadata = GetNewMetadataCraftedOnTurntable( world, i, j, k );
-			int iItemIDDropped = GetItemIDCraftedOnTurntable( world, i, j, k );
-			int iItemCountDropped = GetItemCountCraftedOnTurntable( world, i, j, k );
-			int iItemDamageDropped = GetItemDamageCraftedOnTurntable( world, i, j, k );
-			
-			for ( int tempCount = 0; tempCount < iItemCountDropped; tempCount++ )
-			{
-				FCUtilsItem.EjectSingleItemWithRandomOffset( world, i, j + 1, k, iItemIDDropped, iItemDamageDropped );			
-			}
-
-			world.setBlockAndMetadataWithNotify( i, j, k, iNewBlockID, iNewBlockMetadata );			
-			
-			iCraftingCounter = 0;
-		}
-		
-		return iCraftingCounter;
-	}
-	
-	public int GetRotationsToCraftOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 1;
-	}
-	
-	public void OnCraftedOnTurntable( World world, int i, int j, int k )
-	{
-        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
-        	i, j, k, world.getBlockId( i, j, k ) + ( world.getBlockMetadata( i, j, k ) << 12 ) );        
-	}
-	
-	public int GetNewBlockIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 0;
-	}
-	
-	public int GetNewMetadataCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 0;
-	}
-	
-	public int GetItemIDCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return Item.clay.itemID;
-	}
-	
-	public int GetItemCountCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 1;
-	}
-	
-	public int GetItemDamageCraftedOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 0;
-	}
-	
-	/**
-	 * Returns true if the facing has actually changed as a result of this call
-	 */
-	public boolean RotateAroundJAxis( World world, int i, int j, int k, boolean bReverse )
-	{
-		int iMetadata = world.getBlockMetadata( i, j, k );
-		
-		int iNewMetadata = RotateMetadataAroundJAxis( iMetadata, bReverse );
-		
-		if ( iNewMetadata != iMetadata )
-		{
-			world.setBlockMetadataWithNotify( i, j, k, iNewMetadata );
-			
-			return true;
-		}
-		
-		return false;
-	}
-
-	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
-	{
-		int iFacing = GetFacing( iMetadata );
-		
-		int iNewFacing = RotateFacingAroundJ( iFacing, bReverse );
-		
-		return SetFacing( iMetadata, iNewFacing );
-	}
-
-    public boolean CanRotateAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
-    {
-    	return false;
-    }
-    
-    /**
-     * Returns false if the block was destroyed and should not be rotated
-     */
-    public boolean OnRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iFacing  )
-    {
-    	return true;
-    }
-    
-    public int GetNewMetadataRotatedAroundBlockOnTurntableToFacing( World world, int i, int j, int k, int iInitialFacing, int iRotatedFacing )
-    {
-    	return 0;
-    }
-    
-    //----- Block Dispenser Related Functionality -----//
-    
-    /**
-     * If the stack returned is null, the block will not be retrieved
-     */
-    public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
-    {
-    	int iMetadata = world.getBlockMetadata( i, j, k );
-    	
-    	if ( canSilkHarvest( iMetadata ) )
-    	{
-    		return createStackedBlock( iMetadata );
-    	}
-    	
-    	int iIdDropped = idDropped( iMetadata, world.rand, 0 );
-    	
-    	if ( iIdDropped > 0 )
-    	{
-    		return new ItemStack( iIdDropped, 1, damageDropped( iMetadata ) );
-    	}
-    	
-    	return null;
-    }
-    
-    /**
-     * Whether a block is destroyed by the dispenser, even if no item is collected
-     */
-    public boolean IsBlockDestroyedByBlockDispenser( int iMetadata )
-    {
-    	return false;
-    }
-    
-    public void OnRemovedByBlockDispenser( World world, int i, int j, int k )
-    {
-        world.playAuxSFX( FCBetterThanWolves.m_iBlockDestroyRespectParticleSettingsAuxFXID, 
-        	i, j, k, blockID + ( world.getBlockMetadata( i, j, k ) << 12 ) );
-        
-    	world.setBlockWithNotify( i, j, k, 0 );
-    }
-    
-	//---------- Weather Related Functionality --------//
-    
-    /**
-     * Called on server only
-     */
-    public void OnStruckByLightning( World world, int i, int j, int k )
-    {
-    }
-    
-	//------- Mob Spawning Related Functionality ------//
-
-    /**
-     * This is only a first-pass indicator as to whether ANY mobs can spawn on top of the block,
-     * so stuff like leaves where only Jungle Spiders can spawn on them, should still return true.
-     */
-    public boolean CanMobsSpawnOn( World world, int i, int j, int k )
-    {
-        return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId ) &&
-        	getCollisionBoundingBoxFromPool( world, i, j, k ) != null;
-    }
-
-    public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
-    {
-    	return 0F;
-    }
-    
-	//-------- Collision Handling Functionality -------//
-    
-    /**
-     * This should never be modified after a block is initialized to avoid multithreading issues
-     * that occurred with the old min/max bounds variables.
-     */
-    private AxisAlignedBB m_fixedBlockBounds = new AxisAlignedBB( 0D, 0D, 0D, 1D, 1D, 1D );
-    private boolean m_bFixedBlockBoundsSet = false;
-
-    /**
-     * Should only ever be called once for a block.  Repeated calls will silently fail without
-     * changing the bounds.
-     */
-    protected void InitBlockBounds( double dMinX, double dMinY, double dMinZ, 
-    	double dMaxX, double dMaxY, double dMaxZ )
-    {
-    	if ( !m_bFixedBlockBoundsSet )
-    	{
-    		// only allow the bounds to be set before they're ever accessed to 
-    		// discourage the kind of errors that necessitated it in the first 
-    		// place: client and server threads modifying the min/max values 
-    		// resulting in race conditions.
-    		
-    		m_fixedBlockBounds.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );
-    	}
-    }
-
-    protected void InitBlockBounds( AxisAlignedBB bounds )
-    {
-    	if ( !m_bFixedBlockBoundsSet )
-    	{
-    		m_fixedBlockBounds.setBB( bounds );
-    	}
-    }
-    
-    protected AxisAlignedBB GetFixedBlockBoundsFromPool()
-    {
-		m_bFixedBlockBoundsSet = true;
-		
-    	return m_fixedBlockBounds.MakeTemporaryCopy();
-    }
-
-    public AxisAlignedBB getCollisionBoundingBoxFromPool( World world, int i, int j, int k )
-    {
-    	return GetBlockBoundsFromPoolBasedOnState( world, i, j, k ).offset( i, j, k );
-    }
-    
-    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
-    	IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return GetFixedBlockBoundsFromPool();
-    }
-    
-    public MovingObjectPosition collisionRayTrace( World world, int i, int j, int k, 
-    	Vec3 startRay, Vec3 endRay )
-    {
-    	return CollisionRayTraceVsBlockBounds( world, i, j, k, startRay, endRay );
-    }
-
-    public MovingObjectPosition MouseOverRayTrace( World world, int i, int j, int k, 
-    	Vec3 startRay, Vec3 endRay )
-    {
-    	return collisionRayTrace( world, i, j, k, startRay, endRay );
-    }
-
-    public MovingObjectPosition CollisionRayTraceVsBlockBounds( World world, int i, int j, int k, 
-    	Vec3 startRay, Vec3 endRay )
-    {
-    	AxisAlignedBB collisionBox = GetBlockBoundsFromPoolBasedOnState( 
-    		world, i, j, k ).offset( i, j, k );
-    	
-    	MovingObjectPosition collisionPoint = collisionBox.calculateIntercept( startRay, endRay );
-    	
-    	if ( collisionPoint != null )
-    	{
-    		collisionPoint.blockX = i;
-    		collisionPoint.blockY = j;
-    		collisionPoint.blockZ = k;
-    	}
-    	
-    	return collisionPoint;
-    }
-
-	//------------- Grazing Functionality -------------//
-    
-    private int m_iHerbivoreItemFoodValue = 0;
-    private int m_iBirdItemFoodValue = 0;
-    private int m_iPigItemFoodValue = 0;
-    
-    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
-    	EntityAnimal byAnimal )
-    {
-    	return false;
-    }
-    
-    public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
-    {
-        world.setBlockToAir( i, j, k );
-
-        Block blockBelow = blocksList[world.getBlockId( i, j - 1, k )];
-        
-        if ( blockBelow != null )
-        {
-        	blockBelow.OnVegetationAboveGrazed( world, i, j - 1, k, animal );
-        }
-    }
-    
-	public void OnVegetationAboveGrazed( World world, int i, int j, int k, EntityAnimal animal )
-	{
-	}
-	
-	/** 
-	 * Used when pigs dig up dirt to let any attached neighbors know that they should break loose
-	 */
-	public void NotifyNeighborsBlockDisrupted( World world, int i, int j, int k )
-	{
-		FCUtilsBlockPos pos = new FCUtilsBlockPos( i, j, k );
-		FCUtilsBlockPos tempPos = new FCUtilsBlockPos();
-		
-		for ( int iTempFacing = 0; iTempFacing <= 5; iTempFacing++ )
-		{
-			tempPos.Set( pos );			
-			tempPos.AddFacingAsOffset( iTempFacing );
-			
-			Block tempBlock = Block.blocksList[world.getBlockId( tempPos.i, tempPos.j, tempPos.k )];
-			
-			if ( tempBlock != null )
-			{
-				tempBlock.OnNeighborDisrupted( world, tempPos.i, tempPos.j, tempPos.k, 
-					GetOppositeFacing( iTempFacing ) );
-			}
-		}
-	}
-	
-	public void OnNeighborDisrupted( World world, int i, int j, int k, int iToFacing )
-	{
-	}
-	
-    public int GetHerbivoreItemFoodValue( int iItemDamage )
-    {
-    	return m_iHerbivoreItemFoodValue;
-    }
-    
-    public void SetHerbivoreItemFoodValue( int iFoodValue )
-    {
-    	m_iHerbivoreItemFoodValue = iFoodValue;
-    }
-    
-    public int GetChickenItemFoodValue( int iItemDamage )
-    {
-    	return m_iBirdItemFoodValue;
-    }
-    
-    public void SetChickenItemFoodValue( int iFoodValue )
-    {
-    	m_iBirdItemFoodValue = iFoodValue;
-    }
-    
-    public int GetPigItemFoodValue( int iItemDamage )
-    {
-    	return m_iPigItemFoodValue;
-    }
-    
-    public void SetPigItemFoodValue( int iFoodValue )
-    {
-    	m_iPigItemFoodValue = iFoodValue;
-    }
-    
-	//----------- Plant Growth Functionality ----------//
-    
-    public boolean CanDomesticatedCropsGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean CanReedsGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean CanSaplingsGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    /**
-     * Covers stuff like flowers and tall grass
-     */
-    public boolean CanWildVegetationGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean CanNetherWartGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    public boolean CanCactusGrowOnBlock( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-	public boolean IsBlockHydratedForPlantGrowthOn( World world, int i, int j, int k )
-	{
-		return false;
-	}
-
-	public boolean IsConsideredNeighbouringWaterForReedGrowthOn( World world, int i, int j, int k )
-	{
-		for ( int iTempI = i - 1; iTempI <= i + 1; iTempI++ )
-		{		
-			for ( int iTempK = k - 1; iTempK <= k + 1; iTempK++ )
-			{				
-				if ( world.getBlockMaterial( iTempI, j, iTempK ) == Material.water )
-				{
-					return true;
-				}
-			}
-		}
-
-		return false;
-	}
-	
-	/** 
-	 * This is used by old style non-daily plant growth
-	 */
-	public float GetPlantGrowthOnMultiplier( World world, int i, int j, int k, Block plantBlock )
-	{
-		return 1F;
-	}
-	
-	public boolean GetIsFertilizedForPlantGrowth( World world, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	/** 
-	 * Called when a plant hits a full growth stage, like wheat fully grown, 
-	 * or each full block of Hemp.  Used to clear fertilizer.
-	 */
-	public void NotifyOfFullStagePlantGrowthOn( World world, int i, int j, int k, Block plantBlock )
-	{
-	}
-	
-	/**
-	 * Called server only.  Called AFTER the plant is removed, so it's no longer valid.  
-	 */
-	public void NotifyOfPlantAboveRemoved( World world, int i, int j, int k, Block plantBlock )
-	{
-	}
-	
-	/**
-	 * This determines whether weeds can share space with crop blocks, or grow
-	 * within their own independent weed blocks
-	 */
-	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	/**
-	 * The growth level of weeds growing out of this block.  Range of 0 to 3 
-	 */
-	public int GetWeedsGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return 0;
-	}
-	
-	public void RemoveWeeds( World world, int i, int j, int k )
-	{
-	}
-	
-	public boolean AttemptToApplyFertilizerTo( World world, int i, int j, int k )
-	{
-		return false;
-	}
-	
-	public boolean GetConvertsLegacySoil( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return false;		
-	}
-	
-    //----------------- Integrity Test ----------------//
-    
-	static public boolean InstallationIntegrityTest()
-    {
-    	return true;
-    }
-    
-	//----------- Client Side Functionality -----------//    
-	// END FCMOD
 }
--- BlockCrops.java	Mon Feb 18 12:27:49 2019
+++ BlockCrops.java	Fri Apr 20 22:33:06 2018
@@ -9,10 +9,7 @@
         super(par1);
         this.setTickRandomly(true);
         float var2 = 0.5F;
-        // FCMOD: Changed
-        //this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
-        InitBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
-        //END FCMOD
+        this.setBlockBounds(0.5F - var2, 0.0F, 0.5F - var2, 0.5F + var2, 0.25F, 0.5F + var2);
         this.setCreativeTab((CreativeTabs)null);
         this.setHardness(0.0F);
         this.setStepSound(soundGrassFootstep);
@@ -23,20 +20,14 @@
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
-    // FCMOD: Removed as deprecated
-    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.tilledField.blockID;
     }
-    */
-    // END FCMOD
 
     /**
      * Ticks the block if it's been scheduled
      */
-    // FCMOD: Removed and replaced
-    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         super.updateTick(par1World, par2, par3, par4, par5Random);
@@ -57,8 +48,6 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Apply bonemeal to the crops.
@@ -80,8 +69,6 @@
      * different sides that aren't opposing, and by adding growth for every crop next to this one (and for crop below
      * this one). Args: x, y, z
      */
-    // FCMOD: Removed as deprecated
-    /*
     private float getGrowthRate(World par1World, int par2, int par3, int par4)
     {
         float var5 = 1.0F;
@@ -130,8 +117,6 @@
 
         return var5;
     }
-    */
-    // END FCMOD
 
     /**
      * The type of render function that is called for this block
@@ -168,8 +153,6 @@
         {
             if (par5 >= 7)
             {
-            	// FCMOD: Change
-            	/*
                 int var8 = 3 + par7;
 
                 for (int var9 = 0; var9 < var8; ++var9)
@@ -179,9 +162,6 @@
                         this.dropBlockAsItem_do(par1World, par2, par3, par4, new ItemStack(this.getSeedItem(), 1, 0));
                     }
                 }
-                */
-            	DropSeeds( par1World, par2, par3, par4, par5, par6, par7);
-            	// END FCMOD
             }
         }
     }
@@ -189,14 +169,10 @@
     /**
      * Returns the ID of the items to drop on destruction.
      */
-    // FCMOD: Removed and replaced
-    /*
     public int idDropped(int par1, Random par2Random, int par3)
     {
         return par1 == 7 ? this.getCropItem() : this.getSeedItem();
     }
-    */
-    // END FCMOD
 
     /**
      * Returns the quantity of items to drop on block destruction.
@@ -205,147 +181,4 @@
     {
         return 1;
     }
-    
-    // FCMOD: Added New
-    @Override
-    public int idDropped( int iMetadata, Random random, int iFortuneModifier )
-    {
-    	if ( iMetadata == 7 )
-    	{
-    		return getCropItem();
-    	}
-    	
-        return 0;
-    }
-    
-    @Override
-    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
-    	EntityAnimal animal )
-    {
-		return true;
-    }
-    
-    @Override
-    public void OnGrazed( World world, int i, int j, int k, EntityAnimal animal )
-    {
-    	// drop the block as an item so that animals can get the base graze value + eat
-    	// any tasties that drop
-    	
-        dropBlockAsItem( world, i, j, k, world.getBlockMetadata( i, j, k ), 0 );
-        
-        super.OnGrazed( world, i, j, k, animal );    
-    }
-    
-    @Override
-    public void updateTick( World world, int i, int j, int k, Random rand )
-    {
-        super.updateTick( world, i, j, k, rand );
-
-    	// make sure parent update didn't destroy the block, and prevent crops growing in the end
-    	// note that CanGrowOnBlock() has already been confirmed in parent method    	
-    	
-        if ( world.provider.dimensionId != 1 && 
-        	world.getBlockId( i, j, k ) == blockID )
-        {
-        	AttemptToGrow( world, i, j, k, rand );
-        }
-    }
-
-    @Override
-    protected boolean CanGrowOnBlock( World world, int i, int j, int k )
-    {
-    	Block blockOn = Block.blocksList[world.getBlockId( i, j, k )];
-    	
-    	return blockOn != null && blockOn.CanDomesticatedCropsGrowOnBlock( world, i, j, k );
-    }
-    
-	@Override
-	public boolean CanWeedsGrowInBlock( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return true;
-	}
-	
-    //------------- Class Specific Methods ------------//
-    
-    protected void AttemptToGrow( World world, int i, int j, int k, Random rand )
-    {
-    	if ( GetWeedsGrowthLevel( world, i, j, k ) == 0 && 
-    		GetGrowthLevel( world, i, j, k ) < 7 && 
-	    	world.getBlockLightValue( i, j + 1, k ) >= 9 )
-	    {
-	        Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
-	        
-	        if ( blockBelow != null && 
-	        	blockBelow.IsBlockHydratedForPlantGrowthOn( world, i, j - 1, k ) )
-	        {
-	    		float fGrowthChance = GetBaseGrowthChance( world, i, j, k ) *
-	    			blockBelow.GetPlantGrowthOnMultiplier( world, i, j - 1, k, this );
-	    		
-	            if ( rand.nextFloat() <= fGrowthChance )
-	            {
-	            	IncrementGrowthLevel( world, i, j, k );
-	            }
-	        }
-	    }
-    }
-    
-    public void DropSeeds( World world, int i, int j, int k, int iMetadata, 
-    	float fChance, int iFortuneModifier )
-    {
-        dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
-        
-        if ( world.rand.nextInt( 16 ) - iFortuneModifier < 4 )
-        {
-            dropBlockAsItem_do(world, i, j, k, new ItemStack( getSeedItem(), 1, 0 ) );
-        }
-    }
-    
-    public float GetBaseGrowthChance( World world, int i, int j, int k )
-    {
-    	return 0.05F;
-    }
-    
-    protected void IncrementGrowthLevel( World world, int i, int j, int k )
-    {
-    	int iGrowthLevel = GetGrowthLevel( world, i, j, k ) + 1;
-    	
-        SetGrowthLevel( world, i, j, k, iGrowthLevel );
-        
-        if ( iGrowthLevel == 7 )
-        {
-        	Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
-        	
-        	if ( blockBelow != null )
-        	{
-        		blockBelow.NotifyOfFullStagePlantGrowthOn( world, i, j - 1, k, this );
-        	}
-        }
-    }
-    
-    protected int GetGrowthLevel( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return GetGrowthLevel( blockAccess.getBlockMetadata( i, j, k ) );
-    }
-    
-    protected int GetGrowthLevel( int iMetadata )
-    {
-    	return iMetadata & 7;
-    }
-    
-    protected void SetGrowthLevel( World world, int i, int j, int k, int iLevel )
-    {
-    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
-    	
-    	world.setBlockMetadataWithNotify( i, j, k, iMetadata | iLevel );
-    }
-    
-    protected void SetGrowthLevelNoNotify( World world, int i, int j, int k, int iLevel )
-    {
-    	int iMetadata = world.getBlockMetadata( i, j, k ) & (~7); // filter out old level   	
-    	
-    	world.setBlockMetadata( i, j, k, iMetadata | iLevel );
-    }
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- BlockDoor.java	Sat Jul 13 20:39:04 2013
+++ BlockDoor.java	Fri Apr 20 22:33:07 2018
@@ -365,11 +365,4 @@
             par1World.setBlockToAir(par2, par3 - 1, par4);
         }
     }
-    
-    // FCMOD: Code added
-    public void OnAIOpenDoor( World world, int i, int j, int k, boolean bOpen )
-    {
-    	onPoweredBlockChange( world, i, j, k, bOpen );    	
-    }
-    // END FCMOD
 }
--- BlockFire.java	Tue Dec 11 22:46:01 2018
+++ BlockFire.java	Fri Apr 20 22:33:07 2018
@@ -5,25 +5,13 @@
 public class BlockFire extends Block
 {
     /** The chance this block will encourage nearby blocks to catch on fire */
-	// FCMOD: Change to static, public, and extended block IDs
-	/*
     private int[] chanceToEncourageFire = new int[256];
-    */
-    static public int[] chanceToEncourageFire = new int[4096];
-    // END FCMOD
 
     /**
      * This is an array indexed by block ID the larger the number in the array the more likely a block type will catch
      * fires
      */
-	// FCMOD: Change to static, public, and extended block IDs
-    // FCNOTE: This is actually the chance of a block being DESTROYED by fire, and potentially converted to a fire block
-	/*
     private int[] abilityToCatchFire = new int[256];
-    */
-    static public int[] abilityToCatchFire = new int[4096];
-    // END FCMOD
-    private Icon[] iconArray;
 
     protected BlockFire(int par1)
     {
@@ -35,8 +23,6 @@
      * This method is called on a block after all other blocks gets already created. You can use it to reference and
      * configure something on the block that needs the others ones.
      */
-	// FCMOD: Removed in favor of the block classes themselves setting their own fire properties
-    /*
     public void initializeBlock()
     {
         this.setBurnRate(Block.planks.blockID, 5, 20);
@@ -55,8 +41,6 @@
         this.setBurnRate(Block.cloth.blockID, 30, 60);
         this.setBurnRate(Block.vine.blockID, 15, 100);
     }
-    */
-    // END FCMOD
 
     /**
      * Sets the burn rate for a block. The larger abilityToCatchFire the more easily it will catch. The larger
@@ -122,8 +106,6 @@
     /**
      * Ticks the block if it's been scheduled
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
         if (par1World.getGameRules().getGameRuleBooleanValue("doFireTick"))
@@ -229,8 +211,6 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     public boolean func_82506_l()
     {
@@ -245,10 +225,7 @@
         {
             boolean var9 = par1World.getBlockId(par2, par3, par4) == Block.tnt.blockID;
 
-            // FCMOD: Changed
-            //if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
-            if ( par6Random.nextInt( par7 + 10 ) < 5 && !par1World.IsRainingAtPos( par2, par3, par4 ) )
-        	// END FCMOD
+            if (par6Random.nextInt(par7 + 10) < 5 && !par1World.canLightningStrikeAt(par2, par3, par4))
             {
                 int var10 = par7 + par6Random.nextInt(5) / 4;
 
@@ -274,12 +251,7 @@
     /**
      * Returns true if at least one block next to this one can burn.
      */
-	// FCMOD: Changed to protected
-	/*
     private boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
-    */
-    protected boolean canNeighborBurn(World par1World, int par2, int par3, int par4)
-    // END FCMOD
     {
         return this.canBlockCatchFire(par1World, par2 + 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2 - 1, par3, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 - 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3 + 1, par4) ? true : (this.canBlockCatchFire(par1World, par2, par3, par4 - 1) ? true : this.canBlockCatchFire(par1World, par2, par3, par4 + 1)))));
     }
@@ -287,8 +259,6 @@
     /**
      * Gets the highest chance of a neighbor block encouraging this block to catch fire
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     private int getChanceOfNeighborsEncouragingFire(World par1World, int par2, int par3, int par4)
     {
         byte var5 = 0;
@@ -308,8 +278,6 @@
             return var6;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns if this block is collidable (only used by Fire). Args: x, y, z
@@ -332,15 +300,11 @@
      * current number passed in it will return its number instead of the passed in one.  Args: world, x, y, z,
      * curChanceToEncourageFire
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     public int getChanceToEncourageFire(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = this.chanceToEncourageFire[par1World.getBlockId(par2, par3, par4)];
         return var6 > par5 ? var6 : par5;
     }
-    */
-    // END FCMOD
 
     /**
      * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
@@ -379,9 +343,4 @@
             }
         }
     }
-    
-    // FCMOD: Added New
-    
-	//----------- Client Side Functionality -----------//
-	// END FCMOD
 }
--- BlockFlower.java	Sun Feb 10 12:59:41 2019
+++ BlockFlower.java	Fri Apr 20 22:33:07 2018
@@ -2,24 +2,14 @@
 
 import java.util.Random;
 
-// FCMOD: Changed
-//public class BlockFlower extends Block
-public class BlockFlower extends FCBlockPlants
-// END FCMOD
+public class BlockFlower extends Block
 {
-	/**
-	 * FCNOTE: This class would be better called BlockPlants, as it acts as a common base class
-	 * for vegetation and crops.
-	 */
     protected BlockFlower(int par1, Material par2Material)
     {
         super(par1, par2Material);
         this.setTickRandomly(true);
         float var3 = 0.2F;
-        // FCMOD: Changed
-        //this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
-        InitBlockBounds( 0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3 );
-        // END FCMOD
+        this.setBlockBounds(0.5F - var3, 0.0F, 0.5F - var3, 0.5F + var3, var3 * 3.0F, 0.5F + var3);
         this.setCreativeTab(CreativeTabs.tabDecorations);
     }
 
@@ -31,27 +21,19 @@
     /**
      * Checks to see if its valid to put this block at the specified coordinates. Args: world, x, y, z
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean canPlaceBlockAt(World par1World, int par2, int par3, int par4)
     {
         return super.canPlaceBlockAt(par1World, par2, par3, par4) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
-    */
-    // END FCMOD
 
     /**
      * Gets passed in the blockID of the block below and supposed to return true if its allowed to grow on the type of
      * blockID passed in. Args: blockID
      */
-    // FCMOD: Removed as deprecated
-    /*
     protected boolean canThisPlantGrowOnThisBlockID(int par1)
     {
         return par1 == Block.grass.blockID || par1 == Block.dirt.blockID || par1 == Block.tilledField.blockID;
     }
-    */
-    // END FCMOD
 
     /**
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
@@ -83,14 +65,10 @@
     /**
      * Can this block stay at this position.  Similar to canPlaceBlockAt except gets checked often with plants.
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean canBlockStay(World par1World, int par2, int par3, int par4)
     {
         return (par1World.getFullBlockLightValue(par2, par3, par4) >= 8 || par1World.canBlockSeeTheSky(par2, par3, par4)) && this.canThisPlantGrowOnThisBlockID(par1World.getBlockId(par2, par3 - 1, par4));
     }
-    */
-    // END FCMOD
 
     /**
      * Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been
@@ -125,24 +103,4 @@
     {
         return 1;
     }
-    
-    // FCMOD: Added New
-    @Override
-    public boolean canBlockStay( World world, int i, int j, int k )
-    {
-        return ( world.getFullBlockLightValue( i, j, k ) >= 8 || 
-        	world.canBlockSeeTheSky( i, j, k ) ) && super.canBlockStay( world, i, j, k ); 
-    }
-    
-    @Override
-    public boolean CanBeGrazedOn( IBlockAccess blockAccess, int i, int j, int k, 
-    	EntityAnimal animal )
-    {
-		return animal.CanGrazeOnRoughVegetation();
-    }
-    
-    //------------- Class Specific Methods ------------//
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- BlockFlowing.java	Wed Feb 20 13:25:11 2019
+++ BlockFlowing.java	Fri Apr 20 22:33:07 2018
@@ -65,12 +65,6 @@
             var12 = this.getSmallestFlowDecay(par1World, par2 + 1, par3, par4, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 - 1, var12);
             var12 = this.getSmallestFlowDecay(par1World, par2, par3, par4 + 1, var12);
-            
-            // FCMOD: Code added
-        	var12 = GetSmallestFlowDecayFromCustomSources( par1World, par2, par3, par4, var12 );            	
-        	int iTickRate = tickRate(par1World);
-            // END FCMOD
-        	
             var10 = var12 + var7;
 
             if (var10 >= 8 || var12 < 0)
@@ -104,19 +98,11 @@
                 }
             }
 
-        	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
-            /*
             if (this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 && par5Random.nextInt(4) != 0)
             {
                 var10 = var6;
                 var8 = false;
             }
-            */
-            if ( this.blockMaterial == Material.lava && var6 < 8 && var10 < 8 && var10 > var6 )
-            {
-            	iTickRate += iTickRate * ( 1 + par5Random.nextInt( 4 ) );
-            }
-            // END FCMOD
 
             if (var10 == var6)
             {
@@ -136,12 +122,7 @@
                 else
                 {
                     par1World.setBlockMetadata(par2, par3, par4, var10, 2);
-                	// FCMOD: Code change to import 1.6 lava flow fix with additional variability so it doesn't look as weird
-                    /*
                     par1World.scheduleBlockUpdate(par2, par3, par4, this.blockID, this.tickRate(par1World));
-                    */
-                    par1World.scheduleBlockUpdate( par2, par3, par4, this.blockID, iTickRate );
-                    // END FCMOD
                     par1World.notifyBlocksOfNeighborChange(par2, par3, par4, this.blockID);
                 }
             }
@@ -155,11 +136,7 @@
         {
             if (this.blockMaterial == Material.lava && par1World.getBlockMaterial(par2, par3 - 1, par4) == Material.water)
             {
-            	// FCMOD: Changed
-                //par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
-                par1World.setBlock( par2, par3 - 1, par4, 
-                	FCBetterThanWolves.fcBlockLavaPillow.blockID );
-                // END FCMOD
+                par1World.setBlock(par2, par3 - 1, par4, Block.stone.blockID);
                 this.triggerLavaMixEffects(par1World, par2, par3 - 1, par4);
                 return;
             }
@@ -228,10 +205,7 @@
                 }
                 else
                 {
-                	// FCMOD: Changed                	
-                    //Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
-                	Block.blocksList[var6].OnFluidFlowIntoBlock( par1World, par2, par3, par4, this );
-                	// END FCMOD
+                    Block.blocksList[var6].dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
                 }
             }
 
@@ -368,12 +342,10 @@
     /**
      * Returns true if block at coords blocks fluids
      */
-    // FCMOD: Removed and replaced later
-    /*
     private boolean blockBlocksFlow(World par1World, int par2, int par3, int par4)
     {
         int var5 = par1World.getBlockId(par2, par3, par4);
-        
+
         if (var5 != Block.doorWood.blockID && var5 != Block.doorIron.blockID && var5 != Block.signPost.blockID && var5 != Block.ladder.blockID && var5 != Block.reed.blockID)
         {
             if (var5 == 0)
@@ -391,8 +363,6 @@
             return true;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * getSmallestFlowDecay(World world, intx, int y, int z, int currentSmallestFlowDecay) - Looks up the flow decay at
@@ -450,58 +420,4 @@
     {
         return false;
     }
-    
-    // FCMOD: Added New   
-    @Override
-    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
-    {
-    	super.onNeighborBlockChange( world, i, j, k, iNeighborBlockID );
-    	
-    	// these blocks normally have an update scheduled, and randomly get ticked to 
-    	// ensure they don't get stalled on chunk load, but can sit there for extend periods
-    	// until that happens, so this ensures player interaction will get them going again
-    	
-    	if ( !world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )
-    	{
-    		world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
-    	}
-    }
-
-	private int GetSmallestFlowDecayFromCustomSources( World world, int i, int j, int k, int iSmallestFlowDecay )
-	{
-		// note that this function doesn't update numAdjacentSources as that is used for new source block creation
-		
-        if ( iSmallestFlowDecay != 0 )
-        {
-        	for ( int iFacing = 0; iFacing < 6; iFacing++ )
-        	{
-        		int iTargetDecay = FCUtilsWorld.IsValidSourceForFluidBlockToFacing( world, i, j, k, iFacing );
-        		
-				if ( iTargetDecay == 0 )
-				{
-					iSmallestFlowDecay = 0;
-					
-					break;
-				}
-				
-				if ( iTargetDecay > 0 )
-				{
-					if ( iSmallestFlowDecay < 0 || iTargetDecay < iSmallestFlowDecay )
-					{
-						iSmallestFlowDecay = iTargetDecay;
-					}
-				}
-        	}
-        }
-        
-		return iSmallestFlowDecay;
-	}
-	
-    public boolean blockBlocksFlow( World world, int i, int j, int k )
-    {
-        Block block = blocksList[world.getBlockId( i, j, k )];
-        
-        return block != null && block.GetPreventsFluidFlow( world, i, j, k, this );
-    }
-	// END FCMOD
 }
--- BlockFluid.java	Fri Feb 15 15:48:48 2019
+++ BlockFluid.java	Fri Apr 20 22:33:07 2018
@@ -9,10 +9,7 @@
         super(par1, par2Material);
         float var3 = 0.0F;
         float var4 = 0.0F;
-        // FCMOD: Changed
-        //this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
-        InitBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
-        // END FCMOD
+        this.setBlockBounds(0.0F + var4, 0.0F + var3, 0.0F + var4, 1.0F + var4, 1.0F + var3, 1.0F + var4);
         this.setTickRandomly(true);
     }
 
@@ -137,8 +134,6 @@
     /**
      * Returns a vector indicating the direction and intensity of fluid flow.
      */
-    // FCMOD: Code removed and replaced later
-    /*
     private Vec3 getFlowVector(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         Vec3 var5 = par1IBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
@@ -245,8 +240,6 @@
         var5 = var5.normalize();
         return var5;
     }
-    */
-    // END FCMOD
 
     /**
      * Can add to the passed in vector for a movement vector to be applied to the entity. Args: x, y, z, entity, vec3d
@@ -330,11 +323,7 @@
                     }
                     else if (var6 <= 4)
                     {
-                    	// FCMOD: Changed
-                        //par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
-                        par1World.setBlock( par2, par3, par4, 
-                        	FCBetterThanWolves.fcBlockLavaPillow.blockID );
-                        // END FCMOD
+                        par1World.setBlock(par2, par3, par4, Block.cobblestone.blockID);
                     }
 
                     this.triggerLavaMixEffects(par1World, par2, par3, par4);
@@ -355,81 +344,4 @@
             par1World.spawnParticle("largesmoke", (double)par2 + Math.random(), (double)par3 + 1.2D, (double)par4 + Math.random(), 0.0D, 0.0D, 0.0D);
         }
     }
-    
-    // FCMOD: Added New
-    @Override
-    public boolean GetCanBlockBeIncinerated( World world, int i, int j, int k )
-    {
-    	return false;
-    }
-    
-    @Override
-    public ItemStack GetStackRetrievedByBlockDispenser( World world, int i, int j, int k )
-    {	 
-    	return null; // can't be picked up
-    }
-    
-    //------------- Class Specific Methods ------------//
-    
-    private Vec3 AddFlowVectorAtTarget( IBlockAccess iBlockAccess, int i, int j, int k, int iFlowDecay, int iTempI, int iTempK, Vec3 flowVec )
-    {
-        int iTempDecay = getEffectiveFlowDecay( iBlockAccess, iTempI, j, iTempK );
-
-        if ( iTempDecay < 0 )
-        {
-            if (!iBlockAccess.getBlockMaterial(iTempI, j, iTempK).blocksMovement())
-            {
-                iTempDecay = this.getEffectiveFlowDecay(iBlockAccess, iTempI, j - 1, iTempK);
-
-                if (iTempDecay >= 0)
-                {
-                    int iDeltaDecay = iTempDecay - (iFlowDecay - 8);
-                    return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
-                }
-            }
-        }
-        else if (iTempDecay >= 0)
-        {
-            int iDeltaDecay = iTempDecay - iFlowDecay;
-            return flowVec.addVector((double)((iTempI - i) * iDeltaDecay), 0D, (double)((iTempK - k) * iDeltaDecay));
-        }
-        
-        return flowVec;
-    }
-    
-    private Vec3 getFlowVector( IBlockAccess iBlockAccess, int i, int j, int k )
-    {
-    	// optomized vanilla function
-    	
-        Vec3 flowVec = iBlockAccess.getWorldVec3Pool().getVecFromPool(0.0D, 0.0D, 0.0D);
-        
-        int iFlowDecay = getEffectiveFlowDecay( iBlockAccess, i, j, k );
-
-        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i - 1, k, flowVec );
-        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k - 1, flowVec );
-        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i + 1, k, flowVec );
-        flowVec = AddFlowVectorAtTarget( iBlockAccess, i, j, k, iFlowDecay, i, k + 1, flowVec );
-                
-        if (iBlockAccess.getBlockMetadata(i, j, k) >= 8)
-        {
-            if ( this.isBlockSolid(iBlockAccess, i, j, k - 1, 2)
-            || this.isBlockSolid(iBlockAccess, i, j, k + 1, 3)
-            || this.isBlockSolid(iBlockAccess, i - 1, j, k, 4)
-            || this.isBlockSolid(iBlockAccess, i + 1, j, k, 5)
-            || this.isBlockSolid(iBlockAccess, i, j + 1, k - 1, 2)
-            || this.isBlockSolid(iBlockAccess, i, j + 1, k + 1, 3)
-            || this.isBlockSolid(iBlockAccess, i - 1, j + 1, k, 4)
-            || this.isBlockSolid(iBlockAccess, i + 1, j + 1, k, 5) )
-            {
-                flowVec = flowVec.normalize().addVector(0.0D, -6.0D, 0.0D);
-            }
-        }
-
-        flowVec = flowVec.normalize();
-        
-        return flowVec;
-    }
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD    
 }
--- BlockFurnace.java	Fri Mar 16 01:31:14 2018
+++ BlockFurnace.java	Fri Apr 20 22:33:07 2018
@@ -10,21 +10,13 @@
     private final Random furnaceRand = new Random();
 
     /** True if this is an active furnace, false if idle */
-    // FCMOD: Changed to protected
-    /*
     private final boolean isActive;
-    */
-    protected final boolean isActive;
-    // END FCMOD
 
     /**
      * This flag is used to prevent the furnace inventory to be dropped upon block removal, is used internally when the
      * furnace block changes from idle to active and vice-versa.
      */
-    // FCMOD: Changed
-    //private static boolean keepFurnaceInventory = false;
-    protected static boolean keepFurnaceInventory = false;
-    // END FCMOD
+    private static boolean keepFurnaceInventory = false;
 
     protected BlockFurnace(int par1, boolean par2)
     {
@@ -111,12 +103,7 @@
     /**
      * Update which block ID the furnace is using depending on whether or not it is burning
      */
-    // FCMOD: Changed
-    /*
     public static void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4)
-    */
-    public void updateFurnaceBlockState(boolean par0, World par1World, int par2, int par3, int par4, boolean bHasContents)
-    // END FCMOD
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         TileEntity var6 = par1World.getBlockTileEntity(par2, par3, par4);
@@ -132,16 +119,6 @@
         }
 
         keepFurnaceInventory = false;
-        // FCMOD: Code added
-        if ( !bHasContents )
-        {
-        	var5 = var5 & 7;
-        }
-        else
-        {
-        	var5 = var5 | 8;
-        }
-        // END FCMOD        
         par1World.setBlockMetadata(par2, par3, par4, var5, 2);
 
         if (var6 != null)
--- BlockHalfSlab.java	Tue Jan 29 20:33:45 2019
+++ BlockHalfSlab.java	Fri Apr 20 22:33:07 2018
@@ -15,26 +15,18 @@
         if (par2)
         {
             opaqueCubeLookup[par1] = true;
-            
-            // FCMOD: Added
-            InitBlockBounds( 0D, 0D, 0D, 1D, 1D, 1D );
-            // END FCMOD
         }
         else
         {
-        	// FCMOD: Changed
-            //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
-            InitBlockBounds( 0D, 0D, 0D, 1D, 0.5D, 1D );
-            
-            useNeighborBrightness[par1] = true;
-            // END FCMOD
+            this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.5F, 1.0F);
         }
 
         this.setLightOpacity(255);
     }
 
-    // FCMOD: Removed
-    /*
+    /**
+     * Updates the blocks bounds based on its current state. Args: world, x, y, z
+     */
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         if (this.isDoubleSlab)
@@ -56,6 +48,9 @@
         }
     }
 
+    /**
+     * Sets the block's bounds for rendering it as an item
+     */
     public void setBlockBoundsForItemRender()
     {
         if (this.isDoubleSlab)
@@ -68,13 +63,15 @@
         }
     }
 
+    /**
+     * Adds all intersecting collision boxes to a list. (Be sure to only add boxes to the list if they intersect the
+     * mask.) Parameters: World, X, Y, Z, mask, list, colliding entity
+     */
     public void addCollisionBoxesToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         super.addCollisionBoxesToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);
     }
-    */
-    // END FCMOD
 
     /**
      * Is this block (a) opaque and (b) a full 1m cube?  This determines whether or not to render the shared face of two
@@ -129,108 +126,4 @@
     {
         return super.getDamageValue(par1World, par2, par3, par4) & 7;
     }
-    
-	// FCMOD: Added New
-    @Override
-    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
-    	IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	AxisAlignedBB bounds;
-    	
-        if ( isDoubleSlab )
-        {
-            bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 1F, 1F );
-        }
-        else
-        {
-            if ( GetIsUpsideDown( blockAccess, i, j, k ) )
-            {
-                bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0.5F, 0F, 1F, 1F, 1F );
-            }
-            else
-            {
-            	bounds = AxisAlignedBB.getAABBPool().getAABB( 0F, 0F, 0F, 1F, 0.5F, 1F );
-            }
-        }
-        
-        return bounds;
-    }
-    
-    @Override
-	public boolean HasLargeCenterHardPointToFacing( IBlockAccess blockAccess, int i, int j, int k, int iFacing, boolean bIgnoreTransparency )
-	{
-    	if ( !isDoubleSlab )
-    	{
-            boolean bIsUpsideDown = GetIsUpsideDown( blockAccess, i, j, k );
-            
-            if ( iFacing == 0  ) 
-            {
-            	if ( !bIsUpsideDown )
-            	{
-            		return true;
-            	}
-            }
-            else if ( iFacing == 1 )
-            {
-            	if ( bIsUpsideDown )
-            	{
-            		return true;
-            	}
-            }
-    	}
-    	
-		return super.HasLargeCenterHardPointToFacing( blockAccess, i, j, k, iFacing, bIgnoreTransparency );
-	}
-
-    @Override
-    public float GroundCoverRestingOnVisualOffset( IBlockAccess blockAccess, int i, int j, int k )
-    {
-        if ( !isDoubleSlab )
-        {
-            if ( ( blockAccess.getBlockMetadata( i, j, k ) & 8 ) == 0 )
-            {
-            	return -0.5F;
-            }
-        }
-        
-    	return 0F;
-    }
-    
-    @Override
-    public boolean CanGroundCoverRestOnBlock( World world, int i, int j, int k )
-    {
-    	return true;
-    }
-    
-    @Override
-    public boolean CanMobsSpawnOn( World world, int i, int j, int k )
-    {
-        return blockMaterial.GetMobsCanSpawnOn( world.provider.dimensionId );
-    }
-
-    @Override
-    public float MobSpawnOnVerticalOffset( World world, int i, int j, int k )
-    {
-        if ( !isDoubleSlab && !GetIsUpsideDown( world, i, j, k ) )
-        {
-        	return -0.5F;
-        }
-        
-    	return 0F;
-    }
-    
-    //------------- Class Specific Methods ------------//
-    
-    public boolean GetIsUpsideDown( IBlockAccess blockAccess, int i, int j, int k )
-    {
-    	return GetIsUpsideDown( blockAccess.getBlockMetadata( i, j, k ) );
-    }
-    
-    public boolean GetIsUpsideDown( int iMetadata )
-    {
-    	return ( iMetadata & 8 ) > 0;
-    }
-    
-	//----------- Client Side Functionality -----------//
-	// END FCMOD
 }
--- BlockLog.java	Fri Jun 14 12:38:58 2013
+++ BlockLog.java	Fri Apr 20 22:33:07 2018
@@ -123,12 +123,4 @@
     {
         return new ItemStack(this.blockID, 1, limitToValidMetadata(par1));
     }
-    // FCMOD: Code added
-    protected BlockLog( int iBlockID, Material material )
-    {
-        super(iBlockID, material );
-        
-        setCreativeTab( CreativeTabs.tabBlock );
-    }
-    // END FCMOD
 }
--- BlockPistonBase.java	Tue Jan 29 14:49:20 2019
+++ BlockPistonBase.java	Fri Apr 20 22:33:07 2018
@@ -5,10 +5,7 @@
 public class BlockPistonBase extends Block
 {
     /** This pistons is the sticky one? */
-	// FCMOD: Changed
-    //private final boolean isSticky;
-    protected final boolean isSticky;
-    // END FCMOD
+    private final boolean isSticky;
 
     public BlockPistonBase(int par1, boolean par2)
     {
@@ -84,10 +81,7 @@
     /**
      * handles attempts to extend or retract the piston.
      */
-    // FCMOD: Changed
-    //private void updatePistonState(World par1World, int par2, int par3, int par4)
-    protected void updatePistonState(World par1World, int par2, int par3, int par4)
-    // END FCMOD
+    private void updatePistonState(World par1World, int par2, int par3, int par4)
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         int var6 = getOrientation(var5);
@@ -190,18 +184,8 @@
                     }
                 }
 
-                // FCMOD: Changed
-                //if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
-                Block targetBlock = Block.blocksList[var11];
-                
-                if ( !var13 && targetBlock != null && 
-                	targetBlock.CanBlockBePulledByPiston( par1World, var8, var9, var10, Block.GetOppositeFacing( par6 ) ) )
-                // END FCMOD                	
-                {
-                    // FCMOD: Added
-            		var12 =  targetBlock.AdjustMetadataForPistonMove( var12 );
-                    // END FCMOD
-                    
+                if (!var13 && var11 > 0 && canPushBlock(var11, par1World, var8, var9, var10, false) && (Block.blocksList[var11].getMobilityFlag() == 0 || var11 == Block.pistonBase.blockID || var11 == Block.pistonStickyBase.blockID))
+                {
                     par2 += Facing.offsetsXForSide[par6];
                     par3 += Facing.offsetsYForSide[par6];
                     par4 += Facing.offsetsZForSide[par6];
@@ -345,8 +329,6 @@
     /**
      * returns true if the piston can push the specified block
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     private static boolean canPushBlock(int par0, World par1World, int par2, int par3, int par4, boolean par5)
     {
         if (par0 == Block.obsidian.blockID)
@@ -385,14 +367,10 @@
             return !(Block.blocksList[par0] instanceof ITileEntityProvider);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * checks to see if this piston could push the blocks in front of it.
      */
-    // FCMOD: Removed and replaced in child class
-    /* 
     private static boolean canExtend(World par0World, int par1, int par2, int par3, int par4)
     {
         int var5 = par1 + Facing.offsetsXForSide[par4];
@@ -437,14 +415,10 @@
             return true;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * attempts to extend the piston. returns false if impossible.
      */
-    // FCMOD: Removed and replaced in child class
-    /* 
     private boolean tryExtend(World par1World, int par2, int par3, int par4, int par5)
     {
         int var6 = par2 + Facing.offsetsXForSide[par5];
@@ -541,22 +515,4 @@
             return true;
         }
     }
-    */
-    // END FCMOD
-    
-    // FCMOD: Added New    
-    protected boolean canExtend( World world, int i, int j, int k, int iFacing )
-    {
-    	// intended to be overriden by child class
-    	
-    	return false;
-    }
-    
-    protected boolean tryExtend( World world, int i, int j, int k, int iFacing )
-    {
-    	// intended to be overriden by child class
-    	
-    	return false;
-    }
-    // END FCMOD    
 }
--- BlockRailBase.java	Wed Dec 19 03:17:00 2018
+++ BlockRailBase.java	Fri Apr 20 22:33:07 2018
@@ -21,22 +21,14 @@
      */
     public static final boolean isRailBlock(int par0)
     {
-        // FCMOD: Changed to recognize all rail blocks
-		/*
         return par0 == Block.rail.blockID || par0 == Block.railPowered.blockID || par0 == Block.railDetector.blockID || par0 == Block.railActivator.blockID;
-        */
-    	return Block.blocksList[par0] instanceof BlockRailBase;
-    	// END FCMOD
     }
 
     protected BlockRailBase(int par1, boolean par2)
     {
         super(par1, Material.circuits);
         this.isPowered = par2;
-        // FCMOD: Changed
-        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
-        InitBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
-        // END FCMOD
+        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
         this.setCreativeTab(CreativeTabs.tabTransport);
     }
 
@@ -70,21 +62,15 @@
      * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,
      * x, y, z, startVec, endVec
      */
-    // FCMOD: Removed
-    /*
     public MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)
     {
         this.setBlockBoundsBasedOnState(par1World, par2, par3, par4);
         return super.collisionRayTrace(par1World, par2, par3, par4, par5Vec3, par6Vec3);
     }
-    */
-    // END FCMOD
 
     /**
      * Updates the blocks bounds based on its current state. Args: world, x, y, z
      */
-    // FCMOD: Removed
-    /*
     public void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)
     {
         int var5 = par1IBlockAccess.getBlockMetadata(par2, par3, par4);
@@ -98,8 +84,6 @@
             this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * If this block doesn't render as an ordinary block it will return False (examples: signs, buttons, stairs, etc)
@@ -194,12 +178,6 @@
 
             if (var8)
             {
-            	// FCMOD: Code added to prevent item duplication since multiple notifications can occur at once
-            	if ( par1World.getBlockId( par2, par3, par4 ) != blockID )
-            	{
-            		return;
-            	}
-            	// END FCMOD
                 this.dropBlockAsItem(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), 0);
                 par1World.setBlockToAir(par2, par3, par4);
             }
@@ -257,121 +235,4 @@
             par1World.notifyBlocksOfNeighborChange(par2, par3 - 1, par4, par5);
         }
     }
-    
-	// FCMOD: Added New
-	@Override
-	public boolean CanRotateOnTurntable( IBlockAccess blockAccess, int i, int j, int k )
-	{
-		return true;
-	}
-	
-	@Override
-	public int RotateMetadataAroundJAxis( int iMetadata, boolean bReverse )
-	{
-		int iDirection = iMetadata;
-		
-		if ( isPowered() ) // this should never be true
-		{
-			iDirection &= 7;
-		}
-		
-		if ( iDirection == 0 )
-		{
-			iDirection = 1;
-		}
-		else if ( iDirection == 1 )
-		{
-			iDirection = 0;
-		}
-		// sloped rails
-		else if ( iDirection == 2 )
-		{
-		}
-		else if ( iDirection == 3 )
-		{
-		}
-		else if ( iDirection == 4 )
-		{
-		}
-		else if ( iDirection == 5 )
-		{
-		}
-		// curved rails
-		else if ( iDirection == 6 )
-		{
-			if ( bReverse )
-			{
-				iDirection = 7;
-			}
-			else
-			{
-				iDirection = 9;
-			}
-		}
-		else if ( iDirection == 7 )
-		{
-			if ( bReverse )
-			{
-				iDirection = 8;
-			}
-			else
-			{
-				iDirection = 6;
-			}
-		}
-		else if ( iDirection == 8 )
-		{
-			if ( bReverse )
-			{
-				iDirection = 9;
-			}
-			else
-			{
-				iDirection = 7;
-			}
-		}
-		else if ( iDirection == 9 )
-		{
-			if ( bReverse )
-			{
-				iDirection = 6;
-			}
-			else
-			{
-				iDirection = 8;
-			}
-		}
-		
-		if ( isPowered() ) // this should never be true
-		{
-			iMetadata = (iMetadata & 8) | iDirection;
-		}
-		else
-		{
-			iMetadata = iDirection;
-		}
-		
-		return iMetadata;
-	}
-	
-    @Override
-    public AxisAlignedBB GetBlockBoundsFromPoolBasedOnState( 
-    	IBlockAccess blockAccess, int i, int j, int k )
-    {
-        int iDirection = blockAccess.getBlockMetadata( i, j, k );
-
-        if ( iDirection >= 2 && iDirection <= 5 )
-        {
-        	return AxisAlignedBB.getAABBPool().getAABB(         	
-        		0D, 0D, 0D, 1D, 0.625D, 1D );
-        }
-        else
-        {
-        	return AxisAlignedBB.getAABBPool().getAABB(         	
-        		0D, 0D, 0D, 1D, 0.125F, 1D );
-        }
-    }
-    
-	//----------- Client Side Functionality -----------//
-	// END FCMOD
 }
--- BlockRedstoneLogic.java	Wed Dec 19 03:18:22 2018
+++ BlockRedstoneLogic.java	Fri Apr 20 22:33:07 2018
@@ -11,10 +11,7 @@
     {
         super(par1, Material.circuits);
         this.isRepeaterPowered = par2;
-        // FCMOD: Changed
-        //this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
-        InitBlockBounds( 0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F );
-        // END FCMOD
+        this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
     }
 
     /**
@@ -349,8 +346,4 @@
     {
         return this.func_94487_f(par1);
     }
-    
-    // FCMOD: Added New
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- BlockRedstoneTorch.java	Wed Feb 20 14:05:41 2019
+++ BlockRedstoneTorch.java	Fri Apr 20 22:33:07 2018
@@ -6,12 +6,7 @@
 import java.util.Map;
 import java.util.Random;
 
-// FCMOD: Change
-/*
 public class BlockRedstoneTorch extends BlockTorch
-*/
-public class BlockRedstoneTorch extends FCBlockTorchBase
-// END FCMOD
 {
     /** Whether the redstone torch is currently active or not. */
     private boolean torchActive = false;
@@ -127,13 +122,7 @@
     /**
      * Returns true or false based on whether the block the torch is attached to is providing indirect power.
      */
-    // FCMOD: Renamed function to prevent problems for add-on mods
-	/*
     private boolean isIndirectlyPowered(World par1World, int par2, int par3, int par4)
-	*/
-    private boolean isIndirectlyPoweredLocal(World par1World, int par2, int par3, int par4)
-    // END FCMOD
-
     {
         int var5 = par1World.getBlockMetadata(par2, par3, par4);
         return var5 == 5 && par1World.getIndirectPowerOutput(par2, par3 - 1, par4, 0) ? true : (var5 == 3 && par1World.getIndirectPowerOutput(par2, par3, par4 - 1, 2) ? true : (var5 == 4 && par1World.getIndirectPowerOutput(par2, par3, par4 + 1, 3) ? true : (var5 == 1 && par1World.getIndirectPowerOutput(par2 - 1, par3, par4, 4) ? true : var5 == 2 && par1World.getIndirectPowerOutput(par2 + 1, par3, par4, 5))));
@@ -144,12 +133,7 @@
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
-		// FCMOD: Renamed function as per above
-		/*
         boolean var6 = this.isIndirectlyPowered(par1World, par2, par3, par4);
-		*/
-        boolean var6 = this.isIndirectlyPoweredLocal(par1World, par2, par3, par4);
-		// END FCMOD
         List var7 = (List)redstoneUpdateInfoCache.get(par1World);
 
         while (var7 != null && !var7.isEmpty() && par1World.getTotalWorldTime() - ((RedstoneUpdateInfo)var7.get(0)).updateTime > 60L)
@@ -187,8 +171,6 @@
      * Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are
      * their own) Args: x, y, z, neighbor blockID
      */
-    // FCMOD: Removed and replaced
-    /*
     public void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)
     {
         if (!this.func_94397_d(par1World, par2, par3, par4, par5))
@@ -201,8 +183,6 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns true if the block is emitting direct/strong redstone power on the specified side. Args: World, X, Y, Z,
@@ -237,27 +217,4 @@
     {
         return par1 == Block.torchRedstoneIdle.blockID || par1 == Block.torchRedstoneActive.blockID;
     }
-    
-    // FCMOD: Added new
-	@Override
-    public void onNeighborBlockChange( World world, int i, int j, int k, int iNeighborBlockID )
-    {
-    	if ( !ValidateState( world, i, j, k, iNeighborBlockID ) )    	
-        {
-            boolean bPowered = isIndirectlyPoweredLocal( world, i, j, k );
-
-            if ( torchActive == bPowered &&
-            	!world.IsUpdatePendingThisTickForBlock( i, j, k, blockID ) )            	
-            {
-                world.scheduleBlockUpdate( i, j, k, blockID, tickRate( world ) );
-            }
-        }
-    }
-    
-	@Override
-	public boolean TriggersBuddy()
-	{
-		return false;
-	}
-	// END FCMOD
 }
--- BlockStem.java	Sat Dec 15 23:39:05 2018
+++ BlockStem.java	Fri Apr 20 22:33:07 2018
@@ -5,12 +5,7 @@
 public class BlockStem extends BlockFlower
 {
     /** Defines if it is a Melon or a Pumpkin that the stem is producing. */
-	// FCMOD: Changed
-	/*
     private final Block fruitType;
-    */
-    protected Block fruitType;
-	// END FCMOD
 
     protected BlockStem(int par1, Block par2Block)
     {
--- Chunk.java	Tue Mar 13 00:13:09 2018
+++ Chunk.java	Fri Apr 20 22:33:08 2018
@@ -204,12 +204,7 @@
             while (var3 < 16)
             {
                 this.precipitationHeightMap[var2 + (var3 << 4)] = -999;
-                // FCMOD: Changed to match 1.8
-                /*
                 int var4 = var1 + 16 - 1;
-                */
-                int var4 = var1 + 16;
-                // END FCMOD
 
                 while (true)
                 {
@@ -567,23 +562,10 @@
                 {
                     Block.blocksList[var8].breakBlock(this.worldObj, var12, par2, var13, var8, var9);
                 }
-                // FCMOD: Code change
-                /*
                 else if (Block.blocksList[var8] instanceof ITileEntityProvider && var8 != par4)
                 {
                     this.worldObj.removeBlockTileEntity(var12, par2, var13);
                 }
-                */
-                else if ( var8 != par4 )
-                {
-                    Block.blocksList[var8].ClientBreakBlock(this.worldObj, var12, par2, var13, var8, var9);
-                    
-                    if ( Block.blocksList[var8] instanceof ITileEntityProvider && Block.blocksList[var8].ShouldDeleteTileEntityOnBlockChange( par4 ) )
-                    {
-                    	this.worldObj.removeBlockTileEntity(var12, par2, var13);
-                    }
-                }
-                // END FCMOD
             }
 
             if (var10.getExtBlockID(par1, par2 & 15, par3) != par4)
@@ -623,12 +605,6 @@
                     {
                         Block.blocksList[par4].onBlockAdded(this.worldObj, var12, par2, var13);
                     }
-                    // FCMOD: Code added
-                    else if ( var8 != par4 )
-                    {
-                        Block.blocksList[par4].ClientBlockAdded(worldObj, var12, par2, var13);
-                    }
-                    // END FCMOD
 
                     if (Block.blocksList[par4] instanceof ITileEntityProvider)
                     {
@@ -1314,56 +1290,4 @@
             }
         }
     }
-    
-    // FCMOD: Code added
-    public void GetClosestEntityMatchingCriteriaWithinRangeSq( FCClosestEntityInfo closestEntityInfo )
-    {
-    	for ( int iVerticalIndex = closestEntityInfo.m_iChunkEntityListMinVerticalIndex; iVerticalIndex <= closestEntityInfo.m_iChunkEntityListMaxVerticalIndex; iVerticalIndex++ )
-    	{
-            List tempEntityList = entityLists[iVerticalIndex];
-            
-            if ( !tempEntityList.isEmpty() )
-            {            
-            	Iterator entityIterator = tempEntityList.iterator();
-            	
-            	while ( entityIterator.hasNext() )
-            	{
-		        	Entity tempEntity = (Entity)entityIterator.next();
-		        	
-		        	closestEntityInfo.m_criteria.ProcessEntity( closestEntityInfo, tempEntity );
-            	}
-            }
-    	}
-    }
-    
-    public int GetBlockNaturalLightValue( int i, int j, int k, int iSkylightSubtracted )
-    {
-    	// modified version of getBlockLightValue that only considers natural light
-    	
-        ExtendedBlockStorage blockStorage = this.storageArrays[j >> 4];
-
-        if ( blockStorage == null )
-        {
-            return !this.worldObj.provider.hasNoSky && iSkylightSubtracted < EnumSkyBlock.Sky.defaultLightValue ? EnumSkyBlock.Sky.defaultLightValue - iSkylightSubtracted : 0;
-        }
-        else
-        {
-            int iLightValue = this.worldObj.provider.hasNoSky ? 0 : blockStorage.getExtSkylightValue(i, j & 15, k);
-
-            if (iLightValue > 0)
-            {
-                isLit = true;
-            }
-
-            iLightValue -= iSkylightSubtracted;
-            
-            if ( iLightValue < 0 )
-            {
-            	iLightValue = 0;
-            }
-
-            return iLightValue;
-        }
-    }    
-    // END FCMOD
 }
--- ChunkProviderGenerate.java	Fri May  3 12:46:11 2019
+++ ChunkProviderGenerate.java	Fri Apr 20 22:33:08 2018
@@ -80,9 +80,6 @@
         this.worldObj = par1World;
         this.mapFeaturesEnabled = par4;
         this.rand = new Random(par2);
-        // FCMOD: Added
-        m_structureRand = new Random(par2);
-        // END FCMOD
         this.noiseGen1 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen2 = new NoiseGeneratorOctaves(this.rand, 16);
         this.noiseGen3 = new NoiseGeneratorOctaves(this.rand, 8);
@@ -475,40 +472,15 @@
         this.rand.setSeed(this.worldObj.getSeed());
         long var7 = this.rand.nextLong() / 2L * 2L + 1L;
         long var9 = this.rand.nextLong() / 2L * 2L + 1L;
-        
-        // FCMOD: Added so that future changes to structure generation will not
-        // impact the other aspects of chunk population
-        long lStructureSeedX = rand.nextLong() / 2L * 2L + 1L;
-        long lStructureSeedZ = rand.nextLong() / 2L * 2L + 1L;        
-        // END FCMOD
-        
         this.rand.setSeed((long)par2 * var7 + (long)par3 * var9 ^ this.worldObj.getSeed());
         boolean var11 = false;
 
         if (this.mapFeaturesEnabled)
         {
-        	// FCNOTE: The structure seed is intentionally not applied to mineshafts given
-        	// how frequent they are, so as not to mess too much with other details throughout the 
-        	// world
             this.mineshaftGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
-        	// FCMOD: Changed  
-            /*
             var11 = this.villageGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.strongholdGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
             this.scatteredFeatureGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);
-             */
-            m_structureRand.setSeed((long)par2 * lStructureSeedX + 
-            	(long)par3 * lStructureSeedZ ^ this.worldObj.getSeed());
-            
-            var11 = villageGenerator.generateStructuresInChunk( worldObj, 
-            	m_structureRand, par2, par3 );
-            
-            strongholdGenerator.generateStructuresInChunk( worldObj, 
-            	m_structureRand, par2, par3 );
-            
-            scatteredFeatureGenerator.generateStructuresInChunk( worldObj, 
-            	m_structureRand, par2, par3 );
-            // END FCMOD
         }
 
         int var12;
@@ -571,10 +543,6 @@
         }
 
         BlockSand.fallInstantly = false;
-
-        // FCMOD: Added
-        BTWPostProcessChunk( worldObj, var4 - 8, var5 - 8 ); // -8 because of += 8 offset applied above
-        // END FCMOD
     }
 
     /**
@@ -644,67 +612,4 @@
             this.scatteredFeatureGenerator.generate(this, this.worldObj, par1, par2, (byte[])null);
         }
     }
-    
-    // FCMOD: Added New    
-    private Random m_structureRand;
-    
-    private void BTWPostProcessChunk( World worldObj, int iChunkX, int iChunkZ )
-    {
-    	if ( worldObj.provider.dimensionId == 0 )
-    	{
-    		GenerateStrata( worldObj, iChunkX, iChunkZ );
-    		GenerateAdditionalBrownMushrooms( worldObj, iChunkX, iChunkZ );
-    	}
-    }    
-    
-    private void GenerateAdditionalBrownMushrooms( World worldObj, int iChunkX, int iChunkZ )
-    {
-        if ( worldObj.rand.nextInt( 4 ) == 0 )
-        {
-        	WorldGenerator mushroomBrownGen = new WorldGenFlowers( Block.mushroomBrown.blockID );    	
-        	
-            int iMushroomX = iChunkX + worldObj.rand.nextInt( 16 ) + 8;
-            int iMushroomY = worldObj.rand.nextInt( 25 );
-            int iMushroomZ = iChunkZ + worldObj.rand.nextInt( 16 ) + 8;
-            
-            mushroomBrownGen.generate( worldObj, worldObj.rand, iMushroomX, iMushroomY, iMushroomZ );
-        }
-    }
-    
-    private void GenerateStrata( World world, int iChunkX, int iChunkZ )
-    {
-        Chunk chunk = world.getChunkFromChunkCoords( iChunkX >> 4, iChunkZ >> 4);
-        
-        for ( int iTempI = 0; iTempI < 16; iTempI++ )
-        {
-        	for ( int iTempK = 0; iTempK < 16; iTempK++ )
-        	{
-        		int iTempJ = 0;
-        		int iStrataHeight = 24 + world.rand.nextInt( 2 );
-        		
-        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
-        		{
-        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
-        			
-        			if ( iTempBlockID == Block.stone.blockID )
-        			{
-        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 2 );
-        			}
-        		}
-        		
-        		iStrataHeight = 48  + world.rand.nextInt( 2 );
-        		
-        		for( ; iTempJ <= iStrataHeight; iTempJ++ )
-        		{
-        			int iTempBlockID = chunk.getBlockID( iTempI, iTempJ, iTempK );
-        			
-        			if ( iTempBlockID == Block.stone.blockID )
-        			{
-        				chunk.setBlockMetadata( iTempI, iTempJ, iTempK, 1 );
-        			}
-        		}        		
-        	}
-        }
-    }
-    // END FCMOD
 }
--- ChunkProviderHell.java	Sat Oct 13 12:13:31 2018
+++ ChunkProviderHell.java	Fri Apr 20 22:33:08 2018
@@ -25,10 +25,7 @@
     /** Is the world that the nether is getting generated. */
     private World worldObj;
     private double[] noiseField;
-    // FCMOD: Changed
-    //public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
-    public FCMapGenNetherBridge genNetherBridge = new FCMapGenNetherBridge();
-    // END FCMOD
+    public MapGenNetherBridge genNetherBridge = new MapGenNetherBridge();
 
     /**
      * Holds the noise used to determine whether slowsand can be generated at a location
@@ -503,14 +500,9 @@
 
         for (var8 = 0; var8 < 16; ++var8)
         {
-        	// FCMOD: changed to fix unnecessary chunk loads and memory leaks
-            //var9 = var4 + this.hellRNG.nextInt(16);
-            //var10 = this.hellRNG.nextInt(108) + 10;
-            //var11 = var5 + this.hellRNG.nextInt(16);
-            var9 = var4 + this.hellRNG.nextInt(16) + 8;
+            var9 = var4 + this.hellRNG.nextInt(16);
             var10 = this.hellRNG.nextInt(108) + 10;
-            var11 = var5 + this.hellRNG.nextInt(16) + 8;
-            // END FCMOD
+            var11 = var5 + this.hellRNG.nextInt(16);
             (new WorldGenHellLava(Block.lavaMoving.blockID, true)).generate(this.worldObj, this.hellRNG, var9, var10, var11);
         }
 
@@ -557,13 +549,7 @@
      */
     public List getPossibleCreatures(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
     {
-    	// FCMOD: Code change to loosen spawn restrictions on wither skeletons and blazes
-    	/*
         if (par1EnumCreatureType == EnumCreatureType.monster && this.genNetherBridge.hasStructureAt(par2, par3, par4))
-        */
-        if ( par1EnumCreatureType == EnumCreatureType.monster && 
-        	genNetherBridge.HasStructureAtLoose( par2, par3, par4 ) )
-    	// END FCMOD
         {
             return this.genNetherBridge.getSpawnList();
         }
--- ChunkProviderServer.java	Thu Dec 24 17:46:44 2020
+++ ChunkProviderServer.java	Fri Apr 20 22:33:08 2018
@@ -47,28 +47,16 @@
         return this.id2ChunkMap.containsItem(ChunkCoordIntPair.chunkXZ2Int(par1, par2));
     }
 
-    // FCMOD: Added (server only) to provide alias to match client naming
-    public void unloadChunksIfNotNearSpawn( int par1, int par2 )
-    {
-        dropChunk( par1, par2 );
-    }
-    // END FCMOD
     public void dropChunk(int par1, int par2)
     {
         if (this.worldObj.provider.canRespawnHere())
         {
-        	// FCCHUNK: Decide on updates around original spawn
-        	// FCMOD: Changed
-        	/*
             ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
             int var4 = par1 * 16 + 8 - var3.posX;
             int var5 = par2 * 16 + 8 - var3.posZ;
             short var6 = 128;
 
             if (var4 < -var6 || var4 > var6 || var5 < -var6 || var5 > var6)
-            */
-        	if ( !IsSpawnChunk( par1, par2 ) )
-        	// END FCMOD
             {
                 this.droppedChunksSet.add(Long.valueOf(ChunkCoordIntPair.chunkXZ2Int(par1, par2)));
             }
@@ -350,45 +338,4 @@
     }
 
     public void recreateStructures(int par1, int par2) {}
-    
-    // FCMOD: Added
-    IChunkProvider GetCurrentProvider()
-    {
-    	// client
-    	//return currentChunkProvider;
-    	// server
-    	return serverChunkGenerator;
-	}
-    
-	protected boolean IsSpawnChunk( int iChunkX, int iChunkZ )
-	{
-		if ( worldObj.provider.canRespawnHere() )
-		{
-		    ChunkCoordinates var3 = this.worldObj.getSpawnPoint();
-		    
-		    // uses the same math as addPlayer in PlayerManager for consistent results
-		    
-		    int iSpawnChunkX = worldObj.worldInfo.getSpawnX() >> 4;
-		    int iSpawnChunkZ = worldObj.worldInfo.getSpawnZ() >> 4;
-		    
-		    int iChunkViewDistance = 
-		    	worldObj.getMinecraftServer().getConfigurationManager().getViewDistance(); 
-	
-		    return iChunkX >= iSpawnChunkX - iChunkViewDistance &&
-		    	iChunkX <= iSpawnChunkX + iChunkViewDistance &&
-			    iChunkZ >= iSpawnChunkZ - iChunkViewDistance &&
-		    	iChunkZ <= iSpawnChunkZ + iChunkViewDistance;
-		}
-		
-		return false;
-	}
-	
-    public void ForceAddToChunksToUnload( int iChunkX, int iChunkZ )
-    {
-    	// client
-        //chunksToUnload.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
-    	// server
-    	droppedChunksSet.add( Long.valueOf( ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ ) ) );
-    }
-    // END FCMOD
 }
--- CommandDifficulty.java	Fri Aug 23 18:35:49 2013
+++ CommandDifficulty.java	Fri Apr 20 22:33:08 2018
@@ -30,12 +30,6 @@
         if (par2ArrayOfStr.length > 0)
         {
             int var3 = this.getDifficultyForName(par1ICommandSender, par2ArrayOfStr[0]);
-            // FCMOD: Code added to remove peaceful and easy
-            if ( var3 < 2 )
-            {
-            	var3 = 2;
-            }
-            // END FCMOD
             MinecraftServer.getServer().setDifficultyForAllWorlds(var3);
             String var4 = StatCollector.translateToLocal(difficulties[var3]);
             notifyAdmins(par1ICommandSender, "commands.difficulty.success", new Object[] {var4});
--- CommandGive.java	Tue Jun 24 15:38:17 2014
+++ CommandGive.java	Fri Apr 20 22:33:08 2018
@@ -49,9 +49,6 @@
                 }
 
                 ItemStack var7 = new ItemStack(var4, var5, var6);
-                // FCMOD: Added
-                var7.getItem().InitializeStackOnGiveCommand( var3.worldObj.rand, var7 );
-                // END FCMOD
                 EntityItem var8 = var3.dropPlayerItem(var7);
                 var8.delayBeforeCanPickup = 0;
                 notifyAdmins(par1ICommandSender, "commands.give.success", new Object[] {Item.itemsList[var4].func_77653_i(var7), Integer.valueOf(var4), Integer.valueOf(var5), var3.getEntityName()});
--- CommandTime.java	Fri Oct 24 19:06:49 2014
+++ CommandTime.java	Fri Apr 20 22:33:09 2018
@@ -57,19 +57,6 @@
                 return;
             }
         }
-        // FCMOD: Code added to display time
-        else
-        {
-	    	par1ICommandSender.sendChatToPlayer( (new StringBuilder()).append( "\247e"). // yellow text
-            	append("Current Overworld Time: " ).
-            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getWorldTime() ) ).
-            	append( " Total Overworld Time: " ).
-            	append( Long.valueOf( MinecraftServer.getServer().worldServers[0].getTotalWorldTime() ) ).
-            	toString() );            	
-            
-            return;
-        }
-        // END FCMOD
 
         throw new WrongUsageException("commands.time.usage", new Object[0]);
     }
--- ComponentMineshaftCorridor.java	Fri Jul 27 13:35:25 2018
+++ ComponentMineshaftCorridor.java	Fri Apr 20 22:33:09 2018
@@ -199,9 +199,6 @@
             par1World.setBlock(var9, var10, var11, Block.rail.blockID, this.getMetadataWithOffset(Block.rail.blockID, par3Random.nextBoolean() ? 1 : 0), 2);
             EntityMinecartChest var12 = new EntityMinecartChest(par1World, (double)((float)var9 + 0.5F), (double)((float)var10 + 0.5F), (double)((float)var11 + 0.5F));
             WeightedRandomChestContent.generateChestContents(par3Random, par7ArrayOfWeightedRandomChestContent, var12, par8);
-            // FCMOD: Added
-            FilterChestMinecartContents( var12 );
-            // END FCMOD
             par1World.spawnEntityInWorld(var12);
             return true;
         }
@@ -229,11 +226,7 @@
 
             if (this.hasSpiders)
             {
-            	// FCMOD: Changed
-                //this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
-                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, 
-                	FCBetterThanWolves.fcBlockWeb.blockID, 0, false);
-                // END FCMOD            	
+                this.randomlyFillWithBlocks(par1World, par3StructureBoundingBox, par2Random, 0.6F, 0, 0, 0, 2, 1, var8, Block.web.blockID, 0, false);
             }
 
             int var9;
@@ -243,42 +236,19 @@
             for (var9 = 0; var9 < this.sectionCount; ++var9)
             {
                 var10 = 2 + var9 * 5;
-                // FCMOD: Code change to replace fences by logs
-                /*
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.fence.blockID, 0, false);
                 this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.fence.blockID, 0, false);
-                */
-                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 0, var10, 0, 1, var10, Block.wood.blockID, 0, 0, 0, false);
-                this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 0, var10, 2, 1, var10, Block.wood.blockID, 0, 0, 0, false);
-                // END FCMOD
-
-            	// FCMOD: Code added
-                int iHorizontalLogMetadata = getMetadataWithOffset( Block.wood.blockID, 4 );
-                // END FCMOD
-                
+
                 if (par2Random.nextInt(4) == 0)
                 {
-                	// FCMOD: Code change
-                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.planks.blockID, 0, false);
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
-                    */
-                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 0, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
-                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 2, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
-                	// END FCMOD
                 }
                 else
                 {
-                	// FCMOD: Code change
-                	/*
                     this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.planks.blockID, 0, false);
-                    */
-                    this.fillWithMetadataBlocks(par1World, par3StructureBoundingBox, 0, 2, var10, 2, 2, var10, Block.wood.blockID, iHorizontalLogMetadata, 0, 0, false);
-                	// END FCMOD
                 }
 
-                // FCMOD: Changed
-                /*
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, Block.web.blockID, 0);
@@ -289,18 +259,6 @@
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, Block.web.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, Block.torchWood.blockID, 0);
                 this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, Block.torchWood.blockID, 0);
-                */
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 - 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 0, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.1F, 2, 2, var10 + 1, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 - 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 0, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 2, 2, var10 + 2, FCBetterThanWolves.fcBlockWeb.blockID, 0);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 - 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);
-                this.randomlyPlaceBlock(par1World, par3StructureBoundingBox, par2Random, 0.05F, 1, 2, var10 + 1, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8);                
-                // END FCMOD
 
                 if (par2Random.nextInt(100) == 0)
                 {
@@ -362,89 +320,4 @@
             return true;
         }
     }
-    
-    // FCMOD: Added
-    private void FilterChestMinecartContents( EntityMinecartChest minecart )
-    {
-        for ( int iSlot = 0; iSlot < minecart.getSizeInventory(); iSlot++ )
-        {
-            ItemStack tempStack = minecart.getStackInSlot( iSlot );
-            
-            if ( tempStack != null )
-            {
-            	int iItemID = tempStack.itemID;
-
-            	if ( iItemID == Item.ingotIron.itemID )
-            	{
-            		if ( minecart.posY > 36F )
-            		{
-                		minecart.setInventorySlotContents( iSlot, null );
-            		}
-            		else
-            		{
-            			tempStack.stackSize = 1;
-            		}
-            	}
-            	else if ( iItemID == Item.diamond.itemID )
-            	{
-            		if ( minecart.posY > 24F )
-            		{
-                		minecart.setInventorySlotContents( iSlot, null );
-            		}
-            		else
-            		{
-            			tempStack.stackSize = 1;
-            		}
-            	}
-            	else if ( iItemID == Item.pickaxeIron.itemID )
-            	{
-            		minecart.setInventorySlotContents( iSlot, null );
-            	}
-            	else if ( iItemID == Item.redstone.itemID )
-            	{
-            		if ( minecart.posY > 24F )
-            		{
-                		minecart.setInventorySlotContents( iSlot, null );
-            		}
-            	}
-            	else if ( iItemID == Item.pumpkinSeeds.itemID )
-            	{
-            		minecart.setInventorySlotContents( iSlot, null );
-            	}            	
-            }
-        }
-    }
-
-    @Override
-    protected int getMetadataWithOffset( int iBlockID, int iMetadata )
-    {
-    	// override to handle horizontal log placement in supports
-    	
-    	if ( iBlockID == Block.wood.blockID )
-    	{
-            if (this.coordBaseMode == 1 || this.coordBaseMode == 3)
-            {
-            	int iLogType = iMetadata & 3;
-            	int iDirection = iMetadata & 12;
-            	
-            	if ( iDirection == 4 )
-            	{
-            		iDirection = 8;
-            	}
-            	else if ( iDirection == 8 )
-            	{
-            		iDirection = 4;
-            	}
-            	
-            	iMetadata = iLogType | iDirection;
-            }
-            
-    		return iMetadata;
-    	}
-    	else
-    	{
-    		return super.getMetadataWithOffset( iBlockID, iMetadata );
-    	}
-    }
-    // END FCMOD
 }
--- ComponentNetherBridgeEntrance.java	Wed Jan 17 13:21:47 2018
+++ ComponentNetherBridgeEntrance.java	Fri Apr 20 22:33:09 2018
@@ -117,10 +117,6 @@
             par1World.scheduledUpdatesAreImmediate = false;
         }
 
-        // FCMOD: Code added
-        placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockSoulforgeDormant.blockID, FCUtilsWorld.RotateFacingForCoordBaseMode( 4, coordBaseMode ), 5, 6, 6, par3StructureBoundingBox );
-        // END FCMOD
-
         return true;
     }
 }
--- ComponentScatteredFeatureDesertPyramid.java	Mon Apr  8 14:35:06 2019
+++ ComponentScatteredFeatureDesertPyramid.java	Fri Apr 20 22:33:09 2018
@@ -4,13 +4,10 @@
 
 public class ComponentScatteredFeatureDesertPyramid extends ComponentScatteredFeature
 {
-	// FCNOTE: Tracks the loot chests which have already been generated.
     private boolean[] field_74940_h = new boolean[4];
 
     /** List of items to generate in chests of Temples. */
-    // FCMOD: Removed as deprecated
-    //private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
-    // END FCMOD
+    private static final WeightedRandomChestContent[] itemsToGenerateInTemple = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
 
     public ComponentScatteredFeatureDesertPyramid(Random par1Random, int par2, int par3)
     {
@@ -21,8 +18,6 @@
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
@@ -227,316 +222,4 @@
 
         return true;
     }
-    */
-    // END FCMOD
-    
-    // FCMOD: Added New
-    private static final WeightedRandomChestContent[] m_LootListArray = 
-    	new WeightedRandomChestContent[] {
-    		// item ID, item damage, min stack size, max stack size, weight
-	    	new WeightedRandomChestContent( Item.helmetGold.itemID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( Item.plateGold.itemID, 0, 1, 1, 2 ), 
-	    	new WeightedRandomChestContent( Item.legsGold.itemID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( Item.bootsGold.itemID, 0, 1, 1, 2 ), 
-	    	new WeightedRandomChestContent( Item.swordGold.itemID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
-	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
-	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
-	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
-		};
-    
-    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
-    	new WeightedRandomChestContent[] {
-	    	new WeightedRandomChestContent( Item.bone.itemID, 0, 4, 6, 20 ), 
-	    	new WeightedRandomChestContent( Item.rottenFlesh.itemID, 0, 3, 7, 11 ),
-	    	new WeightedRandomChestContent( Item.skull.itemID, 0, 1, 1, 5 )
-		};
-    
-    public boolean addComponentParts( World world, Random generatorRand, 
-    	StructureBoundingBox boundingBox )
-    {
-    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
-    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
-    	
-    	// All cloth blocks from original have been replaced by obsidian, 
-    	// and allowances made for looted temples
-    	
-        fillWithBlocks(world, boundingBox, 0, -4, 0, this.scatteredFeatureSizeX - 1, 0, this.scatteredFeatureSizeZ - 1, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        
-        int var4;
-
-        for (var4 = 1; var4 <= 9; ++var4)
-        {
-            fillWithBlocks(world, boundingBox, var4, var4, var4, this.scatteredFeatureSizeX - 1 - var4, var4, this.scatteredFeatureSizeZ - 1 - var4, Block.sandStone.blockID, Block.sandStone.blockID, false);
-            fillWithBlocks(world, boundingBox, var4 + 1, var4, var4 + 1, this.scatteredFeatureSizeX - 2 - var4, var4, this.scatteredFeatureSizeZ - 2 - var4, 0, 0, false);
-        }
-
-        int var5;
-
-        for (var4 = 0; var4 < this.scatteredFeatureSizeX; ++var4)
-        {
-            for (var5 = 0; var5 < this.scatteredFeatureSizeZ; ++var5)
-            {
-                fillCurrentPositionBlocksDownwards(world, Block.sandStone.blockID, 0, var4, -5, var5, boundingBox);
-            }
-        }
-
-        var4 = getMetadataWithOffset(Block.stairsSandStone.blockID, 3);
-        var5 = getMetadataWithOffset(Block.stairsSandStone.blockID, 2);
-        
-        int var6 = getMetadataWithOffset(Block.stairsSandStone.blockID, 0);
-        int var7 = getMetadataWithOffset(Block.stairsSandStone.blockID, 1);
-        
-        fillWithBlocks(world, boundingBox, 0, 0, 0, 4, 9, 4, Block.sandStone.blockID, 0, false);
-        fillWithBlocks(world, boundingBox, 1, 10, 1, 3, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 10, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, 2, 10, 4, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, 0, 10, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 4, 10, 2, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 0, 0, this.scatteredFeatureSizeX - 1, 9, 4, Block.sandStone.blockID, 0, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 4, 10, 1, this.scatteredFeatureSizeX - 2, 10, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 10, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var5, this.scatteredFeatureSizeX - 3, 10, 4, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 5, 10, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, this.scatteredFeatureSizeX - 1, 10, 2, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 8, 0, 0, 12, 4, 4, Block.sandStone.blockID, 0, false);
-        fillWithBlocks(world, boundingBox, 9, 1, 0, 11, 3, 4, 0, 0, false);
-        
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 1, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 2, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 9, 3, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, 3, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 3, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 2, 1, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 11, 1, 1, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 4, 1, 1, 8, 3, 3, Block.sandStone.blockID, 0, false);
-        fillWithBlocks(world, boundingBox, 4, 1, 2, 8, 2, 2, 0, 0, false);
-        fillWithBlocks(world, boundingBox, 12, 1, 1, 16, 3, 3, Block.sandStone.blockID, 0, false);
-        fillWithBlocks(world, boundingBox, 12, 1, 2, 16, 2, 2, 0, 0, false);
-        fillWithBlocks(world, boundingBox, 5, 4, 5, this.scatteredFeatureSizeX - 6, 4, this.scatteredFeatureSizeZ - 6, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, 9, 4, 9, 11, 4, 11, 0, 0, false);
-        
-        fillWithMetadataBlocks(world, boundingBox, 8, 1, 8, 8, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        fillWithMetadataBlocks(world, boundingBox, 12, 1, 8, 12, 3, 8, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        fillWithMetadataBlocks(world, boundingBox, 8, 1, 12, 8, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        fillWithMetadataBlocks(world, boundingBox, 12, 1, 12, 12, 3, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        
-        fillWithBlocks(world, boundingBox, 1, 1, 5, 4, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 1, 5, this.scatteredFeatureSizeX - 2, 4, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, 6, 7, 9, 6, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 7, 7, 9, this.scatteredFeatureSizeX - 7, 7, 11, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        
-        fillWithMetadataBlocks(world, boundingBox, 5, 5, 9, 5, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        fillWithMetadataBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 5, 9, this.scatteredFeatureSizeX - 6, 7, 11, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        
-        placeBlockAtCurrentPosition(world, 0, 0, 5, 5, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 5, 6, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 6, 6, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 5, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 6, 6, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, this.scatteredFeatureSizeX - 7, 6, 10, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 2, 4, 4, 2, 6, 4, 0, 0, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 4, 4, this.scatteredFeatureSizeX - 3, 6, 4, 0, 0, false);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 4, 5, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, 2, 3, 4, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 4, 5, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var4, this.scatteredFeatureSizeX - 3, 3, 4, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 1, 1, 3, 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 3, 1, 3, this.scatteredFeatureSizeX - 2, 2, 3, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, 1, 1, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, 0, this.scatteredFeatureSizeX - 2, 1, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, 1, 2, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stoneSingleSlab.blockID, 1, this.scatteredFeatureSizeX - 2, 2, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var7, 2, 1, 2, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsSandStone.blockID, var6, this.scatteredFeatureSizeX - 3, 1, 2, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 4, 3, 5, 4, 3, 18, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 5, 3, 5, this.scatteredFeatureSizeX - 5, 3, 17, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, 3, 1, 5, 4, 2, 16, 0, 0, false);
-        fillWithBlocks(world, boundingBox, this.scatteredFeatureSizeX - 6, 1, 5, this.scatteredFeatureSizeX - 5, 2, 16, 0, 0, false);
-        
-        int var10;
-
-        for (var10 = 5; var10 <= 17; var10 += 2)
-        {
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 4, 1, var10, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 4, 2, var10, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, this.scatteredFeatureSizeX - 5, 1, var10, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, this.scatteredFeatureSizeX - 5, 2, var10, boundingBox);
-        }
-
-        // the following is the center tiled portion of the floor, centered on 10, 0, 10
-        
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 7, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 9, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 9, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 8, 0, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 12, 0, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 7, 0, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 13, 0, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 0, 11, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 0, 11, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 12, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 13, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 10, 0, 10, boundingBox);
-
-        for (var10 = 0; var10 <= this.scatteredFeatureSizeX - 1; var10 += this.scatteredFeatureSizeX - 1)
-        {
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 2, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 3, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 4, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 5, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 6, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 3, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 1, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 2, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 3, boundingBox);
-        }
-
-        for (var10 = 2; var10 <= this.scatteredFeatureSizeX - 3; var10 += this.scatteredFeatureSizeX - 3 - 2)
-        {
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 2, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 2, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 2, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 3, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 3, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 3, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 4, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 4, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 4, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 5, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 5, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 5, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 6, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, var10, 6, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 6, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 - 1, 7, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10, 7, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, var10 + 1, 7, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 - 1, 8, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10, 8, 0, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, var10 + 1, 8, 0, boundingBox);
-        }
-
-        fillWithMetadataBlocks(world, boundingBox, 8, 4, 0, 12, 6, 0, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        
-        placeBlockAtCurrentPosition(world, 0, 0, 8, 6, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 12, 6, 0, boundingBox);
-        
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 9, 5, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, 5, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.obsidian.blockID, 0, 11, 5, 0, boundingBox);
-        
-        fillWithMetadataBlocks(world, boundingBox, 8, -14, 8, 12, -11, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        fillWithMetadataBlocks(world, boundingBox, 8, -10, 8, 12, -10, 12, Block.sandStone.blockID, 1, Block.sandStone.blockID, 1, false);
-        fillWithMetadataBlocks(world, boundingBox, 8, -9, 8, 12, -9, 12, Block.sandStone.blockID, 2, Block.sandStone.blockID, 2, false);
-        
-        fillWithBlocks(world, boundingBox, 8, -8, 8, 12, -1, 12, Block.sandStone.blockID, Block.sandStone.blockID, false);
-        fillWithBlocks(world, boundingBox, 9, -11, 9, 11, -1, 11, 0, 0, false);
-        
-        placeBlockAtCurrentPosition(world, Block.pressurePlatePlanks.blockID, 0, 10, -11, 10, boundingBox);
-        
-        fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -13, 11, Block.tnt.blockID, 0, false);
-        
-        placeBlockAtCurrentPosition(world, 0, 0, 8, -11, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 8, -10, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 7, -10, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 7, -11, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 12, -11, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 12, -10, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 13, -10, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 13, -11, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 7, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 7, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, -11, 12, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, -10, 12, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 1, 10, -10, 13, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.sandStone.blockID, 2, 10, -11, 13, boundingBox);
-
-        for ( var10 = 0; var10 < 4; ++var10 )
-        {
-            if ( !field_74940_h[var10] )
-            {
-                int iXOffset = Direction.offsetX[var10] * 2;
-                int iZOffset = Direction.offsetZ[var10] * 2;
-                
-                WeightedRandomChestContent[] lootList = m_LootListArray;
-                int iNumItems = 2 + generatorRand.nextInt( 5 );
-
-            	if ( bIsLooted )
-            	{
-                    lootList = m_LootedLootListArray;
-                    iNumItems /= 2;
-            	}
-            	
-                // creates a modified loot list that includes instantiated items with complex data
-                // such as the following enchanted book with a random enchantment
-                
-            	WeightedRandomChestContent[] moddedLootList =
-                	WeightedRandomChestContent.func_92080_a( lootList, 
-                		new WeightedRandomChestContent[] { 
-            			Item.enchantedBook.func_92114_b( generatorRand ) } );
-            	
-                field_74940_h[var10] = generateStructureChestContents( world, boundingBox, 
-                	generatorRand, 10 + iXOffset, -11, 10 + iZOffset, 
-                	moddedLootList, iNumItems );
-            }
-        }
-
-        if ( bIsLooted )
-        {
-        	// clear the center of the floor for access to the shaft
-        	
-            fillWithBlocks(world, boundingBox, 9, 0, 9, 10, 0, 10, 0, 0, false);
-            
-            // clear out trapped area
-            
-            this.fillWithBlocks(world, boundingBox, 9, -13, 9, 11, -11, 11, 0, 0, false);            
-            
-            // drop a ladder
-            
-            int iLadderFacing = getMetadataWithOffset( Block.ladder.blockID, 5 ); // legacy ladder metadata is straight facing
-            
-            int iLadderMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iLadderFacing ); 
-            
-            for ( int iTempY = -13; iTempY <= 0; iTempY++ )
-            {
-            	placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockLadder.blockID, iLadderMetadata, 
-            		9, iTempY, 9, boundingBox );
-            }            
-        }
-        else
-        {
-        	// place enchanting table at center
-        	
-        	placeBlockAtCurrentPosition(world, Block.enchantmentTable.blockID, 0, 10, 1, 10, boundingBox );
-        }
-        
-        return true;
-    }
-    // END FCMOD
 }
--- ComponentScatteredFeatureJunglePyramid.java	Tue Apr  2 13:15:59 2019
+++ ComponentScatteredFeatureJunglePyramid.java	Fri Apr 20 22:33:09 2018
@@ -4,19 +4,13 @@
 
 public class ComponentScatteredFeatureJunglePyramid extends ComponentScatteredFeature
 {
-	// FCNOTE: These two track the loot chests which have already been generated.
     private boolean field_74947_h;
     private boolean field_74948_i;
-    
-    // FCMOD: Removed as deprecated
-    //private boolean field_74945_j;
-    //private boolean field_74946_k;
-    // END FCMOD
+    private boolean field_74945_j;
+    private boolean field_74946_k;
 
     /** List of Chest contents to be generated in the Jungle Pyramid chests. */
-    // FCMOD: Removed as deprecated
-    //private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
-    // END FCMOD
+    private static final WeightedRandomChestContent[] junglePyramidsChestContents = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.diamond.itemID, 0, 1, 3, 3), new WeightedRandomChestContent(Item.ingotIron.itemID, 0, 1, 5, 10), new WeightedRandomChestContent(Item.ingotGold.itemID, 0, 2, 7, 15), new WeightedRandomChestContent(Item.emerald.itemID, 0, 1, 3, 2), new WeightedRandomChestContent(Item.bone.itemID, 0, 4, 6, 20), new WeightedRandomChestContent(Item.rottenFlesh.itemID, 0, 3, 7, 16)};
 
     /**
      * List of Dispenser contents to be generated in the Jungle Pyramid dispensers.
@@ -35,8 +29,6 @@
      * second Part of Structure generating, this for example places Spiderwebs, Mob Spawners, it closes Mineshafts at
      * the end, it adds Fences...
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
         if (!this.func_74935_a(par1World, par3StructureBoundingBox, 0))
@@ -157,7 +149,6 @@
             this.placeBlockAtCurrentPosition(par1World, Block.tripWireSource.blockID, this.getMetadataWithOffset(Block.tripWireSource.blockID, 1) | 4, 4, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 2, -3, 8, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.tripWire.blockID, 4, 3, -3, 8, par3StructureBoundingBox);
-            
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 7, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 6, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 5, -3, 5, par3StructureBoundingBox);
@@ -184,7 +175,7 @@
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 9, -2, 4, par3StructureBoundingBox);
-            
+
             if (!this.field_74946_k)
             {
                 this.field_74946_k = this.generateStructureDispenserContents(par1World, par3StructureBoundingBox, par2Random, 9, -2, 3, 4, junglePyramidsDispenserContents, 2);
@@ -218,6 +209,13 @@
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 8, -3, 8, 8, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.fillWithRandomizedBlocks(par1World, par3StructureBoundingBox, 10, -3, 8, 10, -3, 10, false, par2Random, junglePyramidsRandomScatteredStones);
             this.placeBlockAtCurrentPosition(par1World, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 9, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 8, -2, 10, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.redstoneWire.blockID, 0, 10, -1, 9, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, 1, 9, -2, 8, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -2, 8, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.pistonStickyBase.blockID, this.getMetadataWithOffset(Block.pistonStickyBase.blockID, 4), 10, -1, 8, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.redstoneRepeaterIdle.blockID, this.getMetadataWithOffset(Block.redstoneRepeaterIdle.blockID, 2), 10, -2, 10, par3StructureBoundingBox);
 
             if (!this.field_74948_i)
             {
@@ -227,291 +225,4 @@
             return true;
         }
     }
-    */
-    // END FCMOD
-    
-    // FCMOD: Added New
-    private static final WeightedRandomChestContent[] m_LootListArray = 
-    	new WeightedRandomChestContent[] {
-    		// item ID, item damage, min stack size, max stack size, weight
-	    	new WeightedRandomChestContent( Item.pickaxeGold.itemID, 0, 1, 1, 2 ), 
-	    	new WeightedRandomChestContent( Item.shovelGold.itemID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( Item.axeGold.itemID, 0, 1, 1, 2 ), 
-	    	new WeightedRandomChestContent( Item.hoeGold.itemID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( FCBetterThanWolves.fcBlockLightningRod.blockID, 0, 1, 1, 5 ), 
-	    	new WeightedRandomChestContent( Item.emerald.itemID, 0, 1, 5, 15 ), 
-	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
-	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
-		};
-    
-    private static final WeightedRandomChestContent[] m_LootedLootListArray = 
-    	new WeightedRandomChestContent[] {
-	    	new WeightedRandomChestContent( Item.bowlEmpty.itemID, 0, 1, 1, 10 ), 
-	    	new WeightedRandomChestContent( Item.book.itemID, 0, 2, 4, 25 )
-		};
-    
-    public boolean addComponentParts( World world, Random generatorRand, 
-    	StructureBoundingBox boundingBox )
-    {
-        if ( !func_74935_a( world, boundingBox, 0 ) )
-        {
-            return false;
-        }
-        
-    	boolean bIsLooted = FCUtilsHardcoreSpawn.IsInLootedTempleRadius( world, 
-    		boundingBox.getCenterX(), boundingBox.getCenterZ() );
-    	
-        int var4 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 3 );
-        int var5 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 2 );
-        int var6 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 0 );
-        int var7 = getMetadataWithOffset( Block.stairsCobblestone.blockID, 1 );
-        
-        fillWithRandomizedBlocks(world, boundingBox, 0, -4, 0, scatteredFeatureSizeX - 1, 0, scatteredFeatureSizeZ - 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 2, 9, 2, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 12, 9, 2, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 1, 3, 2, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 9, 1, 3, 9, 2, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 1, 10, 6, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 13, 10, 6, 13, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 1, 3, 2, 1, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 10, 3, 2, 10, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 3, 2, 9, 3, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 6, 2, 9, 6, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 3, 7, 3, 8, 7, 11, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 4, 8, 4, 7, 8, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        
-        fillWithAir(world, boundingBox, 3, 1, 3, 8, 2, 11);
-        fillWithAir(world, boundingBox, 4, 3, 6, 7, 3, 9);
-        fillWithAir(world, boundingBox, 2, 4, 2, 9, 5, 12);
-        fillWithAir(world, boundingBox, 4, 6, 5, 7, 6, 9);
-        fillWithAir(world, boundingBox, 5, 7, 6, 6, 7, 8);
-        fillWithAir(world, boundingBox, 5, 1, 2, 6, 2, 2);
-        fillWithAir(world, boundingBox, 5, 2, 12, 6, 2, 12);
-        fillWithAir(world, boundingBox, 5, 5, 1, 6, 5, 1);
-        fillWithAir(world, boundingBox, 5, 5, 13, 6, 5, 13);
-        
-        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 5, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 5, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 1, 5, 9, boundingBox);
-        placeBlockAtCurrentPosition(world, 0, 0, 10, 5, 9, boundingBox);
-        
-        int var8;
-
-        for ( var8 = 0; var8 <= 14; var8 += 14 )
-        {
-            fillWithRandomizedBlocks(world, boundingBox, 2, 4, var8, 2, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-            fillWithRandomizedBlocks(world, boundingBox, 4, 4, var8, 4, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-            fillWithRandomizedBlocks(world, boundingBox, 7, 4, var8, 7, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-            fillWithRandomizedBlocks(world, boundingBox, 9, 4, var8, 9, 5, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-        }
-
-        this.fillWithRandomizedBlocks(world, boundingBox, 5, 6, 0, 6, 6, 0, false, generatorRand, junglePyramidsRandomScatteredStones);
-
-        for (var8 = 0; var8 <= 11; var8 += 11)
-        {
-            for (int var9 = 2; var9 <= 12; var9 += 2)
-            {
-                fillWithRandomizedBlocks(world, boundingBox, var8, 4, var9, var8, 5, var9, false, generatorRand, junglePyramidsRandomScatteredStones);
-            }
-
-            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 5, var8, 6, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
-            fillWithRandomizedBlocks(world, boundingBox, var8, 6, 9, var8, 6, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
-        }
-
-        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 2, 2, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 2, 9, 9, 2, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 2, 7, 12, 2, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 9, 7, 12, 9, 9, 12, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 4, 4, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 4, 7, 9, 4, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 4, 9, 10, 4, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 7, 9, 10, 7, 9, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 5, 9, 7, 6, 9, 7, false, generatorRand, junglePyramidsRandomScatteredStones);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 9, 6, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 9, 6, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 9, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 9, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 0, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 5, 0, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 6, 0, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 0, 0, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 1, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 2, 9, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 4, 3, 10, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 1, 8, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 2, 9, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var4, 7, 3, 10, boundingBox);
-        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 9, 4, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 7, 1, 9, 7, 1, 9, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 4, 1, 10, 7, 2, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 5, 4, 5, 6, 4, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
-        
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var6, 4, 4, 5, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var7, 7, 4, 5, boundingBox);
-
-        for (var8 = 0; var8 < 4; ++var8)
-        {
-            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 5, 0 - var8, 6 + var8, boundingBox);
-            placeBlockAtCurrentPosition(world, Block.stairsCobblestone.blockID, var5, 6, 0 - var8, 6 + var8, boundingBox);
-            fillWithAir(world, boundingBox, 5, 0 - var8, 7 + var8, 6, 0 - var8, 9 + var8);
-        }
-
-        fillWithAir(world, boundingBox, 1, -3, 12, 10, -1, 13);
-        fillWithAir(world, boundingBox, 1, -3, 1, 3, -1, 13);
-        fillWithAir(world, boundingBox, 1, -3, 1, 9, -1, 5);
-
-        for (var8 = 1; var8 <= 13; var8 += 2)
-        {
-            this.fillWithRandomizedBlocks(world, boundingBox, 1, -3, var8, 1, -2, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-        }
-
-        for (var8 = 2; var8 <= 12; var8 += 2)
-        {
-            this.fillWithRandomizedBlocks(world, boundingBox, 1, -1, var8, 3, -1, var8, false, generatorRand, junglePyramidsRandomScatteredStones);
-        }
-
-        fillWithRandomizedBlocks(world, boundingBox, 2, -2, 1, 5, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 7, -2, 1, 9, -2, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 6, -3, 1, 6, -3, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        fillWithRandomizedBlocks(world, boundingBox, 6, -1, 1, 6, -1, 1, false, generatorRand, junglePyramidsRandomScatteredStones);
-        
-        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 3, -3, 1, boundingBox);
-
-        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 3, -2, 2, boundingBox);
-        
-        placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 4, boundingBox);
-        
-        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -1, 3, boundingBox);
-        placeBlockAtCurrentPosition(world, Block.vine.blockID, 15, 8, -2, 3, boundingBox);
-
-        if ( !field_74947_h )
-        {
-            // creates a modified loot list that includes instantiated items with complex data
-            // such as the following enchanted book with a random enchantment
-            
-            WeightedRandomChestContent[] lootList = m_LootListArray;
-        	int iNumItems = 2 + generatorRand.nextInt( 5 );
-        	
-        	if ( bIsLooted )
-        	{
-                lootList = m_LootedLootListArray;
-                iNumItems /= 2;
-        	}
-        	
-            // creates a modified loot list that includes instantiated items with complex data
-            // such as the following enchanted book with a random enchantment
-            
-        	WeightedRandomChestContent[] moddedLootList =
-            	WeightedRandomChestContent.func_92080_a( lootList, 
-            		new WeightedRandomChestContent[] { 
-        			Item.enchantedBook.func_92114_b( generatorRand ) } );
-        	
-            field_74947_h = generateStructureChestContents( world, boundingBox, 
-            	generatorRand, 8, -3, 3, 
-            	moddedLootList, iNumItems );
-        }
-
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 9, -3, 2, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 1, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 4, -3, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -2, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 5, -1, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 6, -3, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -2, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 7, -1, 5, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 8, -3, 5, boundingBox);
-        this.fillWithRandomizedBlocks(world, boundingBox, 9, -1, 1, 9, -1, 5, false, generatorRand, junglePyramidsRandomScatteredStones);
-        this.fillWithAir(world, boundingBox, 8, -3, 8, 10, -1, 10);
-        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 8, -2, 11, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 9, -2, 11, boundingBox);
-        this.placeBlockAtCurrentPosition(world, Block.stoneBrick.blockID, 3, 10, -2, 11, boundingBox);
-        
-        if ( bIsLooted )
-        {
-        	// knock a hole in the wall where the levers used to be
-        	
-            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -2, 11, boundingBox);
-            this.placeBlockAtCurrentPosition(world, 0, 0, 9, -3, 11, boundingBox);                
-        }
-        
-        this.fillWithRandomizedBlocks(world, boundingBox, 8, -3, 8, 8, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        this.fillWithRandomizedBlocks(world, boundingBox, 10, -3, 8, 10, -3, 10, false, generatorRand, junglePyramidsRandomScatteredStones);
-        
-        this.placeBlockAtCurrentPosition(world, Block.cobblestoneMossy.blockID, 0, 10, -2, 9, boundingBox);
-        
-        if ( !field_74948_i )
-        {
-            // creates a modified loot list that includes instantiated items with complex data
-            // such as the following enchanted book with a random enchantment
-            
-            WeightedRandomChestContent[] lootList = m_LootListArray;
-        	int iNumItems = 2 + generatorRand.nextInt( 5 );
-        	
-        	if ( bIsLooted )
-        	{
-                lootList = m_LootedLootListArray;
-                iNumItems /= 2;
-        	}
-        	
-            // creates a modified loot list that includes instantiated items with complex data
-            // such as the following enchanted book with a random enchantment
-            
-        	WeightedRandomChestContent[] moddedLootList =
-            	WeightedRandomChestContent.func_92080_a( lootList, 
-            		new WeightedRandomChestContent[] { 
-        			Item.enchantedBook.func_92114_b( generatorRand ) } );
-        	
-        	field_74948_i = generateStructureChestContents( world, boundingBox, 
-            	generatorRand, 9, -3, 10, 
-            	moddedLootList, iNumItems );
-        }
-        
-        // Sacrificial altar
-        
-        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 5, 4, 11, boundingBox);
-        placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcAestheticOpaque.blockID, FCBlockAestheticOpaque.m_iSubtypeChoppingBlockDirty, 6, 4, 11, boundingBox);
-        
-        if ( !bIsLooted )
-        {
-        	if ( coordBaseMode != 3 && coordBaseMode != 2 )
-        	{
-                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 5, 3, 10, boundingBox);
-                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 6, 3, 10, boundingBox);
-                
-            	FillVesselWithExperience( world, boundingBox, 5, 3, 10 );
-        	}
-        	else
-        	{
-                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcBlockArcaneVessel.blockID, 0, 6, 3, 10, boundingBox);
-                placeBlockAtCurrentPosition(world, FCBetterThanWolves.fcHandCrank.blockID, 0, 5, 3, 10, boundingBox);
-                
-            	FillVesselWithExperience( world, boundingBox, 6, 3, 10 );
-        	}                
-        }
-        else
-        {
-            placeBlockAtCurrentPosition(world, 0, 0, 5, 3, 10, boundingBox);
-            placeBlockAtCurrentPosition(world, 0, 0, 6, 3, 10, boundingBox);
-        }
-
-        return true;
-    }
-    
-    public void FillVesselWithExperience( World world, StructureBoundingBox boundingBox, int iRelativeI, int iRelativeJ, int iRelativeK )
-    {
-        int iAbsoluteI = getXWithOffset( iRelativeI, iRelativeK );
-        int iAbsoluteJ = getYWithOffset( iRelativeJ );
-        int iAbsoluteK = getZWithOffset( iRelativeI, iRelativeK );
-        
-        TileEntity tileEnt = world.getBlockTileEntity( iAbsoluteI, iAbsoluteJ, iAbsoluteK );
-        
-        if ( tileEnt != null && ( tileEnt instanceof FCTileEntityArcaneVessel ) )
-        {
-            FCTileEntityArcaneVessel vesselEnt = (FCTileEntityArcaneVessel)tileEnt;
-            
-            vesselEnt.InitTempleExperience();
-        }
-    }
-    // END FCMOD
 }
--- ComponentScatteredFeatureSwampHut.java	Sun Nov 22 13:51:24 2020
+++ ComponentScatteredFeatureSwampHut.java	Fri Apr 20 22:33:09 2018
@@ -41,14 +41,8 @@
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 5, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.flowerPot.blockID, 7, 1, 3, 5, par3StructureBoundingBox);
-            // FCMOD: Removed
-            //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
-            //this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
-            // END FCMOD
-            // FCMOD: Code added to add brewing stand to witch huts
-            this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 2, 2, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.brewingStand.blockID, 0, 2, 3, 6, par3StructureBoundingBox);
-            // END FCMOD
+            this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 3, 2, 6, par3StructureBoundingBox);
+            this.placeBlockAtCurrentPosition(par1World, Block.cauldron.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 1, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 5, 2, 1, par3StructureBoundingBox);
             int var4 = this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3);
@@ -70,13 +64,6 @@
                 }
             }
 
-            // FCMOD: Added
-            if ( !m_bHasLootBasket )
-            {
-            	AddLootBasket( par1World, par3StructureBoundingBox, 3, 2, 6 );
-            }
-            // END FCMOD
-            
             if (!this.hasWitch)
             {
                 var8 = this.getXWithOffset(2, 5);
@@ -86,115 +73,14 @@
                 if (par3StructureBoundingBox.isVecInside(var8, var9, var10))
                 {
                     this.hasWitch = true;
-                    // FCMOD: Changed
-                    //EntityWitch var11 = new EntityWitch(par1World);
-                    FCEntityWitch var11 = new FCEntityWitch(par1World);
-                    var11.PreInitCreature();
-                    // END FCMOD
+                    EntityWitch var11 = new EntityWitch(par1World);
                     var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
                     var11.initCreature();
-                    // FCMOD: Added
-                    var11.SetPersistent( true );
-                    // END FCMOD
                     par1World.spawnEntityInWorld(var11);
                 }
-                
-            	// FCMOD: Added
-            	SpawnAdditionalWitches( par1World );
-            	// END FCMOD
             }
 
             return true;
         }
     }
-    
-    // FCMOD: Added
-    private boolean m_bHasLootBasket = false;
-    
-    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
-    
-    private void InitContentsArray()
-    {
-    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
-    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
-        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
-        	new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemMushroomRed.itemID, 0, 5, 16, 5 )
-        }; 
-    }
-    
-    private void SpawnAdditionalWitches( World world )
-    {
-    	int iNumWitches = 2;
-    	
-    	if ( !hasWitch )
-    	{
-    		iNumWitches++;
-    	}
-
-    	// constrain spawning to the chunk containing the structure component that we know is loaded
-    	// note that we can't rely on neighboring chunks with a component, like we can with a structure
-    	
-        int iMinSpawnX = ( boundingBox.minX >> 4 ) << 4;
-        int iMinSpawnZ = ( boundingBox.minZ >> 4 ) << 4;
-        
-        int iSpawnZoneWidth = 16;
-    	
-    	for ( int iTempCount = 0; iTempCount < iNumWitches; iTempCount++ )
-    	{
-    		for ( int iTempTries = 0; iTempTries < 20; iTempTries++ )
-    		{
-    			int iTempX = iMinSpawnX + world.rand.nextInt( iSpawnZoneWidth );
-    			int iTempZ = iMinSpawnZ + world.rand.nextInt( iSpawnZoneWidth );
-    			
-    			int iTempY = world.getTopSolidOrLiquidBlock( iTempX, iTempZ );
-    			
-    			if ( SpawnerAnimals.CanWitchSpawnAtLocationDuringWorldGen( 
-    				world, iTempX, iTempY, iTempZ ) )
-				{
-                    hasWitch = true;
-                    
-                    FCEntityWitch witch = new FCEntityWitch( world );
-                    
-                    // FCMOD: Added
-                    witch.PreInitCreature();
-                    // END FCMOD
-                    witch.setLocationAndAngles( (double)iTempX + 0.5D, (double)iTempY, (double)iTempZ + 0.5D, 0.0F, 0.0F);                    
-                    witch.initCreature();                    
-                    witch.SetPersistent( true );
-                    
-                    world.spawnEntityInWorld( witch );
-                    
-                    break;
-				}
-    		}
-    	}
-    }
-    
-    private void AddLootBasket( World world, StructureBoundingBox boundingBox, int iRelX, int iRelY, int iRelZ )
-    {
-    	if ( m_LootBasketContents == null )
-    	{
-    		// only initialize array on first use to ensure referenced mod items are intialized
-    		InitContentsArray();
-    	}
-    	
-    	int i = getXWithOffset( iRelX, iRelZ );
-        int j = getYWithOffset( iRelY );
-        int k = getZWithOffset( iRelX, iRelZ );
-    	
-        if ( boundingBox.isVecInside( i, j, k) && world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
-        {
-        	m_bHasLootBasket = true;
-        	
-	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
-	    	
-	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
-	    	
-	    	if ( tileEntity != null )
-	    	{
-	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
-	    	}
-        }	    	
-    }
-    // END FCMOD
 }
--- ComponentStrongholdLibrary.java	Thu Jun 21 15:12:21 2018
+++ ComponentStrongholdLibrary.java	Fri Apr 20 22:33:09 2018
@@ -111,8 +111,6 @@
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 8, 6, 11, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 9, 6, 10, par3StructureBoundingBox);
-                // FCMOD: Changed
-                /*
                 var7 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 1, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 2, 13, par3StructureBoundingBox);
@@ -121,18 +119,6 @@
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 5, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 6, 13, par3StructureBoundingBox);
                 this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var7, 10, 7, 13, par3StructureBoundingBox);
-                */
-                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
-                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
-                
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 1, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 2, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 3, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 4, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 5, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 6, 13, par3StructureBoundingBox);
-                placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 10, 7, 13, par3StructureBoundingBox);
-                // END FCMOD
                 byte var8 = 7;
                 byte var9 = 7;
                 this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, var8 - 1, 9, var9, par3StructureBoundingBox);
--- ComponentStrongholdRoomCrossing.java	Thu Jun 21 15:12:21 2018
+++ ComponentStrongholdRoomCrossing.java	Fri Apr 20 22:33:09 2018
@@ -139,19 +139,9 @@
                         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 3, var4, par3StructureBoundingBox);
                     }
 
-                    // FCMOD: Changed
-                    /*
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 1, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 2, 3, par3StructureBoundingBox);
                     this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, this.getMetadataWithOffset(Block.ladder.blockID, 4), 9, 3, 3, par3StructureBoundingBox);
-	                */
-	                int iFacing = getMetadataWithOffset( Block.ladder.blockID, 4 ); // legacy ladder metadata is straight facing
-	                int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
-	                
-                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 1, 3, par3StructureBoundingBox );
-                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 2, 3, par3StructureBoundingBox );
-                    placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 9, 3, 3, par3StructureBoundingBox );
-	                // END FCMOD
                     this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 3, 4, 8, WeightedRandomChestContent.func_92080_a(strongholdRoomCrossingChestContents, new WeightedRandomChestContent[] {Item.enchantedBook.func_92114_b(par2Random)}), 1 + par2Random.nextInt(4));
             }
 
--- ComponentVillage.java	Tue Oct  2 00:41:02 2018
+++ ComponentVillage.java	Fri Apr 20 22:33:09 2018
@@ -107,30 +107,6 @@
      */
     protected void spawnVillagers(World par1World, StructureBoundingBox par2StructureBoundingBox, int par3, int par4, int par5, int par6)
     {
-    	// FCMOD: Code added
-    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-    	
-    	boolean bDirtyPeasants = false;
-    	
-    	if ( iAbandonmentLevel > 1 )
-    	{
-    		if ( par1World.rand.nextInt( 20 ) != 0 )
-    		{
-    			// only a small chance villagers will spawn in fully abandoned villages
-    			
-    			return;
-    		}    		
-    		else if ( par6 > 1 )
-    		{
-    			// and in small dirty numbers if they do
-    			
-    			par6 = 1;    			
-    		}
-    		
-			bDirtyPeasants = true;
-    	}
-    	// END FCMOD
-    	
         if (this.villagersSpawned < par6)
         {
             for (int var7 = this.villagersSpawned; var7 < par6; ++var7)
@@ -145,45 +121,7 @@
                 }
 
                 ++this.villagersSpawned;
-                
-            	// FCMOD: Change
-                /*
                 EntityVillager var11 = new EntityVillager(par1World, this.getVillagerType(var7));
-                */
-                EntityLiving var11;
-                
-                int iVillagerType = this.getVillagerType(var7);
-                
-                if ( iVillagerType != 0 && iAbandonmentLevel > 0 )
-                {
-                	if ( iAbandonmentLevel > 1 || ( iVillagerType != 3 && iVillagerType != 4 ) ) // fully abandoned or not blacksmith or butcher
-                	{
-                		continue;
-                	}
-                }
-                
-                if ( par1World.getWorldInfo().getGameType() != EnumGameType.CREATIVE )
-                {
-                	FCEntityZombie zombieVillager = new FCEntityZombie( par1World );
-                	
-                	zombieVillager.m_iVillagerClass = iVillagerType;
-                	zombieVillager.SetPersistent( true );                	
-            		zombieVillager.setVillager( true );
-                	
-                	var11 = zombieVillager;
-                }
-                else
-                {
-                	FCEntityVillager villager = new FCEntityVillager( par1World, iVillagerType ); 
-                    
-                    if ( bDirtyPeasants )
-                    {
-                    	villager.SetDirtyPeasant( 1 );
-                    }
-                    
-                    var11 = villager;
-                }
-                // END FCMOD
                 var11.setLocationAndAngles((double)var8 + 0.5D, (double)var9, (double)var10 + 0.5D, 0.0F, 0.0F);
                 par1World.spawnEntityInWorld(var11);
             }
--- ComponentVillageChurch.java	Fri Jul 27 13:35:25 2018
+++ ComponentVillageChurch.java	Fri Apr 20 22:33:09 2018
@@ -65,8 +65,6 @@
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 3), 3, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 1), 1, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsCobblestone.blockID, this.getMetadataWithOffset(Block.stairsCobblestone.blockID, 0), 3, 2, 7, par3StructureBoundingBox);
-        // FCMOD: Code change
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
@@ -86,76 +84,17 @@
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 3, 4, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 4, 5, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 6, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 7, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 6, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 7, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 6, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 7, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 3, 8, par3StructureBoundingBox);
-
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 7, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 4, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 3, 4, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 4, 5, par3StructureBoundingBox);
-    	}
-        else
-        {
-        	// cut out holes where windows normally are
-        	
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 6, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 7, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 6, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 7, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 6, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 7, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 3, 8, par3StructureBoundingBox);
-        }
-        // END FCMOD
         int var4 = this.getMetadataWithOffset(Block.ladder.blockID, 4);
         int var5;
 
         for (var5 = 1; var5 <= 9; ++var5)
         {
-        	// FCMOD: Changed
-            //this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
-            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, var4 );
-            
-            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, var5, 3, par3StructureBoundingBox);
-            // END FCMOD
+            this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, var5, 3, par3StructureBoundingBox);
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        // FCMOD: Changed
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( iAbandonmentLevel == 0 )
-        {
-            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
-            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-    	// END FCMOD
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
--- ComponentVillageField.java	Mon Feb 11 00:25:22 2019
+++ ComponentVillageField.java	Fri Apr 20 22:33:09 2018
@@ -44,10 +44,7 @@
                 return Block.potato.blockID;
 
             default:
-            	// FCMOD: Changed
-                //return Block.crops.blockID;
-                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
-                // END FCMOD
+                return Block.crops.blockID;
         }
     }
 
@@ -63,13 +60,6 @@
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
-    	// FCMOD: Added
-        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
-        cropTypeB = cropTypeA;
-        cropTypeC = cropTypeA;
-        cropTypeD = startPiece.GetSecondaryCropBlockID( par1World );
-        // END FCMOD
-        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -83,74 +73,21 @@
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 12, 4, 8, 0, 0, false);
-    	// FCMOD: Changed
-    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
-        */
-    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-    	
-    	if ( iAbandonmentLevel <= 1 )
-    	{
-            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-    	}
-    	else
-    	{
-            fillWithBlocks( par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 7, 0, 1, 8, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-            
-            fillWithBlocks( par1World, par3StructureBoundingBox, 10, 0, 1, 11, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-    	}
-    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 12, 0, 0, 12, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 11, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 11, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
-    	// FCMOD: Changed
-        /*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
-        */
-    	if ( iAbandonmentLevel <= 1 )
-        {
-            this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
-            this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 0, 1, 9, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
-        }
-        // END FCMOD
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
-        	// FCMOD: Changed
-        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
@@ -159,74 +96,6 @@
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeC, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 8, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 10, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeD, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 11, 1, var4, par3StructureBoundingBox);
-            */
-            placeBlockAtCurrentPosition( par1World, cropTypeA, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	1, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeA, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	2, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeB, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	4, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeB, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	5, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeC, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	7, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeC, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	8, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeD, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	10, 1, var4, par3StructureBoundingBox);
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeD, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	11, 1, var4, par3StructureBoundingBox);
-        	// END FCMOD
-            
-            // FCMOD: Added
-        	if ( iAbandonmentLevel > 1 )
-            {
-            	// delete all generated crops after placing so as not to disturb random number generator
-            	
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 7, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 10, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 11, 1, var4, par3StructureBoundingBox);
-            }
-        	else if ( iAbandonmentLevel == 1 )
-        	{
-        		// randomly destroy some of the crops to give the impression of the field being only partially tended
-        		
-        		for ( int iTempCount = 1; iTempCount <= 10; iTempCount += 3 )
-        		{
-        			// use the world random so as not to mess with generation
-        			
-        			if ( par1World.rand.nextInt( 3 ) != 0 )
-        			{
-                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
-        			}
-        			
-        			if ( par1World.rand.nextInt( 3 ) != 0 )
-        			{
-                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
-        			}
-        		}
-        	}
-            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
--- ComponentVillageField2.java	Mon Feb 11 00:44:34 2019
+++ ComponentVillageField2.java	Fri Apr 20 22:33:09 2018
@@ -36,10 +36,7 @@
                 return Block.potato.blockID;
 
             default:
-            	// FCMOD: Changed
-                //return Block.crops.blockID;
-                return FCBetterThanWolves.fcBlockWheatCrop.blockID;
-                // END FCMOD
+                return Block.crops.blockID;
         }
     }
 
@@ -55,11 +52,6 @@
      */
     public boolean addComponentParts(World par1World, Random par2Random, StructureBoundingBox par3StructureBoundingBox)
     {
-    	// FCMOD: Added
-        cropTypeA = startPiece.GetPrimaryCropBlockID( par1World );
-        cropTypeB = startPiece.GetSecondaryCropBlockID( par1World );
-    	// END FCMOD
-        
         if (this.averageGroundLevel < 0)
         {
             this.averageGroundLevel = this.getAverageGroundLevel(par1World, par3StructureBoundingBox);
@@ -73,99 +65,21 @@
         }
 
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 0, 6, 4, 8, 0, 0, false);
-    	// FCMOD: Changed
-    	/*
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, Block.tilledField.blockID, Block.tilledField.blockID, false);
-        */
-    	int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-    	if ( iAbandonmentLevel <= 1 )
-    	{
-            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-            
-            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, 
-            	FCBetterThanWolves.fcBlockFarmland.blockID, false );
-    	}
-    	else
-    	{
-            fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 1, 2, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-            
-            fillWithBlocks(par1World, par3StructureBoundingBox, 4, 0, 1, 5, 0, 7, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, 
-            	FCBetterThanWolves.fcBlockDirtLoose.blockID, false );
-    	}
-    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 0, 0, 0, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 0, 0, 6, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 0, 5, 0, 0, Block.wood.blockID, Block.wood.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, 8, 5, 0, 8, Block.wood.blockID, Block.wood.blockID, false);
-        // FCMOD: Added
-    	if ( iAbandonmentLevel <= 1 )
-    	// END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 0, 1, 3, 0, 7, Block.waterMoving.blockID, Block.waterMoving.blockID, false);
         int var4;
 
         for (var4 = 1; var4 <= 7; ++var4)
         {
-        	// FCMOD: Changed
-        	/*
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 1, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeA, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 2, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 4, 1, var4, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, this.cropTypeB, MathHelper.getRandomIntegerInRange(par2Random, 2, 7), 5, 1, var4, par3StructureBoundingBox);
-            */
-            placeBlockAtCurrentPosition( par1World, cropTypeA, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	1, 1, var4, par3StructureBoundingBox );
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeA, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	2, 1, var4, par3StructureBoundingBox );
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeB, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	4, 1, var4, par3StructureBoundingBox );
-            
-            placeBlockAtCurrentPosition( par1World, cropTypeB, 
-            	MathHelper.getRandomIntegerInRange(par2Random, 2, 5), 
-            	5, 1, var4, par3StructureBoundingBox );
-        	// END FCMOD
-            
-            // FCMOD: Added
-        	if ( iAbandonmentLevel > 1 )
-            {
-            	// delete all generated crops after placing so as not to disturb random number generator
-            	
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 1, var4, par3StructureBoundingBox);
-                this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, var4, par3StructureBoundingBox);
-            }
-        	else if ( iAbandonmentLevel == 1 )
-        	{
-        		// randomly destroy some of the crops to give the impression of the field being only partially tended
-        		
-        		for ( int iTempCount = 1; iTempCount <= 4; iTempCount += 3 )
-        		{
-        			// use the world random so as not to mess with generation
-        			
-        			if ( par1World.rand.nextInt( 3 ) != 0 )
-        			{
-                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount, 1, var4, par3StructureBoundingBox);
-        			}
-        			
-        			if ( par1World.rand.nextInt( 3 ) != 0 )
-        			{
-                        this.placeBlockAtCurrentPosition(par1World, 0, 0, iTempCount + 1, 1, var4, par3StructureBoundingBox);
-        			}
-        		}
-        	}        		
-            // END FCMOD
         }
 
         for (var4 = 0; var4 < 9; ++var4)
--- ComponentVillageHall.java	Fri Jul 27 13:35:25 2018
+++ ComponentVillageHall.java	Fri Apr 20 22:33:09 2018
@@ -77,8 +77,6 @@
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
@@ -87,42 +85,8 @@
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
-    	}
-        else
-        {
-        	// cut out holes where windows normally are
-        	
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
-        }
-        // END FCMOD
-        // FCMOD: Code change to replace pressure plate tables with actual mod tables
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 3, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
-        	2, 1, 3, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 3, par3StructureBoundingBox);
@@ -131,17 +95,8 @@
         this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 6, 1, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( iAbandonmentLevel <= 1 )
-        {
-        	placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
-            placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
-            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-        // END FCMOD
+        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
         {
@@ -150,17 +105,8 @@
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
-        
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( iAbandonmentLevel <= 1 )
-        {
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 6, 3, 4, par3StructureBoundingBox);
-            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, 
-            	this.getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-        // END FCMOD
+        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 6, 3, 4, par3StructureBoundingBox);
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 6, 1, 5, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
 
         for (var6 = 0; var6 < 5; ++var6)
         {
--- ComponentVillageHouse1.java	Sun Apr  8 18:13:11 2018
+++ ComponentVillageHouse1.java	Fri Apr 20 22:33:09 2018
@@ -69,8 +69,6 @@
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 5, 7, 4, 5, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 8, 2, 1, 8, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 2, 0, 7, 4, 0, Block.planks.blockID, Block.planks.blockID, false);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
@@ -89,54 +87,6 @@
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 3, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 3, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 6, 2, 5, par3StructureBoundingBox);
-    	}
-        else
-        {
-        	// cut out holes where windows normally are
-        	
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 3, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 2, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 8, 3, 3, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 5, 2, 5, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 6, 2, 5, par3StructureBoundingBox);
-        }        	
-        // END FCMOD
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 1, 7, 4, 1, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 4, 4, 7, 4, 4, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 3, 4, 7, 3, 4, Block.bookShelf.blockID, Block.bookShelf.blockID, false);
@@ -147,33 +97,14 @@
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 5, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 4, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, var6, 3, 1, 4, par3StructureBoundingBox);
-        // FCMOD: Code change to replace pressure plate tables with actual mod tables
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 4, 1, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 4, 2, 3, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
-        	6, 1, 3, par3StructureBoundingBox);
-        
-        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
-        	4, 1, 3, par3StructureBoundingBox);
-        // FCMOD
-        
-        // FCMOD: Removed
-        //this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
-        // END FCMOD
+        this.placeBlockAtCurrentPosition(par1World, Block.workbench.blockID, 0, 7, 1, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        // FCMOD: Changed
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
-        {
-            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
-            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-    	// END FCMOD
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
--- ComponentVillageHouse2.java	Tue Apr 23 13:12:23 2019
+++ ComponentVillageHouse2.java	Fri Apr 20 22:33:09 2018
@@ -58,70 +58,21 @@
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 5, 1, 0, 5, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 9, 1, 0, 9, 3, 0, Block.fence.blockID, Block.fence.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 6, 1, 4, 9, 4, 6, Block.cobblestone.blockID, Block.cobblestone.blockID, false);
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
-        //this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
-        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox );
-        placeBlockAtCurrentPosition( par1World, Block.waterMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox );
-        // END FCMOD
+        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 7, 1, 5, par3StructureBoundingBox);
+        this.placeBlockAtCurrentPosition(par1World, Block.lavaMoving.blockID, 0, 8, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fenceIron.blockID, 0, 9, 2, 4, par3StructureBoundingBox);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 7, 2, 4, 8, 2, 5, 0, 0, false);
         this.placeBlockAtCurrentPosition(par1World, Block.cobblestone.blockID, 0, 6, 1, 3, par3StructureBoundingBox);
-        // FCMOD: Changed
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.furnaceIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 2, 3, par3StructureBoundingBox);
-            placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockFurnaceBrickIdle.blockID, 0, 6, 3, 3, par3StructureBoundingBox);
-    	}
-        // END FCMOD
-        
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
-        if ( iAbandonmentLevel == 0 )
-    	{
-        	placeBlockAtCurrentPosition(par1World, Block.anvil.blockID, par1World.rand.nextInt( 4 ), 8, 1, 1, par3StructureBoundingBox);
-    	}
-        // END FCMOD
-        
-        // FCMOD: Changed to remove glass from abandoned villages
-        /*
+        this.placeBlockAtCurrentPosition(par1World, Block.stoneDoubleSlab.blockID, 0, 8, 1, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
-        */
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 6, par3StructureBoundingBox);
-        }
-        else
-        {
-        	// cut out holes where windows normally are
-        	
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 6, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 6, par3StructureBoundingBox);
-        }        	
-        // END FCMOD
-        // FCMOD: Changed to replace pressure plate tables with actual mod tables
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 2, 1, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
-        	2, 1, 4, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 3), 2, 1, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.stairsWoodOak.blockID, this.getMetadataWithOffset(Block.stairsWoodOak.blockID, 1), 1, 1, 4, par3StructureBoundingBox);
@@ -138,25 +89,6 @@
             {
                 this.hasMadeChest = true;
                 this.generateStructureChestContents(par1World, par3StructureBoundingBox, par2Random, 5, 1, 5, villageBlacksmithChestContents, 3 + par2Random.nextInt(6));
-                // FCMOD: Added
-                if ( startPiece.GetAbandonmentLevel( par1World ) > 0 )
-                {
-                	// delete the chest after generation so as not to mess with the terrain generator
-                	
-                    int iChestI = getXWithOffset( 5, 5 );
-                    int iChestJ = getYWithOffset( 1 );
-                    int iChestK = getZWithOffset( 5, 5 );
-                    
-                    TileEntityChest chestEnt = (TileEntityChest)par1World.getBlockTileEntity( iChestI, iChestJ, iChestK );
-                    
-                    if ( chestEnt != null )
-                    {
-                    	FCUtilsInventory.ClearInventoryContents( chestEnt );
-                    }
-                	
-                    placeBlockAtCurrentPosition(par1World, 0, 0, 5, 1, 5, par3StructureBoundingBox);                    
-                }
-                // END FCMOD
             }
         }
 
--- ComponentVillageHouse3.java	Fri Jul 27 13:35:25 2018
+++ ComponentVillageHouse3.java	Fri Apr 20 22:33:09 2018
@@ -108,89 +108,34 @@
             }
         }
 
-        // FCMOD: Code added to remove glass from abandoned villages
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        int iGlassBlockID = 0;
-        
-        if ( iAbandonmentLevel == 0 )
-        {
-        	iGlassBlockID = Block.thinGlass.blockID;
-        }
-        // END FCMOD
-        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 0, 2, 4, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 3, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 2, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 0, 2, 3, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 2, 0, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 2, 0, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 2, 0, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 1, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 3, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 2, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 3, par3StructureBoundingBox);        
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 8, 2, 5, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 6, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 8, 2, 8, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 7, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 8, 2, 8, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 8, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 6, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 7, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 8, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 7, par3StructureBoundingBox);
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 2, 2, 8, par3StructureBoundingBox);
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 2, 2, 9, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 4, 4, 10, par3StructureBoundingBox);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 5, 4, 10, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, iGlassBlockID, 0, 5, 4, 10, par3StructureBoundingBox);
-        // END FCMOD        
         this.placeBlockAtCurrentPosition(par1World, Block.wood.blockID, 0, 6, 4, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 5, 5, 10, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 0, par3StructureBoundingBox);
-        
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( iAbandonmentLevel <= 1 )
-        {
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
-            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, 
-            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-        // END FCMOD
-        	
+        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 2, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 0, -1, 3, 2, -1, 0, 0, false);
 
         if (this.getBlockIdAtCurrentPosition(par1World, 2, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 2, -1, -1, par3StructureBoundingBox) != 0)
--- ComponentVillageHouse4_Garden.java	Fri Jul 27 13:35:25 2018
+++ ComponentVillageHouse4_Garden.java	Fri Apr 20 22:33:09 2018
@@ -58,27 +58,9 @@
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 0, 1, 1, 0, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 4, 1, 1, 4, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 3, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 2, 2, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 4, 2, 2, par3StructureBoundingBox);
-    	}
-        else
-        {
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 2, 2, 4, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 4, 2, 2, par3StructureBoundingBox);
-        }
-        // END FCMOD
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 0, 1, 3, 0, par3StructureBoundingBox);
@@ -118,31 +100,14 @@
 
         if (this.isRoofAccessible)
         {
-            // FCMOD: Changed
-        	/*
             var4 = this.getMetadataWithOffset(Block.ladder.blockID, 3);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 2, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 3, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.ladder.blockID, var4, 3, 4, 3, par3StructureBoundingBox);
-            */
-            int iFacing = getMetadataWithOffset( Block.ladder.blockID, 3 ); // legacy ladder metadata is straight facing
-            int iMetadata = FCBetterThanWolves.fcBlockLadder.SetFacing( 0, iFacing );                
-            
-            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 1, 3, par3StructureBoundingBox );
-            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 2, 3, par3StructureBoundingBox );
-            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 3, 3, par3StructureBoundingBox );
-            placeBlockAtCurrentPosition( par1World, FCBetterThanWolves.fcBlockLadder.blockID, iMetadata, 3, 4, 3, par3StructureBoundingBox );
-            // END FCMOD
         }
 
-        // FCMOD: Changed
-        //this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
-        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
-        {
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 1, par3StructureBoundingBox);
-        }
-        // END FCMOD
+        this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 1, par3StructureBoundingBox);
 
         for (var4 = 0; var4 < 5; ++var4)
         {
--- ComponentVillageStartPiece.java	Sun Feb 10 22:44:38 2019
+++ ComponentVillageStartPiece.java	Fri Apr 20 22:33:09 2018
@@ -37,94 +37,4 @@
     {
         return this.worldChunkMngr;
     }
-    
-    // FCMOD: Code added
-    private int m_iAbandonmentLevel;  // 0 = not abandoned, 1 = partially abandoned 2 = fully abandonded
-    private int m_iPrimaryCropBlockID;
-    private int m_iSecondaryCropBlockID;
-    private boolean m_bModSpecificDataInitialized = false;
-
-    public int GetAbandonmentLevel( World world )
-    {
-    	CheckIfModSpecificDataRequiresInit( world );
-    	
-    	return m_iAbandonmentLevel;
-    }
-    
-    public int GetPrimaryCropBlockID( World world )
-    {
-    	CheckIfModSpecificDataRequiresInit( world );
-    	
-    	return m_iPrimaryCropBlockID;
-    }
-    
-    public int GetSecondaryCropBlockID( World world )
-    {
-    	CheckIfModSpecificDataRequiresInit( world );
-    	
-    	return m_iSecondaryCropBlockID;
-    }
-    
-    private void CheckIfModSpecificDataRequiresInit( World world )
-    {
-    	if ( !m_bModSpecificDataInitialized )
-    	{
-    		InitializeModSpecificData( world );    		
-    	}
-    }
-    
-    private void InitializeModSpecificData( World world )
-    {    	
-		m_bModSpecificDataInitialized = true;
-		m_iAbandonmentLevel = 0;
-    	
-    	int iSpawnX = world.getWorldInfo().getSpawnX();
-    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
-    	
-    	int iVillageX = boundingBox.getCenterX();
-    	int iVillageZ = boundingBox.getCenterZ();
-    	
-    	double dDeltaX = (double)( iSpawnX - iVillageX );
-    	double dDeltaZ = (double)( iSpawnZ - iVillageZ );
-    	
-    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;    	
-    	double dAbandonedRadius = FCUtilsHardcoreSpawn.GetAbandonedVillageRadius();
-    	
-    	if ( dDistSqFromSpawn < ( dAbandonedRadius * dAbandonedRadius ) )
-    	{
-    		m_iAbandonmentLevel = 2;
-    	}
-    	else
-    	{
-    		double dPartiallyAbandonedRadius = FCUtilsHardcoreSpawn.GetPartiallyAbandonedVillageRadius();
-    		
-    		if ( dDistSqFromSpawn < ( dPartiallyAbandonedRadius * dPartiallyAbandonedRadius ) )
-    		{    		
-        		m_iAbandonmentLevel = 1;
-        		
-    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
-    			m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
-    		}
-    		else
-    		{	
-    			m_iPrimaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
-    			
-    			int iRandomFactor = world.rand.nextInt( 6 ); 
-    			
-    			if ( iRandomFactor == 5 )
-    			{
-    				m_iSecondaryCropBlockID = Block.potato.blockID;
-    			}
-    			else if ( iRandomFactor == 4 )
-    			{
-    				m_iSecondaryCropBlockID = Block.carrot.blockID;
-    			}
-    			else
-    			{
-    				m_iSecondaryCropBlockID = FCBetterThanWolves.fcBlockWheatCrop.blockID;
-    			}
-    		}
-    	}
-    }
-    // END FCMOD
 }
--- ComponentVillageTorch.java	Fri Jul 27 13:35:25 2018
+++ ComponentVillageTorch.java	Fri Apr 20 22:33:09 2018
@@ -42,24 +42,11 @@
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 0, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, 1, 2, 0, par3StructureBoundingBox);
-        // FCMOD: Code change
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.cloth.blockID, 15, 1, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 0, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, 1, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 2, 3, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.torchWood.blockID, 0, 1, 3, -1, par3StructureBoundingBox);
-        */
-        this.placeBlockAtCurrentPosition(par1World, Block.planks.blockID, 1, 1, 3, 0, par3StructureBoundingBox);
-        
-        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
-        {
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 0, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, 1, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 2, 3, 0, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockTorchFiniteUnlit.blockID, 8, 1, 3, -1, par3StructureBoundingBox);
-        }
-        // END FCMOD        
         return true;
     }
 }
--- ComponentVillageWoodHut.java	Sun Apr  8 18:15:15 2018
+++ ComponentVillageWoodHut.java	Fri Apr 20 22:33:09 2018
@@ -73,48 +73,18 @@
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 3, 1, 1, 3, 3, 3, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 0, 2, 3, 0, Block.planks.blockID, Block.planks.blockID, false);
         this.fillWithBlocks(par1World, par3StructureBoundingBox, 1, 1, 4, 2, 3, 4, Block.planks.blockID, Block.planks.blockID, false);
-        // FCMOD: Code change to remove glass from abandoned villages
-        /*
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
-        */
-        int iAbandonmentLevel = startPiece.GetAbandonmentLevel( par1World );
-        
-        if ( iAbandonmentLevel == 0 )
-    	{
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, Block.thinGlass.blockID, 0, 3, 2, 2, par3StructureBoundingBox);
-    	}
-        else
-        {
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 0, 2, 2, par3StructureBoundingBox);
-            this.placeBlockAtCurrentPosition(par1World, 0, 0, 3, 2, 2, par3StructureBoundingBox);
-        }
-        // END FCMOD
 
         if (this.tablePosition > 0)
         {
-            // FCMOD: Code change to replace pressure plate tables with actual mod tables
-            /*
             this.placeBlockAtCurrentPosition(par1World, Block.fence.blockID, 0, this.tablePosition, 1, 3, par3StructureBoundingBox);
             this.placeBlockAtCurrentPosition(par1World, Block.pressurePlatePlanks.blockID, 0, this.tablePosition, 2, 3, par3StructureBoundingBox);
-            */
-            this.placeBlockAtCurrentPosition(par1World, FCBetterThanWolves.fcBlockWoodOakMouldingAndDecorative.blockID, FCBlockMouldingAndDecorative.m_iSubtypeTable, 
-            	this.tablePosition, 1, 3, par3StructureBoundingBox);
-        	// END FCMOD
         }
 
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 1, 0, par3StructureBoundingBox);
         this.placeBlockAtCurrentPosition(par1World, 0, 0, 1, 2, 0, par3StructureBoundingBox);
-        
-        // FCMOD: Changed
-        //this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
-        if ( startPiece.GetAbandonmentLevel( par1World ) <= 1 )
-        {
-            this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, 
-            	getMetadataWithOffset(FCBetterThanWolves.fcBlockDoorWood.blockID, 1));
-        }
-    	// END FCMOD
+        this.placeDoorAtCurrentPosition(par1World, par3StructureBoundingBox, par2Random, 1, 1, 0, this.getMetadataWithOffset(Block.doorWood.blockID, 1));
 
         if (this.getBlockIdAtCurrentPosition(par1World, 1, 0, -1, par3StructureBoundingBox) == 0 && this.getBlockIdAtCurrentPosition(par1World, 1, -1, -1, par3StructureBoundingBox) != 0)
         {
--- Container.java	Fri Aug 10 01:16:07 2018
+++ Container.java	Fri Apr 20 22:33:09 2018
@@ -558,8 +558,6 @@
     /**
      * merges provided ItemStack with the first avaliable one in the container/player inventory
      */
-    // FCMOD: Removed and replaced later
-    /*
     protected boolean mergeItemStack(ItemStack par1ItemStack, int par2, int par3, boolean par4)
     {
         boolean var5 = false;
@@ -649,8 +647,6 @@
 
         return var5;
     }
-    */
-    // END FCMOD
 
     public static int func_94529_b(int par0)
     {
@@ -732,169 +728,4 @@
             return MathHelper.floor_float(var2 * 14.0F) + (var1 > 0 ? 1 : 0);
         }
     }
-    
-    // FCMOD: Added
-    protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap, boolean bFavorHotbar )
-    {
-    	// test of specific player inv size shouldn't be necessary, but serves as a sanity check
-    	
-    	if ( bFavorHotbar && iSlotDestCap - iSlotDestFirst == 36 )
-    	{
-        	// favor the hotbar from left to right, then the main inventory, whereas vanilla
-    		// just reverses the order from last slot of hotbar to first of inv.
-    		
-        	return MergeItemStackFavoringHotbar( stackSource, iSlotDestFirst, iSlotDestCap );
-    	}
-    	else
-    	{    	
-    		return mergeItemStack( stackSource, iSlotDestFirst, iSlotDestCap );
-    	}
-    }
-    
-	protected boolean mergeItemStack( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
-	{
-	    boolean bMerged = false;
-	    
-	    if ( stackSource.isStackable() )
-	    {
-	    	// look for destination stacks already containing the same item type
-	    	
-		    for ( int iTempSlot = iSlotDestFirst; 
-		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
-	        {
-		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
-	        }
-	    }
-	
-	    if ( stackSource.stackSize > 0 )
-	    {
-	    	// look for empty destination stacks
-	    	
-		    for ( int iTempSlot = iSlotDestFirst; 
-	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
-	        {	
-		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
-	        }
-	    }
-	
-	    return bMerged;
-	}
-    
-	protected boolean MergeItemStackFavoringHotbar( ItemStack stackSource, int iSlotDestFirst, int iSlotDestCap )
-	{
-	    boolean bMerged = false;
-
-	    if ( stackSource.isStackable() )
-	    {
-	    	// look for destination stacks already containing the same item type
-	    	
-		    for ( int iTempSlot = iSlotDestCap - 9; 
-		    	iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
-	        {
-		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
-	        }
-		    
-		    for ( int iTempSlot = iSlotDestFirst; 
-	    		iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
-		    {
-		    	bMerged |= AttemptToMergeWithSlot( stackSource, iTempSlot );
-	        }
-	    }
-	
-	    if ( stackSource.stackSize > 0 )
-	    {
-	    	// look for empty destination stacks
-	    	
-		    for ( int iTempSlot = iSlotDestCap - 9; 
-	    		iTempSlot < iSlotDestCap && stackSource.stackSize > 0; iTempSlot++ )
-	        {	
-		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
-	        }
-	    	
-		    for ( int iTempSlot = iSlotDestFirst; 
-    			iTempSlot < iSlotDestCap - 9 && stackSource.stackSize > 0; iTempSlot++ )
-	        {	
-		    	bMerged |= AttemptToMergeWithSlotIfEmpty( stackSource, iTempSlot );
-	        }
-	    }
-	
-	    return bMerged;
-	}
-    
-    protected boolean AttemptToMergeWithSlot( ItemStack stackSource, int iTempSlot )
-    {
-        Slot tempDestSlot = (Slot)inventorySlots.get( iTempSlot );
-        ItemStack tempDestStack = tempDestSlot.getStack();
-
-        if ( tempDestStack != null && tempDestStack.itemID == stackSource.itemID && 
-        	( !stackSource.getHasSubtypes() || 
-    		stackSource.getItemDamage() == tempDestStack.getItemDamage() ) && 
-    		ItemStack.areItemStackTagsEqual( stackSource, tempDestStack ) )
-        {
-            int iDestStackSize = tempDestStack.stackSize + stackSource.stackSize;
-            int iMaxStackSize = stackSource.getMaxStackSize();
-            
-            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
-            {
-            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
-            }
-
-            if ( tempDestStack.stackSize < iMaxStackSize )
-            {
-                if ( iDestStackSize <= iMaxStackSize )
-                {
-                    stackSource.stackSize = 0;
-                    tempDestStack.stackSize = iDestStackSize;
-                }
-                else
-                {
-                    stackSource.stackSize -= iMaxStackSize - tempDestStack.stackSize;
-                    tempDestStack.stackSize = iMaxStackSize;
-                }
-                
-                tempDestSlot.onSlotChanged();
-                
-                return true;
-            }
-        }
-        
-        return false;
-    }
-    
-    protected boolean AttemptToMergeWithSlotIfEmpty( ItemStack stackSource, int iTempSlot )
-    {
-    	boolean bReturnValue = false;
-    	
-        Slot tempDestSlot = (Slot)inventorySlots.get(iTempSlot);
-        ItemStack tempDestStack = tempDestSlot.getStack();
-
-        if ( tempDestStack == null )
-        {
-            int iMaxStackSize = stackSource.getMaxStackSize();
-            
-            if ( tempDestSlot.getSlotStackLimit() < iMaxStackSize )
-            {
-            	iMaxStackSize = tempDestSlot.getSlotStackLimit();
-            }
-
-            if ( stackSource.stackSize <= iMaxStackSize )
-            {
-                tempDestSlot.putStack( stackSource.copy() );
-                stackSource.stackSize = 0;
-            }
-            else
-            {
-                tempDestSlot.putStack( stackSource.copy() );
-                stackSource.stackSize -= iMaxStackSize;
-                tempDestSlot.getStack().stackSize = iMaxStackSize;
-            }
-            
-            tempDestSlot.onSlotChanged();
-            
-            return true;
-        }
-        
-        return false;
-    }
-    // END FCMOD
 }
--- ContainerBrewingStand.java	Sat Aug 11 00:32:51 2018
+++ ContainerBrewingStand.java	Fri Apr 20 22:33:09 2018
@@ -105,10 +105,7 @@
                         return null;
                     }
                 }
-                // FCMOD: Change to give priority to player hotbar
-                //else if (!this.mergeItemStack(var5, 4, 40, false))
-                else if (!this.mergeItemStack(var5, 4, 40, true))
-            	// END FCMOD
+                else if (!this.mergeItemStack(var5, 4, 40, false))
                 {
                     return null;
                 }
--- ContainerEnchantment.java	Thu Sep  5 17:33:16 2013
+++ ContainerEnchantment.java	Fri Apr 20 22:33:09 2018
@@ -190,10 +190,6 @@
                     }
 
                     this.onCraftMatrixChanged(this.tableInventory);
-
-                    // FCMOD: Code added
-                    worldPointer.playSoundAtEntity( par1EntityPlayer, "random.levelup", 0.25F, worldPointer.rand.nextFloat() * 0.1F + 0.5F );
-                    // END FCMOD
                 }
             }
 
--- ContainerMerchant.java	Tue Oct  2 00:35:38 2018
+++ ContainerMerchant.java	Fri Apr 20 22:33:09 2018
@@ -1,7 +1,5 @@
 package net.minecraft.src;
 
-import java.util.Iterator;
-
 public class ContainerMerchant extends Container
 {
     /** Instance of Merchant. */
@@ -16,42 +14,22 @@
         this.theMerchant = par2IMerchant;
         this.theWorld = par3World;
         this.merchantInventory = new InventoryMerchant(par1InventoryPlayer.player, par2IMerchant);
-    	// FCMOD: Changed y offset of GUI
-    	/*
         this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 53));
         this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 53));
         this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 53));
-        */
-        this.addSlotToContainer(new Slot(this.merchantInventory, 0, 36, 119));
-        this.addSlotToContainer(new Slot(this.merchantInventory, 1, 62, 119));
-        this.addSlotToContainer(new SlotMerchantResult(par1InventoryPlayer.player, par2IMerchant, this.merchantInventory, 2, 120, 119));
-        // END FCMOD
         int var4;
 
         for (var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 9; ++var5)
             {
-            	// FCMOD: Changing y offset of GUI
-            	/*
                 this.addSlotToContainer(new Slot(par1InventoryPlayer, var5 + var4 * 9 + 9, 8 + var5 * 18, 84 + var4 * 18));
-                */
-                this.addSlotToContainer(new Slot(par1InventoryPlayer, 
-                	var5 + var4 * 9 + 9, 
-                	8 + var5 * 18, 
-                	157 + var4 * 18));
-            	// END FCMOD
             }
         }
 
         for (var4 = 0; var4 < 9; ++var4)
         {
-        	// FCMOD: Changing y offset of GUI
-        	/*
             this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 142));
-            */
-            this.addSlotToContainer(new Slot(par1InventoryPlayer, var4, 8 + var4 * 18, 215));
-        	// END FCMOD
         }
     }
 
@@ -63,10 +41,6 @@
     public void onCraftGuiOpened(ICrafting par1ICrafting)
     {
         super.onCraftGuiOpened(par1ICrafting);
-        
-        // FCMOD: Added (Note that uses different function name on client and server)
-        OnCrafterAdded( par1ICrafting );
-        // END FCMOD
     }
 
     /**
@@ -75,10 +49,6 @@
     public void detectAndSendChanges()
     {
         super.detectAndSendChanges();
-        
-        // FCMOD: Added        
-        DetectAndSendChangesToBTSMTradeVariables();
-        // END FCMOD
     }
 
     /**
@@ -115,15 +85,6 @@
 
             if (par2 == 2)
             {
-            	// FCMOD: Code added to abort trade if it's used up
-            	if ( merchantInventory.getCurrentRecipe().func_82784_g() )
-            	{
-                    var4.putStack((ItemStack)null);
-
-            		return null;
-            	}
-            	// END FCMOD
-            	
                 if (!this.mergeItemStack(var5, 3, 39, true))
                 {
                     return null;
@@ -135,32 +96,17 @@
             {
                 if (par2 >= 3 && par2 < 30)
                 {
-                	// FCMOD: Changed to allow shift-click transfer to merchant slots
-                	/*
                     if (!this.mergeItemStack(var5, 30, 39, false))
-                	*/
-                    if (!this.mergeItemStack(var5, 0, 2, false))
-                	// END FCMOD
                     {
                         return null;
                     }
                 }
-                // FCMOD: Changed to allow shift-click transfer to merchant slots
-                /*
                 else if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(var5, 3, 30, false))
-                */
-                else if (par2 >= 30 && par2 < 39 && !this.mergeItemStack(var5, 0, 2, false))
-            	// END FCMOD
                 {
                     return null;
                 }
             }
-        	// FCMOD: Changed to prioritize player hotbar
-        	/*
             else if (!this.mergeItemStack(var5, 3, 39, false))
-            */
-            else if (!this.mergeItemStack(var5, 3, 39, true))
-        	// END FCMOD
             {
                 return null;
             }
@@ -211,58 +157,4 @@
             }
         }
     }
-    // FCMOD: Added
-    public int m_iAssociatedVillagerTradeLevel = 0;
-    public int m_iAssociatedVillagerTradeXP = 0;
-    public int m_iAssociatedVillagerTradeMaxXP = 0;
-    
-    private void DetectAndSendChangesToBTSMTradeVariables()
-    {
-        int iCurrentTradeLevel = theMerchant.GetCurrentTradeLevel();
-        
-        if ( iCurrentTradeLevel != m_iAssociatedVillagerTradeLevel )
-        {
-        	SendProgressBarUpdateToAllCrafters( 0, iCurrentTradeLevel );
-        	
-        	m_iAssociatedVillagerTradeLevel = iCurrentTradeLevel;        	
-        }
-        
-        int iCurrentTradeXP = theMerchant.GetCurrentTradeXP();
-        
-        if ( iCurrentTradeXP != m_iAssociatedVillagerTradeXP )
-        {
-        	SendProgressBarUpdateToAllCrafters( 1, iCurrentTradeXP );
-        	
-        	m_iAssociatedVillagerTradeXP = iCurrentTradeXP;         	
-        }
-        
-        int iCurrentTradeMaxXP = theMerchant.GetCurrentTradeMaxXP();
-        
-        if ( iCurrentTradeMaxXP != m_iAssociatedVillagerTradeMaxXP )
-        {
-        	SendProgressBarUpdateToAllCrafters( 2, iCurrentTradeMaxXP );
-        	
-        	m_iAssociatedVillagerTradeMaxXP = iCurrentTradeMaxXP;         	
-        }
-    }
-    
-    public void SendProgressBarUpdateToAllCrafters( int iVariableIndex, int iValue )
-    {
-        Iterator iterator = crafters.iterator();
-
-        while( iterator.hasNext() )
-        {
-            ICrafting icrafting = (ICrafting)iterator.next();
-
-            icrafting.sendProgressBarUpdate( this, iVariableIndex, iValue );
-        }
-    }
-    
-    public void OnCrafterAdded( ICrafting crafter )
-    {
-        crafter.sendProgressBarUpdate( this, 0, m_iAssociatedVillagerTradeLevel );
-        crafter.sendProgressBarUpdate( this, 1, m_iAssociatedVillagerTradeXP );
-        crafter.sendProgressBarUpdate( this, 2, m_iAssociatedVillagerTradeMaxXP );
-    }    
-    // END FCMOD
 }
--- ContainerWorkbench.java	Thu Aug  9 14:37:37 2018
+++ ContainerWorkbench.java	Fri Apr 20 22:33:09 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 08/09/2018
-
 package net.minecraft.src;
 
 public class ContainerWorkbench extends Container
--- CraftingManager.java	Mon Aug 13 18:48:44 2018
+++ CraftingManager.java	Fri Apr 20 22:33:09 2018
@@ -1,6 +1,5 @@
 package net.minecraft.src;
 
-import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -33,9 +32,7 @@
         (new RecipesDyes()).addRecipes(this);
         this.recipes.add(new RecipesArmorDyes());
         this.recipes.add(new RecipesMapCloning());
-        // FCMOD: Removed
-        //this.recipes.add(new RecipesMapExtending());
-        // END FCMOD
+        this.recipes.add(new RecipesMapExtending());
         this.recipes.add(new RecipeFireworks());
         this.addRecipe(new ItemStack(Item.paper, 3), new Object[] {"###", '#', Item.reed});
         this.addShapelessRecipe(new ItemStack(Item.book, 1), new Object[] {Item.paper, Item.paper, Item.paper, Item.leather});
@@ -222,13 +219,6 @@
     }
 
     void addShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
-    // FCMOD: Added
-    {
-    	AddShapelessRecipe( par1ItemStack, par2ArrayOfObj );
-    }
-    
-    ShapelessRecipes AddShapelessRecipe(ItemStack par1ItemStack, Object ... par2ArrayOfObj)
-    // END FCMOD
     {
         ArrayList var3 = new ArrayList();
         Object[] var4 = par2ArrayOfObj;
@@ -256,19 +246,10 @@
                 var3.add(new ItemStack((Block)var7));
             }
         }
-        
-        // FCMOD: Changed        
-        //this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
-        ShapelessRecipes recipe = new ShapelessRecipes( par1ItemStack, var3 );
-        
-        recipes.add( recipe );
-        
-        return recipe;
-        // END FCMOD
+
+        this.recipes.add(new ShapelessRecipes(par1ItemStack, var3));
     }
 
-    // FCMOD: Removed and replaced
-    /*
     public ItemStack findMatchingRecipe(InventoryCrafting par1InventoryCrafting, World par2World)
     {
         int var3 = 0;
@@ -326,8 +307,6 @@
             return null;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * returns the List<> of all recipes
@@ -336,278 +315,4 @@
     {
         return this.recipes;
     }
-    
-    // FCMOD: Added
-    public ItemStack findMatchingRecipe( InventoryCrafting inventory, World world )
-    {
-    	IRecipe recipe = FindMatchingRecipe( inventory, world );
-    	ItemStack outputStack = null;
-    	
-    	if ( recipe != null )
-    	{
-    		outputStack = recipe.getCraftingResult( inventory );
-    	}
-    	
-    	return outputStack;
-    }
-    
-    public IRecipe FindMatchingRecipe( InventoryCrafting inventory, World world )
-    {
-        for ( int iTempIndex = 0; iTempIndex < this.recipes.size(); ++iTempIndex)
-        {
-            IRecipe tempRecipe = (IRecipe)this.recipes.get(iTempIndex);
-
-            if ( tempRecipe.matches( inventory, world ) )
-            {
-                return tempRecipe;
-            }
-        }
-
-        return null;
-    }
-    
-    public boolean RemoveRecipe( ItemStack itemStack, Object recipeArray[] )
-    {
-    	ShapedRecipes recipe = CreateRecipe( itemStack, recipeArray );
-    	
-    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
-    	
-    	if ( iMatchingIndex >= 0 )
-    	{
-    		recipes.remove( iMatchingIndex );
-    		
-    		return true;
-    	}
-    	
-    	return false;
-    }
-    
-    public boolean RemoveShapelessRecipe( ItemStack itemStack, Object recipeArray[] )
-    {
-    	ShapelessRecipes recipe = CreateShapelessRecipe( itemStack, recipeArray );
-    	
-    	int iMatchingIndex = GetMatchingRecipeIndex( recipe );
-    	
-    	if ( iMatchingIndex >= 0 )
-    	{
-    		recipes.remove( iMatchingIndex );
-    		
-    		return true;
-    	}
-    	
-    	return false;
-    }
-    
-    private int GetMatchingRecipeIndex( IRecipe recipe )
-    {
-    	int iMatchingRecipeIndex = -1;
-    	
-        for ( int iIndex = 0; iIndex < recipes.size(); iIndex++ )
-        {
-            IRecipe tempRecipe = (IRecipe)(recipes.get( iIndex ));
-
-            if ( tempRecipe.matches( recipe ) )
-            {
-                return iIndex;
-            }            
-        }
-
-    	return -1;
-    }
-    
-    private ShapedRecipes CreateRecipe( ItemStack par1ItemStack, Object par2ArrayOfObj[] )
-    {
-        String s = "";
-        int i = 0;
-        int j = 0;
-        int k = 0;
-
-        if (par2ArrayOfObj[i] instanceof String[])
-        {
-            String as[] = (String[])par2ArrayOfObj[i++];
-            String as1[] = as;
-            int l = as1.length;
-
-            for (int j1 = 0; j1 < l; j1++)
-            {
-                String s2 = as1[j1];
-                String s3 = s2;
-                k++;
-                j = s3.length();
-                s = (new StringBuilder()).append(s).append(s3).toString();
-            }
-        }
-        else
-        {
-            while (par2ArrayOfObj[i] instanceof String)
-            {
-                String s1 = (String)par2ArrayOfObj[i++];
-                k++;
-                j = s1.length();
-                s = (new StringBuilder()).append(s).append(s1).toString();
-            }
-        }
-
-        HashMap hashmap = new HashMap();
-
-        for (; i < par2ArrayOfObj.length; i += 2)
-        {
-            Character character = (Character)par2ArrayOfObj[i];
-            ItemStack itemstack = null;
-
-            if (par2ArrayOfObj[i + 1] instanceof Item)
-            {
-                itemstack = new ItemStack((Item)par2ArrayOfObj[i + 1]);
-            }
-            else if (par2ArrayOfObj[i + 1] instanceof Block)
-            {
-                itemstack = new ItemStack((Block)par2ArrayOfObj[i + 1], 1, FCUtilsInventory.m_iIgnoreMetadata);
-            }
-            else if (par2ArrayOfObj[i + 1] instanceof ItemStack)
-            {
-                itemstack = (ItemStack)par2ArrayOfObj[i + 1];
-            }
-
-            hashmap.put(character, itemstack);
-        }
-
-        ItemStack aitemstack[] = new ItemStack[j * k];
-
-        for (int i1 = 0; i1 < j * k; i1++)
-        {
-            char c = s.charAt(i1);
-
-            if (hashmap.containsKey(Character.valueOf(c)))
-            {
-                aitemstack[i1] = ((ItemStack)hashmap.get(Character.valueOf(c))).copy();
-            }
-            else
-            {
-                aitemstack[i1] = null;
-            }
-        }
-
-        return new ShapedRecipes(j, k, aitemstack, par1ItemStack );
-    }
-    
-    private ShapelessRecipes CreateShapelessRecipe(ItemStack par1ItemStack, Object par2ArrayOfObj[])
-    {
-        ArrayList arraylist = new ArrayList();
-        Object aobj[] = par2ArrayOfObj;
-        int i = aobj.length;
-
-        for (int j = 0; j < i; j++)
-        {
-            Object obj = aobj[j];
-
-            if (obj instanceof ItemStack)
-            {
-                arraylist.add(((ItemStack)obj).copy());
-                continue;
-            }
-
-            if (obj instanceof Item)
-            {
-                arraylist.add(new ItemStack((Item)obj));
-                continue;
-            }
-
-            if (obj instanceof Block)
-            {
-                arraylist.add(new ItemStack((Block)obj));
-            }
-            else
-            {
-                throw new RuntimeException("Invalid shapeless recipy!");
-            }
-        }
-
-        return new ShapelessRecipes( par1ItemStack, arraylist );
-    }
-    
-    ShapedRecipes AddShapedRecipeWithCustomClass( Class<? extends ShapedRecipes> recipeClass, ItemStack par1ItemStack, Object ... par2ArrayOfObj )
-    {
-        String var3 = "";
-        int var4 = 0;
-        int var5 = 0;
-        int var6 = 0;
-
-        if (par2ArrayOfObj[var4] instanceof String[])
-        {
-            String[] var7 = (String[])((String[])par2ArrayOfObj[var4++]);
-
-            for (int var8 = 0; var8 < var7.length; ++var8)
-            {
-                String var9 = var7[var8];
-                ++var6;
-                var5 = var9.length();
-                var3 = var3 + var9;
-            }
-        }
-        else
-        {
-            while (par2ArrayOfObj[var4] instanceof String)
-            {
-                String var11 = (String)par2ArrayOfObj[var4++];
-                ++var6;
-                var5 = var11.length();
-                var3 = var3 + var11;
-            }
-        }
-
-        HashMap var12;
-
-        for (var12 = new HashMap(); var4 < par2ArrayOfObj.length; var4 += 2)
-        {
-            Character var13 = (Character)par2ArrayOfObj[var4];
-            ItemStack var14 = null;
-
-            if (par2ArrayOfObj[var4 + 1] instanceof Item)
-            {
-                var14 = new ItemStack((Item)par2ArrayOfObj[var4 + 1]);
-            }
-            else if (par2ArrayOfObj[var4 + 1] instanceof Block)
-            {
-                var14 = new ItemStack((Block)par2ArrayOfObj[var4 + 1], 1, 32767);
-            }
-            else if (par2ArrayOfObj[var4 + 1] instanceof ItemStack)
-            {
-                var14 = (ItemStack)par2ArrayOfObj[var4 + 1];
-            }
-
-            var12.put(var13, var14);
-        }
-
-        ItemStack[] var15 = new ItemStack[var5 * var6];
-
-        for (int var16 = 0; var16 < var5 * var6; ++var16)
-        {
-            char var10 = var3.charAt(var16);
-
-            if (var12.containsKey(Character.valueOf(var10)))
-            {
-                var15[var16] = ((ItemStack)var12.get(Character.valueOf(var10))).copy();
-            }
-            else
-            {
-                var15[var16] = null;
-            }
-        }
-
-        try
-        {
-	        Constructor recipeConstructor = recipeClass.getDeclaredConstructor( new Class[] { int.class, int.class, ItemStack[].class, ItemStack.class } );
-	        
-	        ShapedRecipes recipe = (ShapedRecipes)( recipeConstructor.newInstance( var5, var6, var15, par1ItemStack) );
-	        
-	        recipes.add( recipe );
-	        
-	        return recipe;
-        }
-        catch( Exception e ) 
-        {
-	        throw new RuntimeException( "Haha...noob" );
-        }            
-    }
-    // END FCMOD   
 }
--- DispenserBehaviorBoat.java	Fri Jun 14 12:48:13 2013
+++ DispenserBehaviorBoat.java	Fri Apr 20 22:33:10 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-	// FCMOD: Code removed to prevent usage
-	/*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -41,18 +39,12 @@
         par2ItemStack.splitStack(1);
         return par2ItemStack;
     }
-    */
-    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
-    // FCMOD: Code removed
-    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         par1IBlockSource.getWorld().playAuxSFX(1000, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
     }
-    */
-    // END FCMOD
 }
--- DispenserBehaviorDye.java	Fri Jun 14 12:48:19 2013
+++ DispenserBehaviorDye.java	Fri Apr 20 22:33:10 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-	// FCMOD: Code removed to prevent usage
-	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         if (par2ItemStack.getItemDamage() == 15)
@@ -38,14 +36,10 @@
             return super.dispenseStack(par1IBlockSource, par2ItemStack);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
-	// FCMOD: Code removed
-	/*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96461_b)
@@ -57,6 +51,4 @@
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
-    */
-    // END FCMOD
 }
--- DispenserBehaviorEmptyBucket.java	Fri Jun 14 12:48:23 2013
+++ DispenserBehaviorEmptyBucket.java	Fri Apr 20 22:33:10 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-    // FCMOD: Code removed to prevent usage
-    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -48,6 +46,4 @@
 
         return par2ItemStack;
     }
-    */
-    // END FCMOD
 }
--- DispenserBehaviorFilledBucket.java	Fri Jun 14 12:48:26 2013
+++ DispenserBehaviorFilledBucket.java	Fri Apr 20 22:33:10 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-    // FCMOD: Code removed to prevent usage
-    /*
     public ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         ItemBucket var3 = (ItemBucket)par2ItemStack.getItem();
@@ -28,6 +26,4 @@
             return this.defaultDispenserItemBehavior.dispense(par1IBlockSource, par2ItemStack);
         }
     }
-    */
-    // END FCMOD
 }
--- DispenserBehaviorFire.java	Fri Jun 14 12:48:37 2013
+++ DispenserBehaviorFire.java	Fri Apr 20 22:33:10 2018
@@ -7,8 +7,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-    // FCMOD: Code removed to prevent usage
-    /*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -38,14 +36,10 @@
 
         return par2ItemStack;
     }
-    */
-    // END FCMOD
 
     /**
      * Play the dispense sound from the specified block.
      */
-    // FCMOD: Code removed
-    /*
     protected void playDispenseSound(IBlockSource par1IBlockSource)
     {
         if (this.field_96466_b)
@@ -57,6 +51,4 @@
             par1IBlockSource.getWorld().playAuxSFX(1001, par1IBlockSource.getXInt(), par1IBlockSource.getYInt(), par1IBlockSource.getZInt(), 0);
         }
     }
-    */
-    // END FCMOD
 }
--- DispenserBehaviorTNT.java	Fri Jun 14 12:48:40 2013
+++ DispenserBehaviorTNT.java	Fri Apr 20 22:33:10 2018
@@ -5,8 +5,6 @@
     /**
      * Dispense the specified stack, play the dispense sound and spawn particles.
      */
-	// FCMOD: Code removed to prevent usage
-	/*
     protected ItemStack dispenseStack(IBlockSource par1IBlockSource, ItemStack par2ItemStack)
     {
         EnumFacing var3 = BlockDispenser.getFacing(par1IBlockSource.getBlockMetadata());
@@ -19,6 +17,4 @@
         --par2ItemStack.stackSize;
         return par2ItemStack;
     }
-    */
-    // END FCMOD
 }
--- Enchantment.java	Mon Mar 11 13:45:58 2019
+++ Enchantment.java	Fri Apr 20 22:33:10 2018
@@ -198,10 +198,7 @@
 
     public boolean func_92089_a(ItemStack par1ItemStack)
     {
-    	// FCMOD: Changed
-        //return this.type.canEnchantItem(par1ItemStack.getItem());
-        return par1ItemStack.getItem().IsEnchantmentApplicable( this );
-    	// END FCMOD
+        return this.type.canEnchantItem(par1ItemStack.getItem());
     }
 
     static
@@ -222,24 +219,4 @@
 
         field_92090_c = (Enchantment[])var0.toArray(new Enchantment[0]);
     }
-    
-    // FCMOD: Added New
-    private boolean m_bCanBeAppliedByVanillaEnchanter = true;
-    
-    static
-    {
-        // remove the more powerful enchants from the vanilla enchanter
-    	
-        protection.m_bCanBeAppliedByVanillaEnchanter = false;
-        silkTouch.m_bCanBeAppliedByVanillaEnchanter = false;
-        fortune.m_bCanBeAppliedByVanillaEnchanter = false;
-        sharpness.m_bCanBeAppliedByVanillaEnchanter = false;
-        featherFalling.m_bCanBeAppliedByVanillaEnchanter = false;
-    }
-    
-    public boolean CanBeAppliedByVanillaEnchanter()
-    {
-    	return m_bCanBeAppliedByVanillaEnchanter;
-    }
-    // END FCMOD
 }
--- EnchantmentHelper.java	Fri Mar  8 13:14:29 2019
+++ EnchantmentHelper.java	Fri Apr 20 22:33:10 2018
@@ -254,24 +254,7 @@
      */
     public static int getFortuneModifier(EntityLiving par0EntityLiving)
     {
-    	// FCMOD: Code change
-    	/*
         return getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
-        */
-    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.fortune.effectId, par0EntityLiving.getHeldItem());
-    	
-    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionFortune ) )
-    	{
-        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionFortune ).getAmplifier() + 1;
-        	
-        	if ( iPotionLevel > iEnchantmentLevel )
-        	{
-        		iEnchantmentLevel = iPotionLevel;
-        	}        	
-    	}
-    	
-    	return iEnchantmentLevel;
-    	// END FCMOD
     }
 
     /**
@@ -279,24 +262,7 @@
      */
     public static int getLootingModifier(EntityLiving par0EntityLiving)
     {
-    	// FCMOD: Code change
-    	/*
         return getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
-        */
-    	int iEnchantmentLevel = getEnchantmentLevel(Enchantment.looting.effectId, par0EntityLiving.getHeldItem());
-    	
-    	if ( par0EntityLiving.isPotionActive(FCBetterThanWolves.potionLooting ) )
-    	{
-        	int iPotionLevel = par0EntityLiving.getActivePotionEffect( FCBetterThanWolves.potionLooting ).getAmplifier() + 1;
-        	
-        	if ( iPotionLevel > iEnchantmentLevel )
-        	{
-        		iEnchantmentLevel = iPotionLevel;
-        	}        	
-    	}
-    	
-    	return iEnchantmentLevel;
-    	// END FCMOD
     }
 
     /**
@@ -334,8 +300,6 @@
      * Returns the enchantability of itemstack, it's uses a singular formula for each index (2nd parameter: 0, 1 and 2),
      * cutting to the max enchantability power of the table (3rd parameter)
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public static int calcItemStackEnchantability(Random par0Random, int par1, int par2, ItemStack par3ItemStack)
     {
         Item var4 = par3ItemStack.getItem();
@@ -356,8 +320,6 @@
             return par1 == 0 ? Math.max(var6 / 3, 1) : (par1 == 1 ? var6 * 2 / 3 + 1 : Math.max(var6, par2 * 2));
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Adds a random enchantment to the specified item. Args: random, itemStack, enchantabilityLevel
@@ -494,18 +456,8 @@
         {
             Enchantment var8 = var5[var7];
 
-        	// FCMOD: Changed
-            //if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
-            if ( var8 != null && (var2.IsEnchantmentApplicable( var8 ) || var4))
-        	// END FCMOD
+            if (var8 != null && (var8.type.canEnchantItem(var2) || var4))
             {
-            	// FCMOD: Added to prevent certain enchants from vanilla enchanter
-            	if ( !var8.CanBeAppliedByVanillaEnchanter() )
-            	{
-            		continue;
-            	}
-            	// END FCMOD
-            	
                 for (int var9 = var8.getMinLevel(); var9 <= var8.getMaxLevel(); ++var9)
                 {
                     if (par0 >= var8.getMinEnchantability(var9) && par0 <= var8.getMaxEnchantability(var9))
@@ -523,56 +475,4 @@
 
         return var3;
     }
-    
-    // FCMOD: Code added
-    public static int calcItemStackEnchantability( Random rand, int iTableSlotNum, int iNumBookShelves, ItemStack stack )
-    {
-    	// Replace vanilla code to double amount of bookshelves required, cap enchant level at 15, and make enchant with no shelves be level 1
-    	
-        Item item = stack.getItem();
-        int iItemEnchantability = item.getItemEnchantability();
-
-        if (iItemEnchantability <= 0)
-        {
-            return 0;
-        }
-        else
-        {
-            int iEnchantmentLevel = 1;
-            
-            if ( iTableSlotNum != 0 )
-            {
-                int iMaxEnchantmentLevel = iNumBookShelves >> 1;
-                    
-                if ( iMaxEnchantmentLevel <= 0 )
-                {
-                	iMaxEnchantmentLevel = 1;
-                }
-                else if ( iMaxEnchantmentLevel > 15 )
-                {
-                	iMaxEnchantmentLevel = 15;
-                }
-                	
-            	if ( iTableSlotNum == 1 )
-            	{
-            		if ( iMaxEnchantmentLevel > 1 )
-            		{
-                		iEnchantmentLevel = 2;
-                		
-                		if ( iMaxEnchantmentLevel > 3 )
-                		{
-                			iEnchantmentLevel += rand.nextInt( iMaxEnchantmentLevel - 2 );
-                		}
-            		}
-            	}
-            	else
-            	{
-            		iEnchantmentLevel = iMaxEnchantmentLevel;
-            	}
-            }
-            
-            return iEnchantmentLevel;
-        }
-    }
-    // END FCMOD
 }
--- Entity.java	Thu Dec 24 17:42:50 2020
+++ Entity.java	Fri Apr 20 22:33:10 2018
@@ -1,6 +1,5 @@
 package net.minecraft.src;
 
-import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
@@ -118,9 +117,6 @@
      * The entity's Z coordinate at the previous tick, used to calculate position during rendering routines
      */
     public double lastTickPosZ;
-    /**
-     * FCNOTE: TERRIBLE NAMING.  This is actually the position offset due to player sneaking/crouching
-     */
     public float ySize;
 
     /**
@@ -269,9 +265,6 @@
      */
     protected void setSize(float par1, float par2)
     {
-    	// FCMOD: Code change to duplicate 1.6 fix for animals suffocating and escaping fences bug
-    	// I do not believe this is actually helping anything due to the incremental nature of the 
-    	// move plus I am now ensuring sufficient space on animal grow elsewhere in the code.
         if (par1 != this.width || par2 != this.height)
         {
             this.width = par1;
@@ -282,27 +275,6 @@
         }
 
         float var3 = par1 % 2.0F;
-    	/*
-        float var3;
-
-        if (par1 != this.width || par2 != this.height)
-        {
-            var3 = this.width;
-            this.width = par1;
-            this.height = par2;
-            this.boundingBox.maxX = this.boundingBox.minX + (double)this.width;
-            this.boundingBox.maxZ = this.boundingBox.minZ + (double)this.width;
-            this.boundingBox.maxY = this.boundingBox.minY + (double)this.height;
-
-            if (this.width > var3 && !this.firstUpdate && !this.worldObj.isRemote)
-            {
-                this.moveEntity((double)(var3 - this.width), 0.0D, (double)(var3 - this.width));
-            }
-        }
-
-        var3 = par1 % 2.0F;
-        */    	
-        // END FCMOD
 
         if ((double)var3 < 0.375D)
         {
@@ -557,8 +529,6 @@
     /**
      * Tries to moves the entity by the passed in displacement. Args: x, y, z
      */
-    // FCMOD: Removed and replaced
-    /*
     public void moveEntity(double par1, double par3, double par5)
     {
         if (this.noClip)
@@ -902,8 +872,6 @@
             this.worldObj.theProfiler.endSection();
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Checks for block collisions, and calls the associated onBlockCollided method for the collided block.
@@ -942,28 +910,13 @@
      */
     protected void playStepSound(int par1, int par2, int par3, int par4)
     {
-    	// FCMOD: Changed
-    	/*
         StepSound var5 = Block.blocksList[par4].stepSound;
-        
+
         if (this.worldObj.getBlockId(par1, par2 + 1, par3) == Block.snow.blockID)
         {
             var5 = Block.snow.stepSound;
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
         }
-        */
-        StepSound var5 = Block.blocksList[par4].GetStepSound( worldObj, par1, par2, par3 );
-        
-        int iBlockAboveID = worldObj.getBlockId( par1, par2 + 1, par3 );
-        Block blockAbove = Block.blocksList[iBlockAboveID];
-        
-        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
-        {
-            var5 = blockAbove.stepSound;
-            
-            playSound( var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch() );
-        }
-    	// END FCMOD
         else if (!Block.blocksList[par4].blockMaterial.isLiquid())
         {
             this.playSound(var5.getStepSound(), var5.getVolume() * 0.15F, var5.getPitch());
@@ -1045,10 +998,7 @@
      */
     public boolean isWet()
     {
-    	// FCMOD: Changed
-        //return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
-        return inWater || IsBeingRainedOn();
-        // END FCMOD
+        return this.inWater || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) || this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + (double)this.height), MathHelper.floor_double(this.posZ));
     }
 
     /**
@@ -1423,12 +1373,6 @@
         try
         {
             par1NBTTagCompound.setTag("Pos", this.newDoubleNBTList(new double[] {this.posX, this.posY + (double)this.ySize, this.posZ}));
-        	// FCMOD: Added to fix collision errors on load 
-            par1NBTTagCompound.setTag( "fcMin", newDoubleNBTList( 
-            	new double[] { boundingBox.minX, boundingBox.minY, boundingBox.minZ } ) );
-            par1NBTTagCompound.setTag( "fcMax", newDoubleNBTList(
-            	new double[] { boundingBox.maxX, boundingBox.maxY, boundingBox.maxZ } ) );
-            // END FCMOD
             par1NBTTagCompound.setTag("Motion", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
             par1NBTTagCompound.setTag("Rotation", this.newFloatNBTList(new float[] {this.rotationYaw, this.rotationPitch}));
             par1NBTTagCompound.setFloat("FallDistance", this.fallDistance);
@@ -1464,8 +1408,6 @@
     /**
      * Reads the entity from NBT (calls an abstract helper method to read specialized data)
      */
-    // FCMOD: Removed and replaced
-    /*
     public void readFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         try
@@ -1522,8 +1464,6 @@
             throw new ReportedException(var3);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns the string that identifies this Entity's class
@@ -1790,7 +1730,6 @@
 
     /**
      * Called when a player unounts an entity.
-     * FCNOTE: Call mountEntity( null ) for regular entities.  This searches area for solid ground, and is intended for the player.
      */
     public void unmountEntity(Entity par1Entity)
     {
@@ -2230,12 +2169,7 @@
 
     public float func_82146_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, Block par6Block)
     {
-    	// FCMOD: Code change
-    	/*
         return par6Block.getExplosionResistance(this);
-        */
-        return par6Block.getExplosionResistance(this, par2World, par3, par4, par5);
-    	// END FCMOD
     }
 
     public boolean func_96091_a(Explosion par1Explosion, World par2World, int par3, int par4, int par5, int par6, float par7)
@@ -2283,709 +2217,4 @@
     {
         return this.getEntityName();
     }
-
-    // FCMOD: Added New
-    public boolean IsAffectedByMovementModifiers()
-    {
-    	return true;
-    }
-    
-    public void NotifyOfWolfHowl( Entity sourceEntity )
-    {
-    }
-    
-    protected boolean ShouldSetPositionOnLoad()
-    {
-    	return true;
-    }
-    
-    public boolean CanCollideWithEntity( Entity entity )
-    {
-    	return true;
-    }
-    
-    public boolean IsItemEntity()
-    {
-    	return false;
-    }
-    
-    public boolean CanEntityTriggerTripwire()
-    {
-    	return true;
-    }
-    
-    public AxisAlignedBB GetVisualBoundingBox()
-    {
-    	return boundingBox;    	
-    }
-    
-    public boolean IsSecondaryTargetForSquid()
-    {
-    	return false;
-    }
-    
-    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
-    {
-    	return isEntityAlive() && riddenByEntity == null && ridingEntity == null && 
-    		IsSecondaryTargetForSquid();
-    }
-    
-    public boolean IsValidOngoingAttackTargetForSquid()
-    {
-    	return IsSecondaryTargetForSquid() && isEntityAlive();
-    }
-    
-    public void OnFlungBySquidTentacle( FCEntitySquid squid )
-    {
-    }
-    
-    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
-    {
-    }    
-    
-    public boolean HasHeadCrabbedSquid()
-    {
-    	return riddenByEntity != null && riddenByEntity instanceof FCEntitySquid;
-    }
-    
-    public Entity GetHeadCrabSharedAttackTarget()
-    {
-    	return null;
-    }
-    
-	public boolean IsImmuneToHeadCrabDamage()
-	{
-		return false;
-	}
-	
-    public void OnKickedByCow( FCEntityCow cow )
-	{
-    	FlingAwayFromEntity( cow, GetCowKickMovementMultiplier() );    	
-    }
-    
-    protected double GetCowKickMovementMultiplier()
-    {
-    	return 1D;
-    }
-    
-    public void FlingAwayFromEntity( Entity repulsingEntity, double dForceMultiplier )
-	{
-        if ( ridingEntity != null )
-        {
-        	mountEntity( null );
-        }
-        
-        double dVelocityX = motionX;
-        double dVelocityZ = motionZ;
-        
-		double dDeltaX = posX - repulsingEntity.posX; 
-		double dDeltaZ = posZ - repulsingEntity.posZ;
-		
-		double dFlatDistToTargetSq = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
-
-		if ( dFlatDistToTargetSq > 0.1D )
-		{
-			double dFlatDistToTarget = MathHelper.sqrt_double( dFlatDistToTargetSq );
-			
-			dVelocityX += ( dDeltaX / dFlatDistToTarget ) * 0.5D * dForceMultiplier;
-			dVelocityZ += ( dDeltaZ / dFlatDistToTarget ) * 0.5F * dForceMultiplier;
-		}
-		
-		isAirBorne = true;
-
-        double dVelocityY = motionY + ( 0.25D * dForceMultiplier );
-        
-        dVelocityX *= ( rand.nextDouble() * 0.2D ) + 0.9;
-        dVelocityZ *= ( rand.nextDouble() * 0.2D ) + 0.9;
-        
-		motionX = FCUtilsMath.ClampDouble( dVelocityX, -1D, 1D );
-		motionY = FCUtilsMath.ClampDoubleTop( dVelocityY, 0.75D );
-		motionZ = FCUtilsMath.ClampDouble( dVelocityZ, -1D, 1D );
-    }
-    
-    public boolean DoesEntityApplyToSpawnCap()
-    {
-    	// by default entities do not apply to the spawn cap as this avoids a lot of unnecessary instanceof checks in World.CountEntitiesThatApplyToSpawnCap()
-    	// Note that this behavior is overriden in EntityLiving, which is where it really matters.
-    	
-    	return false;
-    }
-    
-	public void OutOfUpdateRangeUpdate()
-	{
-	}
-	
-	public boolean AppliesConstantForceWhenRidingBoat()
-	{
-		return false;
-	}
-	
-	public double MovementModifierWhenRidingBoat()
-	{
-		return 1.0D;
-	}
-	
-	/**
-	 * Returns true if this function has handled the possession transfer from the dead entity.  Called on server only.
-	 */
-	public boolean OnPossesedRidingEntityDeath()
-	{
-		return false;
-	}
-	
-    public boolean IsBeingRainedOn()
-    {
-        int i = MathHelper.floor_double( posX );
-        int j = MathHelper.floor_double( boundingBox.maxY );
-        int k = MathHelper.floor_double( posZ );
-    	
-    	return worldObj.IsRainingAtPos( i, j, k );
-    }    
-    
-    public boolean DoesEntityApplyToSquidPossessionCap()
-    {
-    	return false;
-    }
-    
-    public boolean IsValidZombieSecondaryTarget( EntityZombie zombie )
-    {
-    	return false;
-    }
-
-    public boolean AttractsLightning()
-    {
-    	return false;
-    }
-    
-    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
-    {
-        dealFireDamage( 7 );
-        
-        fire++;
-
-        if ( fire == 0 )
-        {
-            setFire( 8 );
-        }
-        
-        if ( !isEntityInvulnerable() )
-        {
-        	FlingAwayFromEntity( boltEntity, 2D );
-        }
-    }
-    
-    public void moveEntity( double dMoveX, double dMoveY, double dMoveZ )
-    {
-    	// replacement for vanilla function that cleans up the code for readability while retaining
-    	// same functionality.  Modifications to vanilla functionality listed as FCMOD
-    	
-    	// Note: I've elminated all references to field_70135_K as this seems to be a lingering
-    	// debug value that serves no actual purpose
-    	
-        if ( noClip )
-        {
-            boundingBox.offset( dMoveX, dMoveY, dMoveZ );
-            
-            posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
-            posY = boundingBox.minY + (double)yOffset - (double)ySize;
-            posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
-            
-            return;
-        }
-        
-        worldObj.theProfiler.startSection("move");
-        ySize *= 0.4F; // This is actually the position offset due to player sneaking/crouching 
-        
-        double dOldPosX = posX;
-        double dOldPosY = posY;
-        double dOldPosZ = posZ;
-
-        AxisAlignedBB oldBoundingBox = boundingBox.copy();
-        
-        if ( isInWeb )
-        {
-            isInWeb = false;
-            
-            dMoveX *= 0.25D;
-            dMoveY *= 0.05000000074505806D;
-            dMoveZ *= 0.25D;
-            
-            motionX = 0.0D;
-            motionY = 0.0D;
-            motionZ = 0.0D;
-        }
-
-        boolean bIsSneakingPlayer = onGround && isSneaking() && this instanceof EntityPlayer;
-
-        if ( bIsSneakingPlayer )
-        {
-            double dStepSize = 0.05D;
-
-            while ( dMoveX != 0D && worldObj.getCollidingBoundingBoxes( this, 
-        		boundingBox.getOffsetBoundingBox( dMoveX, -1D, 0D ) ).isEmpty() )
-            {
-                if (dMoveX < dStepSize && dMoveX >= -dStepSize)
-                {
-                    dMoveX = 0D;
-                }
-                else if ( dMoveX > 0D )
-                {
-                    dMoveX -= dStepSize;
-                }
-                else
-                {
-                    dMoveX += dStepSize;
-                }
-            }
-
-            while ( dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
-            	boundingBox.getOffsetBoundingBox( 0D, -1D, dMoveZ ) ).isEmpty() )
-            {
-                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
-                {
-                    dMoveZ = 0D;
-                }
-                else if ( dMoveZ > 0D )
-                {
-                    dMoveZ -= dStepSize;
-                }
-                else
-                {
-                    dMoveZ += dStepSize;
-                }
-            }
-
-            // FCNOTE: the dMoveX != 0D && dMoveZ != 0D below looks a bit weird,
-            // but it's valid as single axis collisions have already been checked above
-            while ( dMoveX != 0D && dMoveZ != 0D && worldObj.getCollidingBoundingBoxes( this, 
-            	boundingBox.getOffsetBoundingBox( dMoveX, -1D, dMoveZ ) ).isEmpty() )
-            {
-                if ( dMoveX < dStepSize && dMoveX >= -dStepSize )
-                {
-                    dMoveX = 0D;
-                }
-                else if ( dMoveX > 0D )
-                {
-                    dMoveX -= dStepSize;
-                }
-                else
-                {
-                    dMoveX += dStepSize;
-                }
-
-                if ( dMoveZ < dStepSize && dMoveZ >= -dStepSize )
-                {
-                    dMoveZ = 0D;
-                }
-                else if ( dMoveZ > 0D )
-                {
-                    dMoveZ -= dStepSize;
-                }
-                else
-                {
-                    dMoveZ += dStepSize;
-                }
-            }
-        }
-
-        double dUnboundedMoveX = dMoveX;
-        double dUnboundedMoveY = dMoveY;
-        double dUnboundedMoveZ = dMoveZ;
-        
-        // addCoord() below returns a new box expanded in the direction of the point
-        
-        // FCMOD: Changed the following bit to calculate one collision list that takes steps
-        // into account right from the start, instead of doing this whole thing a second time 
-        // when steps are checked for later
-        //List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
-        	//boundingBox.addCoord( dMoveX, dMoveY, dMoveZ ) );
-        AxisAlignedBB moveRangeBoundingBox = boundingBox.addCoord( dMoveX, dMoveY, dMoveZ );
-        
-        if ( stepHeight > dMoveY )
-        {
-        	moveRangeBoundingBox.maxY = boundingBox.maxY + stepHeight;
-        }
-        
-        List<AxisAlignedBB> moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
-        	moveRangeBoundingBox );
-        // END FCMOD
-
-        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-        {
-        	// Keep reducing the magnitude of the y movement until it is within the vertical gap
-        	// between the original position and any potentially colliding blocks
-        	
-            dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset( 
-            	boundingBox, dMoveY );
-        }
-
-        boundingBox.offset( 0D, dMoveY, 0D );
-
-        boolean bVerticallySupported = onGround || 
-        	( dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0D );
-        
-        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-        {        	
-            dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset( 
-            	boundingBox, dMoveX );
-        }
-
-        boundingBox.offset( dMoveX, 0D, 0D );
-
-        for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-        {
-            dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
-            	boundingBox, dMoveZ );
-        }
-
-        boundingBox.offset( 0D, 0D, dMoveZ );
-        
-        if ( stepHeight > 0F && bVerticallySupported && 
-        	( bIsSneakingPlayer || ySize < 0.05F ) && 
-        	( dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ ) )
-        {
-            double dBoundedMoveX = dMoveX;
-            double dBoundedMoveY = dMoveY;
-            double dBoundedMoveZ = dMoveZ;
-            
-            dMoveX = dUnboundedMoveX;
-            dMoveY = stepHeight;
-            dMoveZ = dUnboundedMoveZ;
-            
-            AxisAlignedBB dBoundedMoveBox = boundingBox.copy();
-            
-            boundingBox.setBB( oldBoundingBox );
-            
-            // FCMOD: Removed to use precomputed collision list
-            //moveRangeCollisionList = worldObj.getCollidingBoundingBoxes( this, 
-            	//boundingBox.addCoord( dUnboundedMoveX, dMoveY, dUnboundedMoveZ ) );
-            // END FCMOD
-
-            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-            {
-                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
-                	boundingBox, dMoveY );
-            }
-
-            boundingBox.offset( 0D, dMoveY, 0D );
-
-            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-            {
-                dMoveX = moveRangeCollisionList.get( iTempIndex ).calculateXOffset(
-                	boundingBox, dMoveX );
-            }
-
-            boundingBox.offset( dMoveX, 0D, 0D );
-
-            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-            {
-                dMoveZ = moveRangeCollisionList.get( iTempIndex ).calculateZOffset(
-                	boundingBox, dMoveZ );
-            }
-
-            boundingBox.offset( 0D, 0D, dMoveZ );
-
-            // the following portion drops the entity downward after stepping up, to find
-            // the surface it should be resting on
-
-            if ( dMoveY > 0D )
-            {
-	            // FCMOD: Changed so that the entity doesn't end up descending further than it 
-            	// climbed fixing a bug with mobs falling through slabs [MC-72868]
-	            //dMoveY = -stepHeight;
-	            dMoveY = -dMoveY;
-	
-	            for ( int iTempIndex = 0; iTempIndex < moveRangeCollisionList.size(); iTempIndex++ )
-	            {
-	                dMoveY = moveRangeCollisionList.get( iTempIndex ).calculateYOffset(
-	                	boundingBox, dMoveY );
-	            }
-
-	            boundingBox.offset( 0D, dMoveY, 0D );
-            }
-
-            if ( dBoundedMoveX * dBoundedMoveX + dBoundedMoveZ * dBoundedMoveZ >= 
-            	dMoveX * dMoveX + dMoveZ * dMoveZ )
-            {
-                dMoveX = dBoundedMoveX;
-                dMoveY = dBoundedMoveY;
-                dMoveZ = dBoundedMoveZ;
-                
-                boundingBox.setBB(dBoundedMoveBox);
-            }
-        }
-
-        worldObj.theProfiler.endSection();
-        
-        worldObj.theProfiler.startSection("rest");
-        
-        posX = ( boundingBox.minX + boundingBox.maxX ) / 2D;
-        posY = boundingBox.minY + yOffset - ySize;
-        posZ = ( boundingBox.minZ + boundingBox.maxZ ) / 2D;
-        
-        isCollidedHorizontally = dUnboundedMoveX != dMoveX || dUnboundedMoveZ != dMoveZ;
-        isCollidedVertically = dUnboundedMoveY != dMoveY;        
-        onGround = dUnboundedMoveY != dMoveY && dUnboundedMoveY < 0.0D;
-        
-        isCollided = isCollidedHorizontally || isCollidedVertically;
-        
-        updateFallState( dMoveY, onGround );
-
-        if ( dUnboundedMoveX != dMoveX )
-        {
-            motionX = 0D;
-        }
-
-        if ( dUnboundedMoveY != dMoveY )
-        {
-            motionY = 0D;
-        }
-
-        if ( dUnboundedMoveZ != dMoveZ )
-        {
-            motionZ = 0D;
-        }
-
-        double dDeltaX = posX - dOldPosX;
-        double dDeltaY = posY - dOldPosY;
-        double dDeltaZ = posZ - dOldPosZ;
-
-        if ( canTriggerWalking() && !bIsSneakingPlayer && ridingEntity == null )
-        {
-            int iGroundI = MathHelper.floor_double( posX );
-            // FCMOD: Changed to refine step sounds
-            //int iGroundJ = MathHelper.floor_double( posY - 0.20000000298023224D - yOffset );
-            int iGroundJ = MathHelper.floor_double( posY - 0.03D - yOffset );
-            // END FCMOD
-            int iGroundK = MathHelper.floor_double( posZ );
-            
-            int iGroundBlockID = worldObj.getBlockId(iGroundI, iGroundJ, iGroundK);
-            
-            // FCMOD: Added
-            int iTempY = iGroundJ;
-            // END FCMOD
-
-            if ( iGroundBlockID == 0 )
-            {
-                int iGroundRenderType = worldObj.blockGetRenderType( iGroundI, iGroundJ - 1, 
-                	iGroundK );
-
-                if ( iGroundRenderType == 11 || iGroundRenderType == 32 || 
-                	iGroundRenderType == 21 )
-                {
-                    iGroundBlockID = worldObj.getBlockId( iGroundI, iGroundJ - 1, iGroundK );
-                    // FCMOD: Added
-                    iTempY = iGroundJ - 1;
-                    // END FCMOD
-                }
-            }
-
-            // FCMOD: Changed
-            /*
-            if (var32 != Block.ladder.blockID)
-            {
-                var25 = 0.0D;
-            }
-            */
-            Block inBlock = Block.blocksList[iGroundBlockID];
-            
-            if ( inBlock == null || !inBlock.IsBlockClimbable( worldObj, iGroundI, iTempY, iGroundK ) )
-            {
-                dDeltaY = 0D;
-            }                
-            // END FCMOD
-
-            distanceWalkedModified = distanceWalkedModified + MathHelper.sqrt_double(
-            	dDeltaX * dDeltaX + dDeltaZ * dDeltaZ ) * 0.6F;
-            
-            distanceWalkedOnStepModified = distanceWalkedOnStepModified + MathHelper.sqrt_double( 
-            	dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ ) * 0.6F;
-
-            if ( distanceWalkedOnStepModified > nextStepDistance && iGroundBlockID > 0 )
-            {
-                nextStepDistance = (int)distanceWalkedOnStepModified + 1;
-
-                if ( isInWater() )
-                {
-                    float fSwimSoundVolume = MathHelper.sqrt_double(
-                    	motionX * motionX * 0.20000000298023224D + motionY * motionY + 
-                    	motionZ * motionZ * 0.20000000298023224D ) * 0.35F;
-
-                    if ( fSwimSoundVolume > 1F )
-                    {
-                        fSwimSoundVolume = 1F;
-                    }
-
-                    playSound( "liquid.swim", fSwimSoundVolume, 
-                    	1F + ( rand.nextFloat() - rand.nextFloat() ) * 0.4F );
-                }
-
-                playStepSound( iGroundI, iGroundJ, iGroundK, iGroundBlockID );
-                
-                Block.blocksList[iGroundBlockID].onEntityWalking( worldObj, 
-                	iGroundI, iGroundJ, iGroundK, this );
-            }
-        }
-
-        doBlockCollisions(); // notifies blocks of intersections, doesn't move entity
-        
-        boolean bWet = isWet();
-
-        // FCMOD: Changed
-        //if ( worldObj.isBoundingBoxBurning( boundingBox.contract( 0.001D, 0.001D, 0.001D ) ) )
-        if ( worldObj.isBoundingBoxBurning( this ) )
-    	// END FCMOD
-        {
-            dealFireDamage( 1 );
-
-            if ( !bWet )
-            {
-                fire++;
-
-                if ( fire == 0 )
-                {
-                    setFire( 8 );
-                }
-            }
-        }
-        else if ( fire <= 0 )
-        {
-            fire = -fireResistance;
-        }
-
-        if ( bWet && fire > 0 )
-        {
-            playSound( "random.fizz", 0.7F, 1.6F + ( rand.nextFloat() - 
-            	rand.nextFloat() ) * 0.4F );
-            
-            fire = -fireResistance;
-        }
-
-        worldObj.theProfiler.endSection();
-    }
-    
-    public void readFromNBT( NBTTagCompound tag )
-    {
-        try
-        {
-        	boolean bHasBoundingData = false;
-        	
-    		NBTTagList posTag = tag.getTagList( "Pos" );
-    		
-    		prevPosX = lastTickPosX = posX = ( (NBTTagDouble)posTag.tagAt( 0 ) ).data;
-    		prevPosY = lastTickPosY = posY = ( (NBTTagDouble)posTag.tagAt( 1 ) ).data;
-    		prevPosZ = lastTickPosZ = posZ = ( (NBTTagDouble)posTag.tagAt( 2 ) ).data;
-        	
-        	if ( tag.hasKey( "fcMin" ) )
-        	{
-        		bHasBoundingData = true; 
-        			
-        		// fix for entities getting stuck in blocks on load
-        		
-        		NBTTagList minTag = tag.getTagList( "fcMin" );
-        		
-                double dMinX = ( (NBTTagDouble )minTag.tagAt( 0 ) ).data;
-                double dMinY = ( (NBTTagDouble )minTag.tagAt( 1 ) ).data;
-                double dMinZ = ( (NBTTagDouble )minTag.tagAt( 2 ) ).data;                
-	            
-        		NBTTagList maxTag = tag.getTagList( "fcMax" );
-        		
-                double dMaxX = ( (NBTTagDouble )maxTag.tagAt( 0 ) ).data;
-                double dMaxY = ( (NBTTagDouble )maxTag.tagAt( 1 ) ).data;
-                double dMaxZ = ( (NBTTagDouble )maxTag.tagAt( 2 ) ).data;
-                
-                boundingBox.setBounds( dMinX, dMinY, dMinZ, dMaxX, dMaxY, dMaxZ );
-        	}
-        	else
-        	{   
-                setPosition( posX, posY, posZ );        		
-        	}
-        	
-            NBTTagList motionTag = tag.getTagList("Motion");
-            
-            motionX = ((NBTTagDouble)motionTag.tagAt(0)).data;
-            motionY = ((NBTTagDouble)motionTag.tagAt(1)).data;
-            motionZ = ((NBTTagDouble)motionTag.tagAt(2)).data;
-
-            if (Math.abs(this.motionX) > 10.0D)
-            {
-                this.motionX = 0.0D;
-            }
-
-            if (Math.abs(this.motionY) > 10.0D)
-            {
-                this.motionY = 0.0D;
-            }
-
-            if (Math.abs(this.motionZ) > 10.0D)
-            {
-                this.motionZ = 0.0D;
-            }
-
-            NBTTagList rotationTag = tag.getTagList("Rotation");
-            
-            this.prevRotationYaw = this.rotationYaw = ((NBTTagFloat)rotationTag.tagAt(0)).data;
-            this.prevRotationPitch = this.rotationPitch = ((NBTTagFloat)rotationTag.tagAt(1)).data;
-            
-            this.fallDistance = tag.getFloat("FallDistance");
-            this.fire = tag.getShort("Fire");
-            this.setAir(tag.getShort("Air"));
-            this.onGround = tag.getBoolean("OnGround");
-            this.dimension = tag.getInteger("Dimension");
-            this.invulnerable = tag.getBoolean("Invulnerable");
-            this.timeUntilPortal = tag.getInteger("PortalCooldown");
-
-            if (tag.hasKey("UUIDMost") && tag.hasKey("UUIDLeast"))
-            {
-                this.entityUniqueID = new UUID(tag.getLong("UUIDMost"), tag.getLong("UUIDLeast"));
-            }
-
-            this.setRotation(this.rotationYaw, this.rotationPitch);
-            
-            readEntityFromNBT(tag);
-            
-            if ( !bHasBoundingData && ShouldSetPositionOnLoad() )
-            {
-            	// added to duplicate 1.6 fix for animals suffocating and escaping.
-            	// I believe this was due to stuff like child animals modifying their dimensions
-            	// during init, but is not required with the changes made to save full bounding
-            	// boxes
-            	
-                setPosition( posX, posY, posZ);
-            }
-        }
-        catch (Throwable var5)
-        {
-            CrashReport var3 = CrashReport.makeCrashReport(var5, "Loading entity NBT");
-            CrashReportCategory var4 = var3.makeCategory("Entity being loaded");
-            this.func_85029_a(var4);
-            throw new ReportedException(var3);
-        }
-    }
-    
-    /**
-     * Called when clients receive a packed from the server indicating that they should
-     * mount an entity as part of fix for MC-1291.
-     */
-    public void MountEntityRemote( Entity entityToMount )
-    {
-    	mountEntity( entityToMount );
-    }
-    
-    public void FlagAllWatchedObjectsDirty()
-    {
-    	List watchList = dataWatcher.getAllWatched();
-    	
-    	if ( watchList != null )
-    	{
-	        Iterator watchIterator = watchList.iterator();
-	
-	        while ( watchIterator.hasNext() )
-	        {
-	            WatchableObject tempWatchable = (WatchableObject)watchIterator.next();
-	            dataWatcher.setObjectWatched( tempWatchable.getDataValueId() );
-	        }
-    	}
-    }
-    // END FCMOD
 }
--- EntityAgeable.java	Sun May  5 14:00:11 2019
+++ EntityAgeable.java	Fri Apr 20 22:33:10 2018
@@ -1,16 +1,9 @@
 package net.minecraft.src;
 
-import java.util.Iterator;
-import java.util.List;
-
 public abstract class EntityAgeable extends EntityCreature
 {
-	// FCMOD: Changed for clarity
-    //private float field_98056_d = -1.0F;
-    //private float field_98057_e;
-    private float m_fAdultWidth = -1.0F; // -1 flags super entity size has not been initialized
-    private float m_fAdultHeight;
-    // END FCMOD
+    private float field_98056_d = -1.0F;
+    private float field_98057_e;
 
     public EntityAgeable(World par1World)
     {
@@ -23,13 +16,6 @@
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
     public boolean interact(EntityPlayer par1EntityPlayer)
-    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
-    {
-    	return EntityAgeableInteract( par1EntityPlayer );
-    }
-    
-    public boolean EntityAgeableInteract( EntityPlayer par1EntityPlayer )
-    // END FCMOD
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
 
@@ -43,10 +29,7 @@
 
                 if (var4 != null)
                 {
-                	// FCMOD: Changed
-                    //var4.setGrowingAge(-24000);
-                    var4.setGrowingAge( -GetTicksForChildToGrow() );
-                	// END FCMOD
+                    var4.setGrowingAge(-24000);
                     var4.setLocationAndAngles(this.posX, this.posY, this.posZ, 0.0F, 0.0F);
                     this.worldObj.spawnEntityInWorld(var4);
 
@@ -94,12 +77,7 @@
     public void setGrowingAge(int par1)
     {
         this.dataWatcher.updateObject(12, Integer.valueOf(par1));
-        // FCNOTE: This seems grossly ineffecient as I believe this data will get sent to the 
-        // clients every tick for child animals, and those waiting to recharge their love juice
-        // FCMOD: Changed
-        //this.func_98054_a(this.isChild());
-    	AdjustSizeForAge( isChild() );
-        // END FCMOD
+        this.func_98054_a(this.isChild());
     }
 
     /**
@@ -130,10 +108,7 @@
 
         if (this.worldObj.isRemote)
         {
-        	// FCMOD: Changed
-            //this.func_98054_a(this.isChild());
-        	AdjustSizeForAge( isChild() );
-            // END FCMOD
+            this.func_98054_a(this.isChild());
         }
         else
         {
@@ -141,43 +116,11 @@
 
             if (var1 < 0)
             {
-	        	// FCMOD: Added
-	        	if ( !CanChildGrow() )
-	        	{
-	        		return;
-	        	}
-	        	// END FCMOD
-	        	
                 ++var1;
-                
-                // FCMOD: Added
-        		if ( var1 == 0 )
-        		{
-        			// child is about to grow to adulthood.  Make sure it has enough space
-        			AxisAlignedBB adultBounds = AxisAlignedBB.getAABBPool().getAABB(
-        				boundingBox.minX, boundingBox.minY, boundingBox.minZ,
-        				boundingBox.minX + m_fAdultWidth, 
-        				boundingBox.minY + m_fAdultHeight, 
-        				boundingBox.minZ + m_fAdultWidth ); 
-        			
-        			if ( !worldObj.getCollidingBoundingBoxes( this, adultBounds ).isEmpty() )
-        			{
-        				var1 = -20;
-        			}        			
-        		}
-        		// END FCMOD
-        		
-                this.setGrowingAge(var1);                
+                this.setGrowingAge(var1);
             }
             else if (var1 > 0)
             {
-	        	// FCMOD: Added
-	        	if ( !CanLoveJuiceRegenerate() )
-	        	{
-	        		return;
-	        	}
-	        	// END FCMOD
-	        	
                 --var1;
                 this.setGrowingAge(var1);
             }
@@ -192,13 +135,14 @@
         return this.getGrowingAge() < 0;
     }
 
-	// FCMOD: Removed and replaced
-	/*
     public void func_98054_a(boolean par1)
     {
         this.func_98055_j(par1 ? 0.5F : 1.0F);
     }
 
+    /**
+     * Sets the width and height of the entity. Args: width, height
+     */
     protected final void setSize(float par1, float par2)
     {
         boolean var3 = this.field_98056_d > 0.0F;
@@ -215,48 +159,4 @@
     {
         super.setSize(this.field_98056_d * par1, this.field_98057_e * par1);
     }
-    */
-	// END FCMOD
-    
-    // FCMOD: Added New
-	protected final void setSize( float fWidth, float fHeight )
-	{
-        boolean bSizeAlreadyInitialized = m_fAdultWidth > 0F;
-        
-        m_fAdultWidth = fWidth;
-        m_fAdultHeight = fHeight;
-
-        if ( !bSizeAlreadyInitialized )
-        {
-        	AdjustedSizeToScale( 1F );
-        }
-	}
-
-    private void AdjustedSizeToScale( float fScale )
-    {
-        super.setSize( m_fAdultWidth * fScale, m_fAdultHeight * fScale );
-    }
-    
-    public void AdjustSizeForAge( boolean bIsChild )
-    {
-    	AdjustedSizeToScale( bIsChild ? 0.5F : 1F );
-    }
-    
-    public boolean CanChildGrow()
-    {
-    	// prevent animals growing up in the end
-    	
-    	return worldObj.provider.dimensionId != 1;
-    }
-    
-    public boolean CanLoveJuiceRegenerate()
-    {
-    	return true;
-    }
-    
-    protected int GetTicksForChildToGrow()
-    {
-    	return FCUtilsMisc.m_iTicksPerGameDay;
-    }
-    // END FCMOD
 }
--- EntityAIAttackOnCollide.java	Sat Jun  9 01:41:28 2018
+++ EntityAIAttackOnCollide.java	Fri Apr 20 22:33:10 2018
@@ -80,12 +80,6 @@
      */
     public void resetTask()
     {
-    	// FCMOD: Added
-    	if ( attacker.getAttackTarget() == entityTarget )
-    	{
-    		attacker.setAttackTarget( null );
-    	}
-    	// END FCMOD
         this.entityTarget = null;
         this.attacker.getNavigator().clearPathEntity();
     }
@@ -104,20 +98,7 @@
         }
 
         this.attackTick = Math.max(this.attackTick - 1, 0);
-        // FCMOD: Code change to take width of target into account as the original code assumes it's the same as the attacker
-        /*
         double var1 = (double)(this.attacker.width * 2.0F * this.attacker.width * 2.0F);
-        */
-        double dCombinedWidth = attacker.width + entityTarget.width;
-        double var1 = dCombinedWidth * dCombinedWidth;
-        
-        if ( entityTarget == attacker.riddenByEntity )
-        {
-        	// stop stuff like wolves biting squid on their backs
-        	
-        	return;
-        }
-        // END FCMOD
 
         if (this.attacker.getDistanceSq(this.entityTarget.posX, this.entityTarget.boundingBox.minY, this.entityTarget.posZ) <= var1)
         {
--- EntityAICreeperSwell.java	Fri Jun 15 19:50:15 2018
+++ EntityAICreeperSwell.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 public class EntityAICreeperSwell extends EntityAIBase
--- EntityAIDoorInteract.java	Sun Apr  8 18:25:02 2018
+++ EntityAIDoorInteract.java	Fri Apr 20 22:33:10 2018
@@ -106,10 +106,6 @@
     private BlockDoor findUsableDoor(int par1, int par2, int par3)
     {
         int var4 = this.theEntity.worldObj.getBlockId(par1, par2, par3);
-        // FCMOD: Changed
-        //return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
-        return ( var4 != Block.doorWood.blockID && var4 != FCBetterThanWolves.fcBlockDoorWood.blockID ) ? 
-        	null : (BlockDoor)Block.blocksList[var4];
-    	// END FCMOD
+        return var4 != Block.doorWood.blockID ? null : (BlockDoor)Block.blocksList[var4];
     }
 }
--- EntityAIEatGrass.java	Fri Jun 14 13:09:47 2013
+++ EntityAIEatGrass.java	Fri Apr 20 22:33:10 2018
@@ -85,12 +85,7 @@
             else if (this.theWorld.getBlockId(var1, var2 - 1, var3) == Block.grass.blockID)
             {
                 this.theWorld.playAuxSFX(2001, var1, var2 - 1, var3, Block.grass.blockID);
-                // FCMOD: Changed to send notification
-                /*
                 this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 2);
-                */
-                this.theWorld.setBlock(var1, var2 - 1, var3, Block.dirt.blockID, 0, 3);
-                // END FCMOD
                 this.theEntity.eatGrassBonus();
             }
         }
--- EntityAIFollowOwner.java	Sun Feb  4 19:34:14 2018
+++ EntityAIFollowOwner.java	Fri Apr 20 22:33:10 2018
@@ -84,13 +84,6 @@
     {
         this.thePet.getLookHelper().setLookPositionWithEntity(this.theOwner, 10.0F, (float)this.thePet.getVerticalFaceSpeed());
 
-        // FCMOD: Code added to prevent pets sitting in Minecarts from teleporting
-        if ( thePet.ridingEntity != null )
-        {
-        	return;
-        }
-        // END FCMOD
-        
         if (!this.thePet.isSitting())
         {
             if (--this.field_75343_h <= 0)
@@ -101,11 +94,10 @@
                 {
                     if (this.thePet.getDistanceSqToEntity(this.theOwner) >= 144.0D)
                     {
-                        // FCMOD: Code changed
-                    	/*
                         int var1 = MathHelper.floor_double(this.theOwner.posX) - 2;
                         int var2 = MathHelper.floor_double(this.theOwner.posZ) - 2;
                         int var3 = MathHelper.floor_double(this.theOwner.boundingBox.minY);
+
                         for (int var4 = 0; var4 <= 4; ++var4)
                         {
                             for (int var5 = 0; var5 <= 4; ++var5)
@@ -118,57 +110,9 @@
                                 }
                             }
                         }
-                        */
-				        HandleTeleportation();
-				    	// END FCMOD
                     }
                 }
             }
         }
     }
-    
-    // FCMOD: Added
-    private void HandleTeleportation()
-    {
-    	if ( !thePet.IsAITryingToSit() )
-    	{
-	        // Code changed so that pets will teleport *behind* the player instead of just randomly around him
-	        Float xVector = ( MathHelper.sin((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
-	        Float zVector = -( MathHelper.cos((theOwner.rotationYaw / 180F) * (float)Math.PI) * 4.0F );
-	
-	        int var1 = MathHelper.floor_double(theOwner.posX + xVector);
-	        int var2 = MathHelper.floor_double(theOwner.posZ + zVector);
-	        int var3 = MathHelper.floor_double(theOwner.boundingBox.minY);
-	        
-	        // Changed this so that the searching starts at the center of the location
-	        
-	        for (int xCount = 0; xCount <= 4; xCount++)
-	        {
-	            for (int zCount = 0; zCount <= 4; zCount++)
-	            {
-	            	int xOffset = ( xCount + 1 ) >> 1;
-	            	int zOffset = ( zCount + 1 ) >> 1;
-	        
-	        		if ( ( xCount & 1 ) == 0 )
-	        		{
-	        			xOffset = -xOffset;
-	        		}
-	        		
-	        		if ( ( zOffset & 1 ) == 0 )
-	        		{
-	        			zOffset = -zOffset;
-	        		}
-	        		
-	                if ( theWorld.doesBlockHaveSolidTopSurface( var1 + xOffset, var3 - 1, var2 + zOffset) && 
-	            		!theWorld.isBlockNormalCube(var1 + xOffset, var3, var2 + zOffset) && !theWorld.isBlockNormalCube(var1 + xOffset, var3 + 1, var2 + zOffset))
-	                {
-	                    thePet.setLocationAndAngles((float)(var1 + xOffset) + 0.5F, var3, (float)(var2 + zOffset) + 0.5F, thePet.rotationYaw, thePet.rotationPitch);
-	                    petPathfinder.clearPathEntity();
-	                    return;
-	                }
-	            }
-	        }
-    	}
-    }
-    // END FCMOD
 }
--- EntityAIFollowParent.java	Fri Jan  4 17:13:41 2019
+++ EntityAIFollowParent.java	Fri Apr 20 22:33:10 2018
@@ -15,10 +15,6 @@
     {
         this.childAnimal = par1EntityAnimal;
         this.field_75347_c = par2;
-        
-        // FCMOD: Added
-        setMutexBits( 1 );
-        // END FCMOD
     }
 
     /**
@@ -74,12 +70,6 @@
      */
     public boolean continueExecuting()
     {
-    	// FCMOD: Added to prevent adult children from following their parents
-    	if ( !childAnimal.isChild() )
-    	{
-    		return false;
-    	}
-    	// FCMOD
         if (!this.parentAnimal.isEntityAlive())
         {
             return false;
--- EntityAIHurtByTarget.java	Sun Aug 12 12:30:13 2018
+++ EntityAIHurtByTarget.java	Fri Apr 20 22:33:10 2018
@@ -5,21 +5,15 @@
 
 public class EntityAIHurtByTarget extends EntityAITarget
 {
-	// FCMOD: Changed the name of the following for clarity
-	/*
     boolean field_75312_a;
-	*/ 
-    private boolean m_bNearbyEntitiesOfSameTypeAttack;
-    // END FCMOD
 
     /** The PathNavigate of our entity. */
-    // FCNOTE: This is actually the target entity
     EntityLiving entityPathNavigate;
 
     public EntityAIHurtByTarget(EntityLiving par1EntityLiving, boolean par2)
     {
         super(par1EntityLiving, 16.0F, false);
-        this.m_bNearbyEntitiesOfSameTypeAttack = par2;
+        this.field_75312_a = par2;
         this.setMutexBits(1);
     }
 
@@ -28,12 +22,7 @@
      */
     public boolean shouldExecute()
     {
-    	// FCMOD: Changed this to ignore players in creative mode to reduce overall code complexity
-    	/*
         return this.isSuitableTarget(this.taskOwner.getAITarget(), true);
-        */
-        return this.isSuitableTarget(this.taskOwner.getAITarget(), false);
-        // END FCMOD    	
     }
 
     /**
@@ -41,16 +30,7 @@
      */
     public boolean continueExecuting()
     {
-    	// FCMOD: Change to stop executing when the target is dead, and to fix vanilla bug where this would immediately stop executing
-    	/*
         return this.taskOwner.getAITarget() != null && this.taskOwner.getAITarget() != this.entityPathNavigate;
-        */    	
-        return taskOwner.getAITarget() != null && 
-			taskOwner.getAITarget().isEntityAlive() && 
-	    	taskOwner.getAITarget() == entityPathNavigate && 
-	    	taskOwner.getAttackTarget() != null &&
-	    	taskOwner.getAttackTarget() == entityPathNavigate;
-    	// END FCMOD
     }
 
     /**
@@ -61,7 +41,7 @@
         this.taskOwner.setAttackTarget(this.taskOwner.getAITarget());
         this.entityPathNavigate = this.taskOwner.getAITarget();
 
-        if (this.m_bNearbyEntitiesOfSameTypeAttack)
+        if (this.field_75312_a)
         {
             List var1 = this.taskOwner.worldObj.getEntitiesWithinAABB(this.taskOwner.getClass(), AxisAlignedBB.getAABBPool().getAABB(this.taskOwner.posX, this.taskOwner.posY, this.taskOwner.posZ, this.taskOwner.posX + 1.0D, this.taskOwner.posY + 1.0D, this.taskOwner.posZ + 1.0D).expand((double)this.targetDistance, 10.0D, (double)this.targetDistance));
             Iterator var2 = var1.iterator();
@@ -70,19 +50,10 @@
             {
                 EntityLiving var3 = (EntityLiving)var2.next();
 
-            	// FCMOD: Changed this so any other creatures that glom on will trigger this same AI instead of having an attack target without a corresponding
-            	// AI state
-            	/*
                 if (this.taskOwner != var3 && var3.getAttackTarget() == null)
                 {
                     var3.setAttackTarget(this.taskOwner.getAITarget());
                 }
-                */
-                if (this.taskOwner != var3 && var3.getAttackTarget() == null && var3.getAITarget() == null )
-                {
-                	var3.setRevengeTarget( taskOwner.getAITarget() );
-                }
-            	// END FCMOD
             }
         }
 
@@ -94,26 +65,9 @@
      */
     public void resetTask()
     {
-    	// FCMOD: Code change to prevent problems with AI not resetting its target when it dies
-    	/*
         if (this.taskOwner.getAttackTarget() != null && this.taskOwner.getAttackTarget() instanceof EntityPlayer && ((EntityPlayer)this.taskOwner.getAttackTarget()).capabilities.disableDamage)
         {
             super.resetTask();
-            
-            // FCMOD: Code added to fix flickering between angry and not in creative            
-            taskOwner.entityLivingToAttack = null;
-            // END FCMOD
         }
-        */
-    	if ( taskOwner.getAttackTarget() != null && entityPathNavigate == taskOwner.getAttackTarget() )
-    	{
-            taskOwner.setAttackTarget((EntityLiving)null);
-    	}
-    	
-    	if ( taskOwner.getAITarget() != null && entityPathNavigate == taskOwner.getAITarget() )
-    	{
-    		taskOwner.setRevengeTarget( null );
-    	}
-    	// END FCMOD
     }
 }
--- EntityAIMate.java	Thu Feb 22 12:21:35 2018
+++ EntityAIMate.java	Fri Apr 20 22:33:10 2018
@@ -6,9 +6,9 @@
 
 public class EntityAIMate extends EntityAIBase
 {
-    protected EntityAnimal theAnimal;
+    private EntityAnimal theAnimal;
     World theWorld;
-    protected EntityAnimal targetMate;
+    private EntityAnimal targetMate;
 
     /**
      * Delay preventing a baby from spawning immediately when two mate-able animals find each other.
@@ -47,12 +47,6 @@
      */
     public boolean continueExecuting()
     {
-    	// FCMOD: Added
-        if ( !theAnimal.isInLove() )
-        {
-            return false;
-        }
-    	// END FCMOD
         return this.targetMate.isEntityAlive() && this.targetMate.isInLove() && this.spawnBabyDelay < 60;
     }
 
@@ -76,11 +70,7 @@
 
         if (this.spawnBabyDelay >= 60 && this.theAnimal.getDistanceSqToEntity(this.targetMate) < 9.0D)
         {
-        	/* FCMOD: Changed to use entity function to make birthing behavior easier to override and to consolodate it in one place
             this.spawnBaby();
-            */
-        	theAnimal.procreate( targetMate );
-        	// END FCMOD
         }
     }
 
@@ -113,8 +103,6 @@
     /**
      * Spawns a baby animal of the same type.
      */
-    // FCMOD: Removed dead code
-    /*
     private void spawnBaby()
     {
         EntityAgeable var1 = this.theAnimal.createChild(this.targetMate);
@@ -138,9 +126,7 @@
                 this.theWorld.spawnParticle("heart", this.theAnimal.posX + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, this.theAnimal.posY + 0.5D + (double)(var2.nextFloat() * this.theAnimal.height), this.theAnimal.posZ + (double)(var2.nextFloat() * this.theAnimal.width * 2.0F) - (double)this.theAnimal.width, var4, var6, var8);
             }
 
-            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));            
-        }        
+            this.theWorld.spawnEntityInWorld(new EntityXPOrb(this.theWorld, this.theAnimal.posX, this.theAnimal.posY, this.theAnimal.posZ, var2.nextInt(7) + 1));
+        }
     }
-    */
-    // END FCMOD
 }
--- EntityAIOpenDoor.java	Sat Jul 13 20:39:58 2013
+++ EntityAIOpenDoor.java	Fri Apr 20 22:33:10 2018
@@ -26,12 +26,7 @@
     public void startExecuting()
     {
         this.field_75360_j = 20;
-        // FCMOD: Code change
-        /*
         this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
-        */        
-        this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, true);
-        // END FCMOD
     }
 
     /**
@@ -41,12 +36,7 @@
     {
         if (this.field_75361_i)
         {
-            // FCMOD: Code change
-            /*
             this.targetDoor.onPoweredBlockChange(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
-            */
-            this.targetDoor.OnAIOpenDoor(this.theEntity.worldObj, this.entityPosX, this.entityPosY, this.entityPosZ, false);
-        	// END FCMOD
         }
     }
 
--- EntityAIOwnerHurtByTarget.java	Fri Jun 14 13:10:48 2013
+++ EntityAIOwnerHurtByTarget.java	Fri Apr 20 22:33:10 2018
@@ -17,12 +17,6 @@
      */
     public boolean shouldExecute()
     {
-    	// FCMOD: Code added to check if sitting before attacking    	
-    	if ( theDefendingTameable.isSitting() )
-    	{
-    		return false;
-    	}
-    	// END FCMOD
         if (!this.theDefendingTameable.isTamed())
         {
             return false;
@@ -51,17 +45,4 @@
         this.taskOwner.setAttackTarget(this.theOwnerAttacker);
         super.startExecuting();
     }
-
-    // FCMOD: Inherited function added
-    @Override
-    public boolean continueExecuting()
-    {
-    	if ( theDefendingTameable.isSitting() )
-    	{
-    		return false;
-    	}
-    	
-    	return super.continueExecuting();
-    }
-    // END FCMOD
 }
--- EntityAIOwnerHurtTarget.java	Fri Jun 14 13:10:53 2013
+++ EntityAIOwnerHurtTarget.java	Fri Apr 20 22:33:10 2018
@@ -17,12 +17,6 @@
      */
     public boolean shouldExecute()
     {
-    	// FCMOD: Code added to check if sitting before attacking    	
-    	if ( theEntityTameable.isSitting() )
-    	{
-    		return false;
-    	}
-    	// END FCMOD
         if (!this.theEntityTameable.isTamed())
         {
             return false;
@@ -51,17 +45,4 @@
         this.taskOwner.setAttackTarget(this.theTarget);
         super.startExecuting();
     }
-
-    // FCMOD: Inherited function added
-    @Override
-    public boolean continueExecuting()
-    {
-    	if ( theEntityTameable.isSitting() )
-    	{
-    		return false;
-    	}
-    	
-    	return super.continueExecuting();
-    }
-    // END FCMOD
 }
--- EntityAISit.java	Sun Feb  4 19:30:53 2018
+++ EntityAISit.java	Fri Apr 20 22:33:10 2018
@@ -33,12 +33,7 @@
         else
         {
             EntityLiving var1 = this.theEntity.getOwner();
-            // FCMOD: Line change to prevent wolves from standing when player is attacked
-            /*
             return var1 == null ? true : (this.theEntity.getDistanceSqToEntity(var1) < 144.0D && var1.getAITarget() != null ? false : this.isSitting);
-            */
-            return var1 == null ? true : this.isSitting;
-            // END FCMOD
         }
     }
 
@@ -66,11 +61,4 @@
     {
         this.isSitting = par1;
     }
-    
-    // FCMOD: Added
-    public boolean IsTryingToSit()
-    {
-    	return this.isSitting;
-    }
-    // END FCMOD
-}
\ No newline at end of file
+}
--- EntityAITasks.java	Tue Jan  8 17:13:12 2019
+++ EntityAITasks.java	Fri Apr 20 22:33:10 2018
@@ -178,48 +178,4 @@
     {
         return (par1EntityAITaskEntry.action.getMutexBits() & par2EntityAITaskEntry.action.getMutexBits()) == 0;
     }
-    
-    // FCMOD: Added New
-    public void RemoveAllTasksOfClass( Class classToRemove )
-    {
-        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
-
-        while ( entries.hasNext())
-        {
-            EntityAITaskEntry tempEntry = entries.next();
-            EntityAIBase tempAction = tempEntry.action;
-
-            if ( classToRemove.isAssignableFrom( tempAction.getClass() ) )
-            {
-                if ( executingTaskEntries.contains( tempEntry ) )
-                {
-                    tempAction.resetTask();
-                    
-                    executingTaskEntries.remove( tempEntry );
-                }
-
-                entries.remove();
-            }
-        }
-    }
-    
-    public void RemoveAllTasks()
-    {
-        Iterator<EntityAITaskEntry> entries = taskEntries.iterator();
-
-        while ( entries.hasNext())
-        {
-            EntityAITaskEntry tempEntry = entries.next();
-
-            if ( executingTaskEntries.contains( tempEntry ) )
-            {
-                tempEntry.action.resetTask();
-                
-                executingTaskEntries.remove( tempEntry );
-            }
-
-            entries.remove();
-        }
-    }
-    // END FCMOD
 }
--- EntityAITempt.java	Wed Feb 28 15:35:57 2018
+++ EntityAITempt.java	Fri Apr 20 22:33:10 2018
@@ -97,12 +97,7 @@
             this.field_75279_g = (double)this.temptingPlayer.rotationYaw;
         }
 
-        // FCMOD: Changed this line
-        /*
         return this.shouldExecute();
-        */
-        return ShouldContinueFollowing();
-        // END FCMOD
     }
 
     /**
@@ -125,12 +120,7 @@
     {
         this.temptingPlayer = null;
         this.temptedEntity.getNavigator().clearPathEntity();
-        // FCMOD: Code change to make animals more responsive to tempting.  Note that AI is only checked every three ticks
-        /*
         this.delayTemptCounter = 100;
-        */
-        this.delayTemptCounter = 33;
-        // END FCMOD
         this.field_75287_j = false;
         this.temptedEntity.getNavigator().setAvoidsWater(this.field_75286_m);
     }
@@ -156,34 +146,4 @@
     {
         return this.field_75287_j;
     }
-    
-    // FCMOD: Function added
-    private boolean ShouldContinueFollowing()
-    {
-        if (delayTemptCounter > 0)
-        {
-            delayTemptCounter--;
-            return false;
-        }
-
-        if (temptingPlayer == null || temptingPlayer.isLivingDead )
-        {
-            return false;
-        }
-
-        if (temptedEntity.getDistanceSqToEntity(temptingPlayer) > 256D)
-        {
-        	return false;
-        }
-
-        ItemStack itemstack = temptingPlayer.getCurrentEquippedItem();
-
-        if (itemstack == null)
-        {
-            return false;
-        }
-
-        return itemstack.itemID == breedingFood;
-    }
-    // END FCMOD
 }
--- EntityAIWander.java	Fri Jun 14 13:11:11 2013
+++ EntityAIWander.java	Fri Apr 20 22:33:10 2018
@@ -20,21 +20,11 @@
      */
     public boolean shouldExecute()
     {
-    	// FCMOD: Code removed to disable AI activation distance
-    	/*
         if (this.entity.getAge() >= 100)
         {
             return false;
         }
-        */
-    	// END FCMOD
-    	
-    	// FCMOD: Line change to get rid of else
-    	/*
         else if (this.entity.getRNG().nextInt(120) != 0)
-        */
-        if (this.entity.getRNG().nextInt(120) != 0)
-    	// END FCMOD
         {
             return false;
         }
--- EntityAnimal.java	Tue Jan 22 17:07:59 2019
+++ EntityAnimal.java	Fri Apr 20 22:33:10 2018
@@ -2,24 +2,15 @@
 
 import java.util.List;
 
-// FCMOD: Added
-import java.util.Iterator;
-// END FCMOD
-
 public abstract class EntityAnimal extends EntityAgeable implements IAnimals
 {
-	// FCMOD: Removed and replaced with a watchable value
-    //private int inLove;
-	// END FCMOD
+    private int inLove;
 
     /**
      * This is representation of a counter for reproduction progress. (Note that this is different from the inLove which
      * represent being in Love-Mode)
      */
-	// FCMOD: Changed
-    //private int breeding = 0;
-    protected int breeding = 0;
-    // END FCMOD
+    private int breeding = 0;
 
     public EntityAnimal(World par1World)
     {
@@ -33,12 +24,7 @@
     {
         if (this.getGrowingAge() != 0)
         {
-        	// FCMOD: Change
-        	/*
             this.inLove = 0;
-            */
-        	resetInLove();
-        	// END FCMOD
         }
 
         super.updateAITick();
@@ -54,35 +40,15 @@
 
         if (this.getGrowingAge() != 0)
         {
-        	// FCMOD: Change
-        	/*
             this.inLove = 0;
-            */
-        	resetInLove();
-        	// END FCMOD
         }
 
-        // FCMOD: Change
-        /*
         if (this.inLove > 0)
-        */
-        if ( isInLove() )
-    	// END FCMOD
         {
-            // FCMOD: Change
-            /*
             --this.inLove;
-            */
-            setInLove( getInLove() - 1 );
-        	// END FCMOD
             String var1 = "heart";
 
-            // FCMOD: Change
-            /*
             if (this.inLove % 10 == 0)
-            */
-            if ( getInLove() % 10 == 0 )
-        	// END FCMOD
             {
                 double var2 = this.rand.nextGaussian() * 0.02D;
                 double var4 = this.rand.nextGaussian() * 0.02D;
@@ -129,12 +95,7 @@
                     this.hasAttacked = true;
                 }
             }
-            // FCMOD: Change
-            /*
             else if (this.inLove > 0 && var8.inLove > 0)
-            */
-            else if ( isInLove() && var8.isInLove() )
-        	// END FCMOD
             {
                 if (var8.entityToAttack == null)
                 {
@@ -143,14 +104,8 @@
 
                 if (var8.entityToAttack == this && (double)par2 < 3.5D)
                 {
-                	// FCMOD: Code change: 
-                	/*
                     ++var8.inLove;
                     ++this.inLove;
-                    */
-                    setInLove( getInLove() + 1 );
-                    var8.setInLove( var8.getInLove() + 1 );
-                    // END FCMOD
                     ++this.breeding;
 
                     if (this.breeding % 4 == 0)
@@ -180,8 +135,6 @@
      * Creates a baby animal according to the animal type of the target at the actual position and spawns 'love'
      * particles.
      */
-    // FCMOD: Code removed and replaced later
-    /*
     private void procreate(EntityAnimal par1EntityAnimal)
     {
         EntityAgeable var2 = this.createChild(par1EntityAnimal);
@@ -210,8 +163,6 @@
             this.worldObj.spawnEntityInWorld(var2);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Called when the entity is attacked.
@@ -226,13 +177,7 @@
         {
             this.fleeingTick = 60;
             this.entityToAttack = null;
-            // FCMOD: Code change
-            /*
             this.inLove = 0;
-            */
-        	resetInLove();
-        	PanickNearbyAnimals( par1DamageSource );
-        	// END FCMOD
             return super.attackEntityFrom(par1DamageSource, par2);
         }
     }
@@ -241,40 +186,28 @@
      * Takes a coordinate in and returns a weight to determine how likely this creature will try to path to the block.
      * Args: x, y, z
      */
-    // FCMOD: Removed and replaced
-    /*
     public float getBlockPathWeight(int par1, int par2, int par3)
     {
         return this.worldObj.getBlockId(par1, par2 - 1, par3) == Block.grass.blockID ? 10.0F : this.worldObj.getLightBrightness(par1, par2, par3) - 0.5F;
     }
-    */
-    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
      */
-    // FCMOD: Removed and replaced
-    /*
     public void writeEntityToNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.writeEntityToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setInteger("InLove", this.inLove);
     }
-    */
-    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
      */
-    // FCMOD: Removed and replaced
-    /*
     public void readEntityFromNBT(NBTTagCompound par1NBTTagCompound)
     {
         super.readEntityFromNBT(par1NBTTagCompound);
         this.inLove = par1NBTTagCompound.getInteger("InLove");
     }
-    */
-    // END FCMOD
 
     /**
      * Finds the closest player within 16 blocks to attack, or null if this Entity isn't interested in attacking
@@ -293,15 +226,8 @@
             int var3;
             EntityAnimal var4;
 
-            // FCMOD: Change
-            /*
             if (this.inLove > 0)
-            */
-            if ( isInLove() )
-        	// END FCMOD
             {
-	        	// FCMOD: Changed the following to find the closest animal instead of just a random one
-	        	/*	        	
                 var2 = this.worldObj.getEntitiesWithinAABB(this.getClass(), this.boundingBox.expand((double)var1, (double)var1, (double)var1));
 
                 for (var3 = 0; var3 < var2.size(); ++var3)
@@ -313,30 +239,6 @@
                         return var4;
                     }
                 }
-                */
-	        	double dClosestAnimalDistanceSq = 0.0F;
-	        	EntityAnimal closestValidAnimal = null;
-	        	
-	            List list = worldObj.getEntitiesWithinAABB(getClass(), boundingBox.expand( var1, var1, var1 ));
-
-	            for (int i = 0; i < list.size(); i++)
-	            {
-	                EntityAnimal entityanimal = (EntityAnimal)list.get(i);
-	                
-	                if (entityanimal != this && entityanimal.isInLove() )
-	                {
-	                	double dDistanceSqToAnimal = getDistanceSqToEntity( entityanimal );
-	                	
-	                	if ( closestValidAnimal == null || dDistanceSqToAnimal < dClosestAnimalDistanceSq )
-	                	{
-	                		dClosestAnimalDistanceSq = dDistanceSqToAnimal;
-	                		closestValidAnimal = entityanimal;
-	                	}
-	        		}
-	            }
-            
-            	return closestValidAnimal;
-	            // END FCMOD
             }
             else if (this.getGrowingAge() == 0)
             {
@@ -418,8 +320,6 @@
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -454,26 +354,18 @@
             return super.interact(par1EntityPlayer);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns if the entity is currently in 'love mode'.
      */
     public boolean isInLove()
     {
-    	// FCMOD: Changed
-        //return this.inLove > 0;
-    	return getInLove() > 0;
-    	// END FCMOD    	
+        return this.inLove > 0;
     }
 
     public void resetInLove()
     {
-    	// FCMOD: Changed
-        //this.inLove = 0;
-    	setInLove( 0 );
-    	// END FCMOD
+        this.inLove = 0;
     }
 
     /**
@@ -483,994 +375,4 @@
     {
         return par1EntityAnimal == this ? false : (par1EntityAnimal.getClass() != this.getClass() ? false : this.isInLove() && par1EntityAnimal.isInLove());
     }
-    
-    // FCMOD: Added New
-    protected static final int m_iHungerLevelDataWatcherID = 21;
-	protected static final int m_iInLoveDataWatcherID = 22;
-	protected static final int m_iWearingBreedingHarnessDataWatcherID = 23;
-	
-    @Override
-    protected void entityInit()
-    {
-        super.entityInit();
-        
-        dataWatcher.addObject( m_iHungerLevelDataWatcherID, new Byte( (byte)0 ) );
-        dataWatcher.addObject( m_iInLoveDataWatcherID, new Integer( 0 ) );
-        dataWatcher.addObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( (byte)0 ) );
-    }
-    
-    @Override
-    public void writeEntityToNBT( NBTTagCompound tag )
-    {
-        super.writeEntityToNBT( tag );
-        
-        tag.setInteger( "InLove", getInLove() );
-        tag.setByte( "fcHungerLvl", (byte)GetHungerLevel() );
-        tag.setBoolean( "BreedingHarness", getWearingBreedingHarness() );
-        tag.setInteger( "fcHungerCnt", m_iHungerCountdown );
-        tag.setInteger( "fcHealCnt", m_iHealingCountdown );
-    }
-
-    @Override
-    public void readEntityFromNBT( NBTTagCompound tag )
-    {
-        super.readEntityFromNBT( tag );
-        
-        setInLove( tag.getInteger( "InLove" ) );
-        
-        if ( tag.hasKey( "BreedingHarness" ) )
-        {
-        	setWearingBreedingHarness( tag.getBoolean( "BreedingHarness" ) );
-        }
-        
-        if ( tag.hasKey( "fcHungerLvl" ) )
-        {
-            SetHungerLevel( tag.getByte( "fcHungerLvl" ) );
-        }
-        
-        if ( tag.hasKey( "fcHungerCnt" ) )
-        {
-        	m_iHungerCountdown = tag.getInteger( "fcHungerCnt" );
-        }
-        else
-        {
-        	ResetHungerCountdown();
-        }
-        
-        if ( tag.hasKey( "fcHealCnt" ) )
-        {
-        	m_iHealingCountdown = tag.getInteger( "fcHealCnt" );
-        }
-        else
-        {
-        	ResetHealingCountdown();
-        }
-    }
-    
-    @Override
-    protected void ModSpecificOnLivingUpdate()
-    {
-    	super.ModSpecificOnLivingUpdate();
-    	
-	    if ( !worldObj.isRemote )
-	    {
-	    	if ( isEntityAlive() )
-	    	{
-		        CheckForLooseFood();
-		        CheckForIntersectingBreedingHarnesses();
-	
-		        UpdateHealing();
-		        UpdateHungerState();
-	    	}
-	    }
-	    else
-	    {
-	        if ( m_iGrazeProgressCounter > 0 )
-	        {
-	        	// update the graze counter on the client as we only get an initial 
-	        	// notification when it starts in a healthUpdate
-	        	
-	            m_iGrazeProgressCounter--;
-	        }
-	    }
-	    
-	    if ( isInLove() )
-	    {
-	    	if ( entityToAttack != null && entityToAttack instanceof EntityAnimal )
-	    	{
-	            EntityAnimal entityanimal = (EntityAnimal)entityToAttack;
-	            
-	            if ( !entityanimal.isInLove() )
-	            {
-	            	// the targeted animal is no longer in love mode.  Reset the target so another will be selected on the following update
-	            	
-	            	entityToAttack = null;
-	            }
-	    	}
-	    }
-    }
-    
-	@Override
-    protected void jump()
-    {
-    	if ( isChild() )
-    	{
-    		// jump half height if child or starving
-    		
-            motionY = 0.21D;
-            isAirBorne = true;    		
-    	}
-    	else
-    	{
-    		super.jump();
-    	}
-    }
-    
-	@Override
-    public void onDeath( DamageSource damageSource )
-    {
-    	super.onDeath( damageSource );
-    	
-    	if ( !worldObj.isRemote && getWearingBreedingHarness() )
-    	{
-            dropItem( FCBetterThanWolves.fcItemBreedingHarness.itemID, 1 );
-    	}        
-    }
-    
-	@Override
-    protected void updateEntityActionState()
-    {
-		super.updateEntityActionState();
-		
-    	if ( getWearingBreedingHarness() )
-    	{
-            moveStrafing = 0F;
-            moveForward = 0F;
-    	}
-    }
-	
-	@Override
-    public void CheckForScrollDrop()
-    {
-		// this is overridden to prevent potentially expensive (and useless) checks every 
-		// time an animal dies, since none of them drop scrolls
-    }
-
-    @Override
-    protected float getSoundPitch()
-    {
-    	float fPitch = super.getSoundPitch();
-
-    	if ( IsPossessed() )
-    	{
-    		fPitch *= 0.60F;
-    	}
-    	
-        return fPitch;
-    }
-    
-	@Override
-    public void setRevengeTarget( EntityLiving targetEntity )
-    {
-		// override to lengthen panic time on animals
-    	
-        entityLivingToAttack = targetEntity;
-        
-        if ( entityLivingToAttack != null )
-        {
-        	revengeTimer = 300; // 15 seconds
-        }
-        else
-        {
-        	revengeTimer = 0;
-        }
-    }
-    
-    @Override
-    public float getBlockPathWeight( int i, int j, int k )
-    {
-    	if ( CanGrazeOnBlock( i, j - 1, k ) || CanGrazeOnBlock( i, j, k ) )
-    	{
-    		return 10F;
-    	}
-    	
-    	return worldObj.GetNaturalLightBrightness( i, j, k ) - 0.5F;
-    }
-    
-    @Override
-    public boolean IsSecondaryTargetForSquid()
-    {
-    	return true;
-    }
-    
-    @Override
-    public void OnFlungBySquidTentacle( FCEntitySquid squid )
-    {
-		DamageSource squidSource = DamageSource.causeMobDamage( squid );
-		
-		attackEntityFrom( squidSource, 0 );
-    }
-    
-    @Override
-    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
-    {
-		DamageSource squidSource = DamageSource.causeMobDamage( squid );
-		
-		attackEntityFrom( squidSource, 0 );
-    }
-    
-    @Override
-    protected void AttemptToPossessNearbyCreatureOnDeath()
-    {
-		AttemptToPossessNearbyCreature( 16D, true );
-    }
-    
-    @Override
-    public float getSpeedModifier()
-    {
-    	return super.getSpeedModifier() * GetHungerSpeedModifier();    	
-    }
-    
-    @Override
-    public boolean CanChildGrow()
-    {
-    	return super.CanChildGrow() && !IsTooHungryToGrow();
-    }
-    
-    @Override
-    public boolean CanLoveJuiceRegenerate()
-    {
-    	return IsFullyFed();
-    }
-    
-    @Override
-    protected int GetTicksForChildToGrow()
-    {
-    	return FCUtilsMisc.m_iTicksPerGameDay * 2;
-    }
-    
-    @Override
-    public boolean interact( EntityPlayer player )
-    {
-    	return EntityAnimalInteract( player );
-    }
-    
-    @Override
-    public void initCreature() 
-    {
-    	InitHungerWithVariance();
-    }
-    
-    //------------- Class Specific Methods ------------//
-    
-    public int getInLove()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iInLoveDataWatcherID );
-    }
-    
-    public void setInLove( int iInLove )
-    {
-        dataWatcher.updateObject( m_iInLoveDataWatcherID, Integer.valueOf( iInLove ) );
-    }
-   
-    public boolean getWearingBreedingHarness()
-    {
-        return ( dataWatcher.getWatchableObjectByte( m_iWearingBreedingHarnessDataWatcherID ) > 0 );
-    }
-    
-    public void setWearingBreedingHarness( boolean bWearingHarness )
-    {
-    	Byte wearing = 0;
-    	
-    	if ( bWearingHarness )
-    	{
-    		wearing = 1;
-    	}
-    	
-        dataWatcher.updateObject( m_iWearingBreedingHarnessDataWatcherID, Byte.valueOf( wearing ) );
-    }
-   
-    public void CheckForIntersectingBreedingHarnesses()
-    {    
-    	if ( getWearingBreedingHarness()  )
-    	{
-            AxisAlignedBB tempBoundingBox = boundingBox.copy();
-            
-            tempBoundingBox.contract(0.1D, 0.1D, 0.1D );
-            
-		    List collisionList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, 
-	    		tempBoundingBox );
-		    
-		    if ( !collisionList.isEmpty() )
-		    {
-	            for ( int listIndex = 0; listIndex < collisionList.size(); listIndex++ )
-	            {
-		    		EntityAnimal entityAnimal = (EntityAnimal)collisionList.get( listIndex );;
-		    		
-		    		if ( entityAnimal != this )
-		    		{		    		
-				        if ( entityAnimal.getWearingBreedingHarness() && !(entityAnimal.isLivingDead) )
-				        {
-				        	attackEntityFrom( DamageSource.inWall, 1 );
-				        	
-			    			break;				            
-			    		}
-		    		}
-	            }
-		    }
-    	}
-    }
-    
-	public void PanickNearbyAnimals( DamageSource damageSource )
-	{
-		Entity attackingEntity = damageSource.getEntity();
-
-		if ( attackingEntity != null && ( attackingEntity instanceof EntityLiving ) )
-		{
-			EntityLiving attackingEntityLiving = (EntityLiving)attackingEntity;
-			
-	        List animalList = worldObj.getEntitiesWithinAABB( EntityAnimal.class, boundingBox.expand( 16D, 8D, 16D ) );
-	        
-	        Iterator itemIterator = animalList.iterator();
-	
-	        while ( itemIterator.hasNext())
-	        {
-	    		EntityAnimal tempAnimal = (EntityAnimal)itemIterator.next();
-	    		
-		        if ( !(tempAnimal.isLivingDead) && tempAnimal != this && tempAnimal != attackingEntityLiving )
-		        {
-		        	tempAnimal.OnNearbyAnimalAttacked( this, attackingEntityLiving ); 
-		        }
-		        
-	        }
-		}
-	}
-	
-	public void OnNearbyAnimalAttacked( EntityAnimal attackedAnimal, EntityLiving attackSource )
-	{
-		// only freak the animal out if it isn't already freaked by something else
-		
-		if ( entityLivingToAttack == null )
-		{
-	        entityLivingToAttack = attackSource;	        
-        	revengeTimer = 150; // 7.5 seconds
-		}
-		else if ( revengeTimer < 150 )
-		{
-			revengeTimer = 150;
-		}
-	}
-
-	public void OnNearbyFireStartAttempt( EntityPlayer player )
-	{
-		OnNearbyPlayerStartles( player );
-	}
-	
-	public void OnNearbyPlayerBlockAddOrRemove( EntityPlayer player )
-	{
-		OnNearbyPlayerStartles( player );
-	}
-	
-	protected void OnNearbyPlayerStartles( EntityPlayer player )
-	{
-		// only freak the animal out if it isn't already freaked by something else
-		
-		if ( entityLivingToAttack == null )
-		{
-	        entityLivingToAttack = player;	        
-        	revengeTimer = 150; // 7.5 seconds
-		}
-		else if ( revengeTimer < 150 )
-		{
-			revengeTimer = 150;
-		}
-	}
-	
-    protected void procreate( EntityAnimal targetMate )
-    {
-    	// Replacement for vanilla function above
-    	
-		double dChildX = posX;
-		double dChildY = posY;
-		double dChildZ = posZ;
-		
-        if ( getWearingBreedingHarness() )
-        {
-        	dChildX = ( posX + targetMate.posX ) / 2.0F;
-        	dChildY = ( posY + targetMate.posY ) / 2.0F;
-        	dChildZ = ( posZ + targetMate.posZ ) / 2.0F;                	
-        }
-        
-        GiveBirthAtTargetLocation( targetMate, dChildX, dChildY, dChildZ );
-        
-    	ResetMatingStateOfBothParents( targetMate );
-    	
-        SpawnBirthHeartParticles();
-
-        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
-        
-        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalBirthingAuxFXID,  
-    		MathHelper.floor_double( dChildX ), MathHelper.floor_double( dChildY ), MathHelper.floor_double( dChildZ ), 
-    		0 );            
-    }
-    
-    protected void GiveBirthAtTargetLocation( EntityAnimal targetMate, double dChildX, double dChildY, double dChildZ )
-    {
-        EntityAgeable childEntity = createChild( targetMate );
-
-        if ( childEntity != null )
-        {
-            childEntity.setGrowingAge( -GetTicksForChildToGrow() );
-            
-        	childEntity.setLocationAndAngles( dChildX, dChildY, dChildZ, rotationYaw, rotationPitch );
-            
-            worldObj.spawnEntityInWorld( childEntity );            
-        }
-    }
-    
-    protected void ResetMatingStateOfBothParents( EntityAnimal targetMate )
-    {
-        setGrowingAge( GetTicksToRegenerateLoveJuice() );
-        targetMate.setGrowingAge( targetMate.GetTicksToRegenerateLoveJuice() );
-        
-        resetInLove();            
-        breeding = 0;
-        entityToAttack = null;
-        
-        targetMate.resetInLove();            
-        targetMate.entityToAttack = null;
-        targetMate.breeding = 0;        
-    }
-    
-    protected void SpawnBirthHeartParticles()
-    {
-        for ( int iTempCount = 0; iTempCount < 7; ++iTempCount )
-        {
-            double dParticleVelX = this.rand.nextGaussian() * 0.02D;
-            double dParticleVelY = this.rand.nextGaussian() * 0.02D;
-            double dParticleVelZ = this.rand.nextGaussian() * 0.02D;
-            
-            worldObj.spawnParticle( "heart", 
-            	this.posX + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
-            	this.posY + 0.5D + (double)(this.rand.nextFloat() * this.height), 
-            	this.posZ + (double)(this.rand.nextFloat() * this.width * 2.0F) - (double)this.width, 
-            	dParticleVelX, dParticleVelY, dParticleVelZ);
-        }
-    }
-    
-    //-------------- Hunger related functionality ------------//
-    
-    protected static final int m_iFullHungerCount = ( FCUtilsMisc.m_iTicksPerGameDay );
-    protected static final int m_iLevelUpHungerCount = ( m_iFullHungerCount + 
-    	( m_iFullHungerCount / 16 ) );
-    
-    protected static final int m_iMaxHealingCount = ( FCUtilsMisc.m_iTicksPerGameDay );
-    
-    protected int m_iHungerCountdown = m_iFullHungerCount;
-    protected int m_iHealingCountdown = m_iFullHungerCount;
-    
-    public static final int m_iBaseGrazeFoodValue = 200;
-    
-    protected static final int m_iDelayBetweenEatLoose = ( FCUtilsMisc.m_iTicksPerSecond / 2 );
-    
-    protected static final int m_iDelayBetweenEatLooseVariance = 
-    	( FCUtilsMisc.m_iTicksPerSecond / 2 );
-    
-    protected int m_iEatLooseCooldownCounter = ( m_iDelayBetweenEatLoose + 
-    	m_iDelayBetweenEatLooseVariance );
-    
-    protected int m_iGrazeProgressCounter = 0;
-    
-    public void InitHungerWithVariance()
-    {
-    	// prevent initially spawned animals from all eating at the same time.
-    	
-    	if ( IsSubjectToHunger() )
-    	{
-    		m_iHungerCountdown = m_iFullHungerCount - rand.nextInt( GetGrazeHungerGain() );
-    	}
-    }
-    
-    protected int GetHungerLevel()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iHungerLevelDataWatcherID );
-    }
-    
-    protected void SetHungerLevel( int iHungerLevel )
-    {
-        dataWatcher.updateObject( m_iHungerLevelDataWatcherID, Byte.valueOf( (byte)iHungerLevel ) );
-    }
-    
-    protected boolean IsFullyFed()
-    {
-        return GetHungerLevel() == 0;
-    }
-    
-    protected boolean IsFamished()
-    {
-        return GetHungerLevel() == 1;
-    }
-    
-    protected boolean IsStarving()
-    {
-        return GetHungerLevel() >= 2;
-    }    
-    
-    protected void OnBecomeFamished()
-    {
-		SetHungerLevel( 1 );
-    }
-    
-    public void OnBecomeStarving()
-    {
-		SetHungerLevel( 2 );
-    }
-    
-    protected void OnStarvingCountExpired()
-    {
-		// max health 20 wolves, 15 cows, 10 pigs, 8 sheep, 4 chicken
-		
-		attackEntityFrom( DamageSource.starve, 5 );
-    }
-    
-    public boolean IsSubjectToHunger()
-    {
-    	return false;
-    }
-    
-    protected void UpdateHungerState()
-    {
-    	if ( IsSubjectToHunger() )
-    	{
-    		if ( !isChild() )
-    		{
-    			m_iHungerCountdown--;
-    		}
-    		else    			
-    		{
-    			// children burn more energy
-    			
-    			m_iHungerCountdown -= 2;
-    		}
-	    	
-	    	if ( m_iHungerCountdown <= 0 )
-	    	{
-	    		if ( !isChild() )
-	        	{
-		    		if ( IsFullyFed() )
-		    		{
-	    				OnBecomeFamished();
-		    		}
-		    		else if ( IsFamished() )
-		    		{
-		    			OnBecomeStarving();
-		    		}
-		    		else // starving
-		    		{
-		    			OnStarvingCountExpired();
-		    		}
-		    		
-		    		ResetHungerCountdown();
-	        	}
-	    		else 
-	    		{ 
-	    			// children can not survive being famished.  They'll
-	    			// just keep taking damage once their countdown expires
-	    			
-	    			attackEntityFrom( DamageSource.starve, 1 );
-	    		}		
-	    	}
-    	}
-    }
-    
-    protected void ResetHungerCountdown()
-    {
-    	m_iHungerCountdown = m_iFullHungerCount; 
-    }    
-    
-    protected void AddToHungerCount( int iAddedHunger )
-    {
-    	m_iHungerCountdown += iAddedHunger;
-    	
-    	// don't level up immediately when full to prevent flickering state
-    	
-    	if ( m_iHungerCountdown > m_iLevelUpHungerCount )
-    	{
-    		int iHungerLevel = GetHungerLevel();
-    		
-    		if ( iHungerLevel > 0 )
-    		{
-        		m_iHungerCountdown -= m_iFullHungerCount;
-        		
-    			SetHungerLevel( iHungerLevel - 1 );
-    		}
-    	}    	
-    }
-    
-    protected int GetGrazeHungerGain()
-    {
-    	return m_iBaseGrazeFoodValue * GetFoodValueMultiplier();
-    }
-    
-    protected int GetFoodValueMultiplier()
-    {
-    	return 2;
-    }
-    
-    public void OnGrazeBlock( int i, int j, int k )
-    {
-    	AddToHungerCount( GetGrazeHungerGain() );
-    }
-    
-    public boolean ShouldNotifyBlockOnGraze()
-    {
-    	return true;
-    }
-    
-    public void PlayGrazeFX( int i, int j, int k, int iBlockID )
-    {
-		worldObj.playAuxSFX( 2001, i, j, k, iBlockID ); 
-    }
-    
-    public int GetGrazeDuration()
-    {
-    	return 40;
-    }
-    
-    public boolean IsHungryEnoughToGraze()
-    {
-		return !IsFullyFed() || m_iHungerCountdown + GetGrazeHungerGain() <= 
-			m_iFullHungerCount;
-    }
-    
-    public boolean IsHungryEnoughToForceMoveToGraze()
-    {
-		return isChild() || !IsFullyFed() || m_iHungerCountdown < m_iFullHungerCount / 2;
-    }
-    
-    protected boolean IsTooHungryToGrow()
-    {
-    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
-    }
-    
-    protected boolean IsTooHungryToHeal()
-    {
-    	return !IsFullyFed() || m_iHungerCountdown < ( m_iFullHungerCount * 3 ) / 4;    	
-    }
-    
-    public boolean CanGrazeMycelium()
-    {
-    	return false;
-    }
-    
-    public boolean GetDisruptsEarthOnGraze()
-    {
-    	return false;
-    }
-    
-    public boolean CanGrazeOnRoughVegetation()
-    {
-    	return false;
-    }
-    
-    /**
-     * Returns null if no valid graze block exists at location
-     */    
-    public FCUtilsBlockPos GetGrazeBlockForPos()
-    {
-    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( MathHelper.floor_double( posX ), 
-    		(int)boundingBox.minY, MathHelper.floor_double( posZ ) );
-    	
-    	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
-    	{
-    		return targetPos;
-    	}
-    	else
-    	{
-    		targetPos.j--;
-    		
-        	if ( CanGrazeOnBlock( targetPos.i, targetPos.j, targetPos.k ) )
-        	{
-        		return targetPos;
-        	}
-    	}
-        
-        return null;
-    }
-    
-    public boolean ShouldStayInPlaceToGraze()
-    {
-    	return GetGrazeBlockForPos() != null;
-    }
-    
-    public boolean CanGrazeOnBlock( int i, int j, int k )
-    {
-    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
-    	
-    	if ( block != null )
-    	{
-    		return block.CanBeGrazedOn( worldObj, i, j, k, this );
-    	}
-    	
-    	return false;
-    }
-    
-    protected float GetHungerSpeedModifier()
-    {
-    	if ( IsStarving() )
-    	{
-    		return 0.5F;
-    	}
-    	else if ( IsFamished() )
-    	{
-    		return 0.75F;
-    	}
-    	
-    	return 1F;
-    }
-
-    public boolean IsTemptingItem( ItemStack stack )
-    {
-    	return GetItemFoodValue( stack ) > 0 || 
-    		( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
-    }
-    
-    public boolean IsEdibleItem( ItemStack stack )
-    {
-    	return isBreedingItem( stack ) || GetItemFoodValue( stack ) > 0;
-    }
-
-    protected boolean IsHungryEnoughToEatLooseFood()
-    {
-		return !IsFullyFed() || m_iHungerCountdown <= m_iFullHungerCount;
-    }
-    
-    protected boolean IsReadyToEatBreedingItem()
-    {
-    	return IsFullyFed() && getGrowingAge() == 0 && !isInLove();
-    }
-    
-    protected int GetItemFoodValue( ItemStack stack )
-    {
-    	return stack.getItem().GetHerbivoreFoodValue( stack.getItemDamage() ) * 
-    		GetFoodValueMultiplier();
-    }
-    
-    protected boolean AttemptToEatItemForBreeding( ItemStack stack )
-    {
-        if ( isBreedingItem( stack ) && IsReadyToEatBreedingItem() )
-        {
-        	OnEatBreedingItem();
-			
-			return true;
-        }
-        
-        return false;
-    }
-    
-    protected void OnEatBreedingItem()
-    {
-        setInLove( 600 );
-        entityToAttack = null;
-        
-        for( int iTempCount = 0; iTempCount < 7; iTempCount++ )
-        {
-            worldObj.spawnParticle( "heart", 
-            	posX + (double)( ( rand.nextFloat() * width * 2F ) - width ), 
-            	posY + 0.5D + (double)( rand.nextFloat() * height ), 
-            	posZ + (double)( ( rand.nextFloat() * width * 2.0F ) - width ), 
-        		rand.nextGaussian() * 0.02D, rand.nextGaussian() * 0.02D, 
-        		rand.nextGaussian() * 0.02D ); // last 3 are velocity
-        }
-    }
-    
-    protected boolean AttemptToEatItem( ItemStack stack )
-    {
-    	int iFoodValue = GetItemFoodValue( stack );
-    	
-		if ( AttemptToEatItemForBreeding( stack ) || ( iFoodValue > 0 && 
-			IsHungryEnoughToEatLooseFood() ) )
-		{
-        	AddToHungerCount( iFoodValue );
-            
-            worldObj.setEntityState( this, (byte)10 ); // trigger eating anim on client
-            
-	        worldObj.playAuxSFX( FCBetterThanWolves.m_iAnimalEatAuxFXID,	                
-                MathHelper.floor_double( posX ), (int)( posY + height ),
-                MathHelper.floor_double( posZ ), 0 );
-	        
-        	return true;
-		}
-		
-        return false;
-    }
-    
-    public boolean AttemptToBeHandFedItem( ItemStack stack )
-    {
-    	return AttemptToEatItem( stack );
-    }
-
-    protected boolean AttemptToEatLooseItem( ItemStack stack )
-    {
-    	return AttemptToEatItem( stack );
-    }
-    
-    public boolean IsReadyToEatLooseFood()
-    {
-    	return IsHungryEnoughToEatLooseFood() || IsReadyToEatBreedingItem();
-    }
-    
-    public boolean IsReadyToEatLooseItem( ItemStack stack )
-    {
-    	return ( GetItemFoodValue( stack ) > 0 && IsHungryEnoughToEatLooseFood() ) || 
-			( isBreedingItem( stack ) && IsReadyToEatBreedingItem() );
-    }
-    
-    protected void CheckForLooseFood()
-    {    
-    	if ( m_iEatLooseCooldownCounter > 0 )
-    	{
-    		m_iEatLooseCooldownCounter--;
-    	}
-    	else if ( IsReadyToEatLooseFood() )
-    	{
-		    List<EntityItem> entityList = worldObj.getEntitiesWithinAABB( 
-		    	EntityItem.class, AxisAlignedBB.getAABBPool().getAABB( 
-				boundingBox.minX - 1.5F, boundingBox.minY - 1F, boundingBox.minZ - 1.5F, 
-				boundingBox.maxX + 1.5F, boundingBox.maxY + 1F, boundingBox.maxZ + 1.5F ) );
-		    
-		    if ( !entityList.isEmpty() )
-		    {
-		    	Iterator<EntityItem> entityIterator = entityList.iterator();
-
-		    	while ( entityIterator.hasNext() )
-	            {
-		    		EntityItem tempEntity = entityIterator.next();
-		    		
-			        if ( tempEntity.delayBeforeCanPickup == 0 && tempEntity.isEntityAlive() )
-			        {
-			        	ItemStack tempStack = tempEntity.getEntityItem();
-			        	
-			        	if ( AttemptToEatLooseItem( tempEntity.getEntityItem() ) )
-		        		{
-			                tempStack.stackSize--;
-			                
-			                if ( tempStack.stackSize <= 0 )
-			                {
-			    	            tempEntity.setDead();					            
-			                }
-			                else
-			                {
-			                	// slight delay on pickup so animals don't all eat from a stack
-			                	// at once
-			                	
-			                	tempEntity.delayBeforeCanPickup = 2; 			                	
-			                }
-			                
-		    	            m_iEatLooseCooldownCounter = m_iDelayBetweenEatLoose +
-		    	            	rand.nextInt( m_iDelayBetweenEatLooseVariance + 1 );
-					        
-			    			break;				            
-		        		}			        		
-		    		}
-	            }
-		    }
-    	}
-    }
-    
-    public boolean EntityAnimalInteract( EntityPlayer player )
-    {
-        ItemStack heldItem = player.inventory.getCurrentItem();
-
-        if ( heldItem != null )
-        {
-        	if ( IsEdibleItem( heldItem ) )
-        	{
-	        	if ( !worldObj.isRemote && AttemptToBeHandFedItem( heldItem ) )
-	        	{
-	                heldItem.stackSize--;
-	
-	                if ( heldItem.stackSize <= 0 )
-	                {
-	                    player.inventory.setInventorySlotContents( player.inventory.currentItem, 
-	                    	null );
-	                }
-	        	}
-	        	
-	            return true;
-        	}
-        }
-        
-        return super.interact( player );
-    }
-    
-    protected int GetTicksToRegenerateLoveJuice()
-    {
-    	return FCUtilsMisc.m_iTicksPerGameDay;
-    }
-    
-    public float GetGrazeHeadVerticalOffset( float fPartialTick )
-    {
-    	int iGrazeDuration = GetGrazeDuration(); 
-		
-    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
-    	{
-            return 0F;
-    	}
-    	else if ( m_iGrazeProgressCounter >= 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
-    	{
-    		return 1F;
-    	}
-    	else if ( m_iGrazeProgressCounter < 4 )
-    	{
-    		return ( (float)m_iGrazeProgressCounter - fPartialTick ) / 4F;
-    	}
-    	else
-    	{
-            return -( (float)( m_iGrazeProgressCounter - iGrazeDuration ) - fPartialTick ) / 4F;
-    	}    	
-    }
-    
-    public float GetGrazeHeadRotation( float fPartialTick )
-    {
-    	int iGrazeDuration = GetGrazeDuration(); 
-		
-    	if ( getWearingBreedingHarness() || m_iGrazeProgressCounter <= 0 )
-    	{
-            return rotationPitch / ( 180F / (float)Math.PI );
-    	}
-    	else if ( m_iGrazeProgressCounter > 4 && m_iGrazeProgressCounter <= iGrazeDuration - 4 )
-        {
-            float fProgress = ((float)( m_iGrazeProgressCounter - 4 ) - fPartialTick ) / 
-            	(float)( iGrazeDuration - 8 );
-            
-            return ( (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor() ) + 
-            	( (float)Math.PI * 7F / 100F ) * 
-            	MathHelper.sin( fProgress * GetGrazeHeadRotationRateMultiplier() );
-        }
-        else
-        {
-            return (float)Math.PI / GetGrazeHeadRotationMagnitudeDivisor(); 
-        }
-    }
-    
-    protected float GetGrazeHeadRotationMagnitudeDivisor()
-    {
-    	return 5F;
-    }
-    
-    protected float GetGrazeHeadRotationRateMultiplier()
-    {
-    	return 28.7F;
-    }
-    
-    protected void UpdateHealing()
-    {
-    	if ( IsSubjectToHunger() && !isChild() )
-    	{
-    		if ( IsTooHungryToHeal() )
-    		{
-    			ResetHealingCountdown();
-    		}
-    		else
-    		{
-    			m_iHealingCountdown--;
-    			
-    			if ( m_iHealingCountdown <= 0 )
-    			{
-    				heal( 1 );
-    				
-        			ResetHealingCountdown();
-    			}
-    		}
-    	}
-    }
-    
-    protected void ResetHealingCountdown()
-    {
-    	m_iHealingCountdown = m_iMaxHealingCount; 
-    }    
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- EntityArrow.java	Wed Dec 19 02:30:56 2018
+++ EntityArrow.java	Fri Apr 20 22:33:10 2018
@@ -4,22 +4,12 @@
 
 public class EntityArrow extends Entity implements IProjectile
 {
-	// FCMOD: Changed to protected
-	/*
     private int xTile = -1;
     private int yTile = -1;
     private int zTile = -1;
     private int inTile = 0;
     private int inData = 0;
     private boolean inGround = false;
-    */
-    protected int xTile = -1;
-    protected int yTile = -1;
-    protected int zTile = -1;
-    protected int inTile = 0;
-    protected int inData = 0;
-    protected boolean inGround = false;
-	// END FCMOD
 
     /** 1 if the player can pick up the arrow */
     public int canBePickedUp = 0;
@@ -153,9 +143,7 @@
 
         if (var16 > 0)
         {
-        	// FCMOD: Removed due to deprecation
-            //Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
-        	// END FCMOD
+            Block.blocksList[var16].setBlockBoundsBasedOnState(this.worldObj, this.xTile, this.yTile, this.zTile);
             AxisAlignedBB var2 = Block.blocksList[var16].getCollisionBoundingBoxFromPool(this.worldObj, this.xTile, this.yTile, this.zTile);
 
             if (var2 != null && var2.isVecInside(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ)))
@@ -174,21 +162,11 @@
             int var18 = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
             int var19 = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
 
-            // FCMOD: Changed this line
-			/*
             if (var18 == this.inTile && var19 == this.inData)
-			*/
-            if (var18 == this.inTile && ( var19 == this.inData || var18 == FCBetterThanWolves.fcBlockDetector.blockID ) )
-    		// END FCMOD
             {
                 ++this.ticksInGround;
 
-                // FCMOD: Changed this to increase arrow despawn time to be same as items
-                /*
                 if (this.ticksInGround == 1200)
-                */
-                if ( ticksInGround >= 6000 )
-            	// END FCMOD
                 {
                     this.setDead();
                 }
@@ -292,12 +270,7 @@
                         var4.entityHit.setFire(5);
                     }
 
-                    // FCMOD: Line changed
-                    /*
                     if (var4.entityHit.attackEntityFrom(var22, var24))
-                    */
-	                if ( var4.entityHit.attackEntityFrom( var22, (int)((float)var24 * GetDamageMultiplier() ) ))
-	            	// END FCMOD
                     {
                         if (var4.entityHit instanceof EntityLiving)
                         {
@@ -353,9 +326,6 @@
                     this.zTile = var4.blockZ;
                     this.inTile = this.worldObj.getBlockId(this.xTile, this.yTile, this.zTile);
                     this.inData = this.worldObj.getBlockMetadata(this.xTile, this.yTile, this.zTile);
-                    // FCMOD: Added
-                    NotifyColldingBlockOfImpact();
-                    // END FCMOD
                     this.motionX = (double)((float)(var4.hitVec.xCoord - this.posX));
                     this.motionY = (double)((float)(var4.hitVec.yCoord - this.posY));
                     this.motionZ = (double)((float)(var4.hitVec.zCoord - this.posZ));
@@ -432,9 +402,6 @@
             this.setPosition(this.posX, this.posY, this.posZ);
             this.doBlockCollisions();
         }
-        // FCMOD: Added        
-        NotifyAnyCollidingBlocks();
-        // END FCMOD
     }
 
     /**
@@ -451,10 +418,6 @@
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setByte("pickup", (byte)this.canBePickedUp);
         par1NBTTagCompound.setDouble("damage", this.damage);
-        
-        // FCMOD: Added
-        par1NBTTagCompound.setShort( "fcInTileEx", (short)this.inTile );
-	    // END FCMOD    
     }
 
     /**
@@ -483,13 +446,6 @@
         {
             this.canBePickedUp = par1NBTTagCompound.getBoolean("player") ? 1 : 0;
         }
-        
-        // FCMOD: Added
-        if ( par1NBTTagCompound.hasKey( "fcInTileEx" ) )
-        {
-        	inTile = par1NBTTagCompound.getShort( "fcInTileEx" );
-        }
-	    // END FCMOD
     }
 
     /**
@@ -501,12 +457,7 @@
         {
             boolean var2 = this.canBePickedUp == 1 || this.canBePickedUp == 2 && par1EntityPlayer.capabilities.isCreativeMode;
 
-            // FCMOD: Changed line
-            /*
             if (this.canBePickedUp == 1 && !par1EntityPlayer.inventory.addItemStackToInventory(new ItemStack(Item.arrow, 1)))
-	        */
-	        if ( canBePickedUp == 1 && !AddArrowToPlayerInv( par1EntityPlayer ) )
-	    	// END FCMOD
             {
                 var2 = false;
             }
@@ -580,49 +531,4 @@
         byte var1 = this.dataWatcher.getWatchableObjectByte(16);
         return (var1 & 1) != 0;
     }
-    
-    // FCMOD: Code added
-    protected float GetDamageMultiplier()
-    {
-    	return 1F;
-    }
-    
-	protected boolean AddArrowToPlayerInv( EntityPlayer player )
-	{
-		return player.inventory.addItemStackToInventory( new ItemStack( GetCorrespondingItem(), 1 ) );
-	}
-	
-	public Item GetCorrespondingItem()
-	{
-		return Item.arrow;
-	}
-	
-	public boolean CanHopperCollect()
-	{
-		return true;
-	}
-	
-	private void NotifyAnyCollidingBlocks()
-	{
-        if ( inGround )
-        {
-            Block blockHit = Block.blocksList[inTile];
-            
-            if ( blockHit != null )
-            {
-            	blockHit.OnArrowCollide( worldObj, xTile, yTile, zTile, this );
-            }
-        }
-	}
-	
-    private void NotifyColldingBlockOfImpact()
-    {
-	    Block blockHit = Block.blocksList[inTile];
-	    
-	    if ( blockHit != null )
-	    {
-	    	blockHit.OnArrowImpact( worldObj, xTile, yTile, zTile, this );
-	    }
-    }
-	// END FCMOD
 }
--- EntityBat.java	Sun Sep 23 13:49:22 2018
+++ EntityBat.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/23/2018
-
 package net.minecraft.src;
 
 import java.util.Calendar;
--- EntityBlaze.java	Thu Sep 27 12:41:03 2018
+++ EntityBlaze.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/27/2018
-
 package net.minecraft.src;
 
 public class EntityBlaze extends EntityMob
--- EntityBoat.java	Sun Jun  3 17:52:11 2018
+++ EntityBoat.java	Fri Apr 20 22:33:10 2018
@@ -4,7 +4,6 @@
 
 public class EntityBoat extends Entity
 {
-	// FCNOTE: The following seems to be false if the boat is ridden by a player
     private boolean field_70279_a;
     private double speedMultiplier;
     private int boatPosRotationIncrements;
@@ -168,15 +167,6 @@
             }
         }
 
-        // FCMOD: Added
-        if ( var2 > 0.1F )
-        {
-        	// var 2 tracks how deep the boat is resting in the water
-            fallDistance = 0.0F;
-            extinguish();
-        }
-        // END FCMOD
-
         double var23 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
         double var6;
         double var8;
@@ -261,8 +251,6 @@
                 this.motionY += 0.007000000216066837D;
             }
 
-            // FCMOD: modify boat speed by whether player is holding a sail
-            /*
             if (this.riddenByEntity != null)
             {
                 this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
@@ -278,40 +266,6 @@
                 this.motionZ *= var8;
                 var6 = 0.35D;
             }
-            */
-            double dMaxSpeed = 0.35D;
-            
-            if ( riddenByEntity != null )
-            {
-            	dMaxSpeed *= riddenByEntity.MovementModifierWhenRidingBoat();
-            	
-                this.motionX += this.riddenByEntity.motionX * this.speedMultiplier;
-                this.motionZ += this.riddenByEntity.motionZ * this.speedMultiplier;
-                
-            	if ( riddenByEntity.AppliesConstantForceWhenRidingBoat() )
-            	{
-            		motionX -= Math.cos( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
-            		motionZ -= Math.sin( (double)rotationYaw * Math.PI / 180.0D ) * dMaxSpeed * 0.02;
-            	}
-            }
-
-            var6 = Math.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
-
-            if ( var6 > dMaxSpeed )
-            {
-                double dSpeedModifier = dMaxSpeed / var6;
-                
-                if ( dSpeedModifier < 0.9D )
-                {
-                	dSpeedModifier = 0.9D;
-                }
-                
-                motionX *= dSpeedModifier;
-                motionZ *= dSpeedModifier;
-                
-                var6 *= dSpeedModifier;
-            }
-            // END FCMOD
 
             if (var6 > var23 && this.speedMultiplier < 0.35D)
             {
@@ -343,8 +297,6 @@
 
             if (this.isCollidedHorizontally && var23 > 0.2D)
             {
-            	// FCMOD: Changed
-            	/*
                 if (!this.worldObj.isRemote && !this.isDead)
                 {
                     this.setDead();
@@ -360,9 +312,6 @@
                         this.dropItemWithOffset(Item.stick.itemID, 1, 0.0F);
                     }
                 }
-                */
-            	BreakBoat();
-            	// END FCMOD
             }
             else
             {
@@ -424,14 +373,7 @@
                         int var21 = MathHelper.floor_double(this.posY) + var20;
                         int var22 = this.worldObj.getBlockId(var27, var21, var19);
 
-                        // FCMOD: Changed
-                        /*
                         if (var22 == Block.snow.blockID)
-                        */
-                        Block tempBlock = Block.blocksList[var22];
-                        
-                        if ( tempBlock != null && tempBlock.IsGroundCover( ) )
-                        // END FCMOD
                         {
                             this.worldObj.setBlockToAir(var27, var21, var19);
                         }
@@ -537,40 +479,4 @@
     {
         return this.dataWatcher.getWatchableObjectInt(18);
     }
-    
-    // FCMOD: Code added
-    @Override
-    public boolean CanCollideWithEntity( Entity entity )
-    {
-    	return !entity.IsItemEntity();
-    }
-    
-    @Override
-    protected void fall( float fFallDistance )
-    {
-    	super.fall( fFallDistance );
-    	
-    	if ( fFallDistance > 5F )
-    	{
-    		BreakBoat();
-    	}
-    }
-    
-    public void BreakBoat()
-    {
-        if ( !worldObj.isRemote && !isDead )
-        {
-            setDead();
-
-            for ( int iCount = 0; iCount < 4; iCount++ )
-            {
-                dropItemWithOffset( Item.stick.itemID, 1, 0.0F );
-                
-                dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 1, 0.0F );
-            }
-            
-            playSound( "mob.zombie.woodbreak", 0.5F, 0.50F + ( rand.nextFloat() * 0.25F ) );
-        }
-    }
-    // END FCMOD
 }
--- EntityCaveSpider.java	Fri Jun 15 19:15:05 2018
+++ EntityCaveSpider.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 public class EntityCaveSpider extends EntitySpider
--- EntityChicken.java	Fri Aug 10 14:46:32 2018
+++ EntityChicken.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 08/10/2018
-
 package net.minecraft.src;
 
 public class EntityChicken extends EntityAnimal
@@ -143,7 +141,7 @@
         {
             this.dropItem(Item.feather.itemID, 1);
         }
-        
+
         if (this.isBurning())
         {
             this.dropItem(Item.chickenCooked.itemID, 1);
--- EntityCow.java	Mon Jul 23 21:09:40 2018
+++ EntityCow.java	Fri Apr 20 22:33:10 2018
@@ -1,11 +1,4 @@
-// FCMOD: Class changes deprecated 07/23/2018
-
 package net.minecraft.src;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.util.Iterator;
-import java.util.List;
 
 public class EntityCow extends EntityAnimal
 {
--- EntityCreature.java	Thu Jan  3 15:15:07 2019
+++ EntityCreature.java	Fri Apr 20 22:33:10 2018
@@ -1,10 +1,5 @@
 package net.minecraft.src;
 
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
-import java.util.Iterator;
-import java.util.List;
-
 public abstract class EntityCreature extends EntityLiving
 {
     private PathEntity pathToEntity;
@@ -58,25 +53,10 @@
         {
             float var2 = this.entityToAttack.getDistanceToEntity(this);
 
-            // FCMOD: Changed
-            /*
             if (this.canEntityBeSeen(this.entityToAttack))
             {
                 this.attackEntity(this.entityToAttack, var2);
             }
-            */
-            if ( ShouldContinueAttacking( var2 ) )
-        	{
-                if (this.canEntityBeSeen(this.entityToAttack))
-                {
-                    this.attackEntity(this.entityToAttack, var2);
-                }
-        	}
-            else
-            {
-                entityToAttack = null;
-            }
-            // END FCMOD
         }
         else
         {
@@ -89,12 +69,7 @@
         {
             this.pathToEntity = this.worldObj.getPathEntityToEntity(this, this.entityToAttack, var1, true, false, false, true);
         }
-        // FCMOD: Code changed to stop AI deactivating with distance
-        /*
         else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0) && this.entityAge < 100)
-        */
-        else if (!this.hasAttacked && (this.pathToEntity == null && this.rand.nextInt(180) == 0 || this.rand.nextInt(120) == 0 || this.fleeingTick > 0))
-        // END FCMOD
         {
             this.updateWanderPath();
         }
@@ -181,13 +156,6 @@
             }
 
             this.worldObj.theProfiler.endSection();
-            
-            // FCMOD: Added as the lack of super call in this condition was causing spiders 
-            // with targets to hang out for an exceedingly long time without despawning
-            entityAge++;
-            
-            despawnEntity();            
-            // END FCMOD
         }
         else
         {
@@ -314,299 +282,4 @@
 
         return var1;
     }
-    
-    // FCMOD: Added New
-    private static final int m_iIsPossessedDataWatcherID = 24;
-    
-    protected int m_iPossessionTimer = -1; // - 1 is not possessed
-    
-    @Override
-    protected void entityInit()
-    {
-    	EntityCreatureEntityInit();
-    }
-    
-    protected void EntityCreatureEntityInit()
-    {
-    	// Added to alow calling entityInit() directly regardless of class hierarchy
-    	
-        super.entityInit();
-        
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-        	dataWatcher.addObject( m_iIsPossessedDataWatcherID, new Byte( (byte)0 ) );
-        }
-    }
-    
-    @Override
-    public void writeEntityToNBT( NBTTagCompound tag )
-    {
-        super.writeEntityToNBT( tag );
-        
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-	        tag.setInteger( "fcPossessionTimer", m_iPossessionTimer );
-	        
-	        tag.setByte( "fcPossessionLevel", (byte)GetPossessionLevel() );
-        }
-    }
-
-    @Override
-    public void readEntityFromNBT( NBTTagCompound tag )
-    {
-        super.readEntityFromNBT( tag );
-        
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-	        if ( tag.hasKey( "fcPossessionTimer" ) )
-	    	{
-	        	m_iPossessionTimer = tag.getInteger( "fcPossessionTimer" );
-	        
-	        	if ( m_iPossessionTimer >= 0 )
-	        	{
-	        		SetPossessionLevel( 1 );
-	        	}
-	        	else
-	        	{
-	        		SetPossessionLevel( 0 );
-	        	}
-	    	}
-	        else
-	        {
-	        	m_iPossessionTimer = -1;
-	        	
-	    		SetPossessionLevel( 0 );
-	        }
-	        
-	        if ( tag.hasKey( "fcPossessionLevel" ) )
-	        {
-	        	SetPossessionLevel( tag.getByte( "fcPossessionLevel" ) );
-	        }
-        }
-    }
-
-    @Override
-    protected void ModSpecificOnLivingUpdate()
-    {
-    	super.ModSpecificOnLivingUpdate();
-    	
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-        	HandlePossession();
-        }
-    }
-    
-    protected boolean GetCanCreatureTypeBePossessed()
-    {
-    	return false;
-    }
-    
-    protected boolean GetCanCreatureBePossessedFromDistance( boolean bPersistentSpirit )
-    {
-        return GetCanCreatureTypeBePossessed() && isEntityAlive() && !IsPossessed();
-    }
-    
-    protected boolean IsPossessed()
-    {
-    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) != 0;    	
-    }
-    
-    protected boolean IsFullyPossessed()
-    {
-    	return GetCanCreatureTypeBePossessed() && dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) > 1;
-    }
-    
-    protected void SetPossessionLevel( int iLevel )
-    {    	
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-	    	byte byteValue = (byte)iLevel;
-	    	
-	        dataWatcher.updateObject( m_iIsPossessedDataWatcherID, Byte.valueOf( byteValue ) );
-        }
-    }
-
-    protected int GetPossessionLevel()
-    {    	
-        if ( GetCanCreatureTypeBePossessed() )
-        {
-        	return (int)( dataWatcher.getWatchableObjectByte( m_iIsPossessedDataWatcherID ) );
-        }
-        
-        return 0;
-    }
-    
-    protected int GetInitialPossessionChance()
-    {
-    	return 1000;    	
-    }
-    
-    protected int GetTimeToFullPossession()
-    {
-    	return 2400 + worldObj.rand.nextInt( 2400 ); // 2 to 4 minutes    	
-    }
-    
-    protected void OnInitialPossession()
-    {
-        worldObj.playSoundAtEntity( this, getDeathSound(), getSoundVolume(), (rand.nextFloat() - rand.nextFloat()) * 0.2F + 1.0F );
-        
-        worldObj.playAuxSFX( FCBetterThanWolves.m_iGhastMoanSoundAuxFXID, 
-        	MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );            
-    }
-    
-    protected void OnFullPossession()
-    {
-    }
-    
-    public void InitiatePossession()
-    {
-		SetPossessionLevel( 1 );
-		
-		m_iPossessionTimer = GetTimeToFullPossession();
-		
-		OnInitialPossession();	    				
-    }
-    
-    protected void HandlePossession()
-    {
-    	if ( worldObj.getWorldInfo().getGameType() == EnumGameType.CREATIVE )
-    	{
-    		return;
-    	}
-    	
-        if ( !worldObj.isRemote )
-        {
-	    	if ( !IsPossessed() )
-	    	{
-	    		if ( worldObj.provider.dimensionId == -1 ) // is nether
-	    		{
-	    			if ( worldObj.rand.nextInt( GetInitialPossessionChance() ) == 0 )
-	    			{
-	    				InitiatePossession();	    				
-	    			}
-	    		}
-	    	}
-	    	else if ( !isChild() ) // children can be possessed but it won't take full effect until they grow up
-	    	{
-	    		if ( GetPossessionLevel() == 1 )
-	    		{
-		    		m_iPossessionTimer--;
-		    		
-		    		if ( m_iPossessionTimer < 0 )
-		    		{
-		    			m_iPossessionTimer = 0;
-		    		}
-		    		
-		    		if ( m_iPossessionTimer == 0 )
-		    		{
-		    			SetPossessionLevel( 2 );
-		    			
-		    			OnFullPossession();	    			
-		    		}
-	    		}
-	    	}
-        }
-    }
-    
-    protected boolean AttemptToPossessNearbyCreature( double dRange, boolean bPersistentSpirit )
-    {    	
-        List nearbyCreatures = worldObj.getEntitiesWithinAABB( EntityCreature.class, boundingBox.expand( dRange, dRange, dRange ) );
-        
-        Iterator itemIterator = nearbyCreatures.iterator();
-    	
-        while ( itemIterator.hasNext() )
-        {
-    		EntityCreature tempCreature = (EntityCreature)itemIterator.next();
-    		
-	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( bPersistentSpirit ) && tempCreature != this )
-	        {
-	        	tempCreature.InitiatePossession();
-        		
-        		return true;
-	        }	        
-        }
-        
-    	return false;
-    }
-    
-    static public int AttemptToPossessCreaturesAroundBlock( World world, int i, int j, int k, int iPossessionCount, int iCubicRange )
-    {
-		AxisAlignedBB possessionBox = AxisAlignedBB.getAABBPool().getAABB( 
-			(double)( i - iCubicRange ), (double)( j - iCubicRange ), (double)( k - iCubicRange ),
-			(double)( i + 1 + iCubicRange ), (double)( j + 1 + iCubicRange ), (double)( k + 1 + iCubicRange ) );
-		
-        List nearbyCreatures = world.getEntitiesWithinAABB( EntityCreature.class, possessionBox );
-        
-        Iterator creatureIterator = nearbyCreatures.iterator();
-    	
-        while ( creatureIterator.hasNext() && iPossessionCount > 0 )
-        {
-        	EntityCreature tempCreature = (EntityCreature)creatureIterator.next();
-    		
-	        if ( tempCreature.GetCanCreatureBePossessedFromDistance( false ) )
-	        {
-	        	tempCreature.InitiatePossession();
-	        	
-	        	iPossessionCount--;        		
-	        }        	        
-        }    
-        
-        return iPossessionCount;
-    }    
-    
-    protected void AttemptToPossessNearbyCreatureOnDeath()
-    {
-		AttemptToPossessNearbyCreature( 16D, false );
-    }
-    
-    @Override
-    public void onDeath( DamageSource source )
-    {
-    	super.onDeath( source );
-    	
-    	// if a possessed creature dies, the spirits attempt to possess another nearby
-    	
-    	if ( !worldObj.isRemote && IsPossessed() )
-    	{
-    		if ( riddenByEntity == null || !riddenByEntity.OnPossesedRidingEntityDeath() )
-    		{
-    			AttemptToPossessNearbyCreatureOnDeath();
-    		}
-    	}
-    }
-
-    protected boolean ShouldContinueAttacking( float fDistanceToTarget )
-    {
-    	return true;
-    }
-
-    protected void TransmitAttackTargetToClients()
-    {
-        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
-        DataOutputStream dataStream = new DataOutputStream( byteStream );
-        
-        try
-        {
-	        dataStream.writeInt( entityId );
-	        dataStream.writeByte( (byte)FCBetterThanWolves.fcCustomEntityEventPacketTypeSetAttackTarget );
-
-	        if ( entityToAttack != null )
-	        {
-	        	dataStream.writeInt( entityToAttack.entityId );
-	        }
-	        else
-	        {
-	        	dataStream.writeInt( -1 );
-	        }
-        }
-        catch (Exception exception)
-        {
-            exception.printStackTrace();
-        }        
-	        
-        Packet250CustomPayload packet = new Packet250CustomPayload( FCBetterThanWolves.fcCustomPacketChannelCustomEntityEvent, byteStream.toByteArray() );
-        
-        FCUtilsWorld.SendPacketToAllPlayersTrackingEntity( (WorldServer)worldObj, this, packet );
-    }
-    // END FCMOD
 }
--- EntityCreeper.java	Fri Jun 15 19:07:14 2018
+++ EntityCreeper.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 public class EntityCreeper extends EntityMob
--- EntityDragon.java	Tue Oct 22 16:45:57 2013
+++ EntityDragon.java	Fri Apr 20 22:33:10 2018
@@ -460,31 +460,11 @@
     {
         this.forceNewTarget = false;
 
-        // FCMOD: Code added
-        boolean bTargetSelected = false;
-        // END FCMOD
-
         if (this.rand.nextInt(2) == 0 && !this.worldObj.playerEntities.isEmpty())
         {
             this.target = (Entity)this.worldObj.playerEntities.get(this.rand.nextInt(this.worldObj.playerEntities.size()));
-            
-            // FCMOD: Code added
-            long lTargetChangedDimensionTime = ((EntityPlayer)target).m_lTimeOfLastDimensionSwitch;
-            long lWorldTime = worldObj.getWorldTime();
-            
-            if ( lWorldTime < lTargetChangedDimensionTime || lWorldTime - lTargetChangedDimensionTime > m_iPlayerSwitchDimensionsGracePeriod )
-            {
-            	bTargetSelected = true;
-            }
-            // END FCMOD
         }
-        
-        // FCMOD: Code change
-        /*
         else
-        */
-        if ( !bTargetSelected )
-    	// END FCMOD
         {
             boolean var1 = false;
 
@@ -761,8 +741,4 @@
     {
         return 5.0F;
     }
-    
-    // FCMOD: Code added
-    private static final long m_iPlayerSwitchDimensionsGracePeriod = 600; // 30 seconds 
-    // END FCMOD
 }
--- EntityEgg.java	Fri Jan  4 19:49:29 2019
+++ EntityEgg.java	Fri Apr 20 22:33:10 2018
@@ -38,23 +38,12 @@
 
             for (int var3 = 0; var3 < var2; ++var3)
             {
-            	// FCMOD: Changed
-                //EntityChicken var4 = new EntityChicken(this.worldObj);
-                //var4.setGrowingAge(-24000);
-                FCEntityChicken var4 = new FCEntityChicken( worldObj );
-                var4.setGrowingAge( -var4.GetTicksForChildToGrow() );
-                // END FCMOD
+                EntityChicken var4 = new EntityChicken(this.worldObj);
+                var4.setGrowingAge(-24000);
                 var4.setLocationAndAngles(this.posX, this.posY, this.posZ, this.rotationYaw, 0.0F);
                 this.worldObj.spawnEntityInWorld(var4);
             }
         }
-        // FCMOD: Added
-        else if ( !worldObj.isRemote )
-        {
-        	FCUtilsItem.EjectSingleItemWithRandomVelocity( worldObj, (float)posX, (float)posY, (float)posZ, FCBetterThanWolves.fcItemRawEgg.itemID, 0 );
-        	
-        }
-        // END FCMOD
 
         for (int var5 = 0; var5 < 8; ++var5)
         {
--- EntityEnderman.java	Fri Mar  8 19:20:19 2019
+++ EntityEnderman.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/24/2018
-
 package net.minecraft.src;
 
 public class EntityEnderman extends EntityMob
@@ -301,14 +299,7 @@
 
                 if (this.worldObj.getCollidingBoundingBoxes(this, this.boundingBox).isEmpty() && !this.worldObj.isAnyLiquid(this.boundingBox))
                 {
-                    // FCMOD: Added
-                    Block blockBelow = Block.blocksList[worldObj.getBlockId( 
-                    	var14, var15 - 1, var16 )];
-
-                    if ( blockBelow != null && blockBelow.CanMobsSpawnOn( 
-                    	worldObj, var14, var15 - 1, var16 ) )
-                    // END FCMOD
-                    var13 = true;                    
+                    var13 = true;
                 }
             }
         }
--- EntityFireball.java	Tue Nov 27 22:36:02 2018
+++ EntityFireball.java	Fri Apr 20 22:33:10 2018
@@ -94,15 +94,6 @@
             else
             {
                 ++this.ticksInAir;
-                
-                // FCMOD: Added as fix for undying fireballs MC-4465
-                if ( ticksInAir >= 600 )
-                {
-                    setDead();
-                    
-                    return;
-                }
-                // END FCMOD
             }
 
             Vec3 var15 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
@@ -229,10 +220,6 @@
         par1NBTTagCompound.setByte("inTile", (byte)this.inTile);
         par1NBTTagCompound.setByte("inGround", (byte)(this.inGround ? 1 : 0));
         par1NBTTagCompound.setTag("direction", this.newDoubleNBTList(new double[] {this.motionX, this.motionY, this.motionZ}));
-        
-        // FCMOD: Added as fix for undying fireballs MC-4465
-        par1NBTTagCompound.setShort( "ticksInAir", (short)ticksInAir );
-        // END FCMOD        
     }
 
     /**
@@ -257,13 +244,6 @@
         {
             this.setDead();
         }
-        
-        // FCMOD: Added as fix for undying fireballs MC-4465
-        if (par1NBTTagCompound.hasKey( "ticksInAir" ) )
-        {
-        	ticksInAir = par1NBTTagCompound.getShort( "ticksInAir" );
-        }
-        // END FCMOD        
     }
 
     /**
--- EntityFishHook.java	Tue Dec 15 17:33:03 2020
+++ EntityFishHook.java	Fri Apr 20 22:33:10 2018
@@ -36,9 +36,6 @@
         super(par1World);
         this.setSize(0.25F, 0.25F);
         this.ignoreFrustumCheck = true;
-        // FCMOD: Added
-        m_bIsBaited = false;
-        // END FCMOD
     }
 
     public EntityFishHook(World par1World, EntityPlayer par2EntityPlayer)
@@ -59,9 +56,6 @@
         this.motionZ = (double)(MathHelper.cos(this.rotationYaw / 180.0F * (float)Math.PI) * MathHelper.cos(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.motionY = (double)(-MathHelper.sin(this.rotationPitch / 180.0F * (float)Math.PI) * var3);
         this.calculateVelocity(this.motionX, this.motionY, this.motionZ, 1.5F, 1.0F);
-        // FCMOD: Added
-        m_bIsBaited = false;
-        // END FCMOD
     }
 
     protected void entityInit() {}
@@ -112,15 +106,7 @@
             {
                 ItemStack var1 = this.angler.getCurrentEquippedItem();
 
-                // FCMOD: Changed
-                /*
                 if (this.angler.isDead || !this.angler.isEntityAlive() || var1 == null || var1.getItem() != Item.fishingRod || this.getDistanceSqToEntity(this.angler) > 1024.0D)
-                */
-                if ( angler.isDead || !angler.isEntityAlive() || var1 == null || 
-                	!( ( var1.getItem() == Item.fishingRod && !m_bIsBaited ) || 
-            		( var1.getItem() == FCBetterThanWolves.fcItemFishingRodBaited && m_bIsBaited ) ) ||
-                	getDistanceSqToEntity( angler ) > 1024D )
-                // END FCMOD
                 {
                     this.setDead();
                     this.angler.fishEntity = null;
@@ -291,8 +277,6 @@
                     }
                     else
                     {
-                        // FCMOD: Changed
-                        /*
                         short var28 = 500;
 
                         if (this.worldObj.canLightningStrikeAt(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY) + 1, MathHelper.floor_double(this.posZ)))
@@ -301,9 +285,6 @@
                         }
 
                         if (this.rand.nextInt(var28) == 0)
-                        */
-                        if ( CheckForBite() )
-                    	// END FCMOD
                         {
                             this.ticksCatchable = this.rand.nextInt(30) + 10;
                             this.motionY -= 0.20000000298023224D;
@@ -326,13 +307,6 @@
                                 var17 = (this.rand.nextFloat() * 2.0F - 1.0F) * this.width;
                                 this.worldObj.spawnParticle("splash", this.posX + (double)var31, (double)(var30 + 1.0F), this.posZ + (double)var17, this.motionX, this.motionY, this.motionZ);
                             }
-                            
-                            // FCMOD: Added
-                            if ( rand.nextInt( 5 ) == 0 )
-                            {
-                            	LoseBait();
-                            }
-                            // END FCMOD
                         }
                     }
                 }
@@ -410,16 +384,6 @@
             else if (this.ticksCatchable > 0)
             {
                 EntityItem var13 = new EntityItem(this.worldObj, this.posX, this.posY, this.posZ, new ItemStack(Item.fishRaw));
-            	// FCMOD: Added
-            	LoseBait();
-            	
-            	if ( this.rand.nextInt( 100 ) == 0 )
-            	{
-            		var13 = new EntityItem( worldObj, posX, posY, posZ, new ItemStack( Item.bootsLeather ) );
-            		
-            		var13.getEntityItem().setItemDamage( var13.getEntityItem().getMaxDamage() - ( 1 + this.rand.nextInt( 10 ) ) );
-            	}
-            	// END FCMOD
                 double var3 = this.angler.posX - this.posX;
                 double var5 = this.angler.posY - this.posY;
                 double var7 = this.angler.posZ - this.posZ;
@@ -430,11 +394,7 @@
                 var13.motionZ = var7 * var11;
                 this.worldObj.spawnEntityInWorld(var13);
                 this.angler.addStat(StatList.fishCaughtStat, 1);
-                // FCMOD: Removed
-                /*
                 this.angler.worldObj.spawnEntityInWorld(new EntityXPOrb(this.angler.worldObj, this.angler.posX, this.angler.posY + 0.5D, this.angler.posZ + 0.5D, this.rand.nextInt(6) + 1));
-                */
-                // END FCMOD
                 var1 = 1;
             }
 
@@ -461,123 +421,4 @@
             this.angler.fishEntity = null;
         }
     }
-    
-    // FCMOD: Added New
-    private boolean m_bIsBaited;
-    
-    public EntityFishHook( World world, EntityPlayer player, boolean bIsBaited )
-    {
-    	this( world, player );
-    	
-    	m_bIsBaited = bIsBaited;
-    }
-    
-	private void LoseBait()
-	{
-		if ( m_bIsBaited )
-		{
-			m_bIsBaited = false;
-			
-            ItemStack rodStack = angler.getCurrentEquippedItem();
-            
-            if ( rodStack != null && rodStack.getItem() == FCBetterThanWolves.fcItemFishingRodBaited )
-            {
-            	ItemStack unbaitedStack = rodStack.copy();
-            	unbaitedStack.stackSize = 1;
-            	unbaitedStack.itemID = Item.fishingRod.itemID;
-            	
-            	angler.inventory.setInventorySlotContents( angler.inventory.currentItem, unbaitedStack );
-            }
-		}
-	}
-	
-	private boolean IsBodyOfWaterLargeEnoughForFishing()
-	{
-        int i = MathHelper.floor_double( posX );
-        int j = MathHelper.floor_double( posY ) - 1;
-        int k = MathHelper.floor_double( posZ );
-
-        for ( int iTempI = i - 2; iTempI <= i + 2; iTempI++ )
-        {
-            for ( int iTempJ = j - 2; iTempJ <= j; iTempJ++ )
-            {
-                for ( int iTempK = k - 2; iTempK <= k + 2; iTempK++ )
-                {
-                	if ( !FCUtilsWorld.IsWaterSourceBlock( worldObj, iTempI, iTempJ, iTempK ) )
-            		{
-                		return false;
-            		}                		
-                }
-            }
-        }
-        
-		return true;
-	}
-
-    private boolean CheckForBite()
-    {
-    	if ( m_bIsBaited )
-    	{
-	        int iBiteOdds = 1500; // previously 1000
-	        
-	        int iTimeOfDay = (int)( worldObj.worldInfo.getWorldTime() % 24000L );
-	        
-	        if ( iTimeOfDay > 14000 && iTimeOfDay < 22000 )
-	        {
-	        	// at night
-	        	
-	        	int iMoonPhase = worldObj.getMoonPhase();
-	        	
-	        	if ( iMoonPhase == 0 )
-	        	{
-	        		iBiteOdds /= 10;
-	        	}
-	        	else
-	        	{
-	        		iBiteOdds *= 4;
-	        		
-	                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
-	                	MathHelper.floor_double( posZ ) ) )
-	                {
-		            	// in the rain
-		            	
-	                	iBiteOdds /= 2;
-	                }
-	        	}
-	        }
-	        else
-	        {
-	        	if ( iTimeOfDay < 2000 || iTimeOfDay > 22000 || 
-	        		( iTimeOfDay > 10000 && iTimeOfDay < 14000 ) ) 
-	            {
-	        		// dawn or dusk
-	        		
-	        		iBiteOdds /= 2;
-	            }
-	
-                if ( worldObj.IsPrecipitatingAtPos( MathHelper.floor_double( posX ), 
-                	MathHelper.floor_double( posZ ) ) )
-	            {
-	            	// in the rain
-	            	
-	            	iBiteOdds /= 2;
-	            }
-	        }
-	
-	        if ( rand.nextInt( iBiteOdds ) == 0 )
-	        {
-	        	if ( worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
-	        		MathHelper.floor_double( posY) + 1, MathHelper.floor_double( posZ) ) )
-	        	{	        		
-		        	if ( IsBodyOfWaterLargeEnoughForFishing() )
-		        	{
-		        		return true;
-		        	}
-	        	}
-	        }
-    	}
-    	
-    	return false;
-    }
-    // END FCMOD
 }
--- EntityGhast.java	Fri Jun 15 19:06:59 2018
+++ EntityGhast.java	Fri Apr 20 22:33:10 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 public class EntityGhast extends EntityFlying implements IMob
@@ -117,7 +115,7 @@
         if (this.targetedEntity == null || this.aggroCooldown-- <= 0)
         {
             this.targetedEntity = this.worldObj.getClosestVulnerablePlayerToEntity(this, 100.0D);
-            
+
             if (this.targetedEntity != null)
             {
                 this.aggroCooldown = 20;
@@ -202,7 +200,7 @@
                 return false;
             }
         }
-        
+
         return true;
     }
 
--- EntityHanging.java	Sun Jul  7 18:38:56 2013
+++ EntityHanging.java	Fri Apr 20 22:33:11 2018
@@ -198,12 +198,7 @@
 
                 var11 = (Entity)var10.next();
             }
-        	// FCMOD: Code change so that paintings and canvas can't overlap
-            /*
             while (!(var11 instanceof EntityHanging));
-            */
-            while (!(var11 instanceof EntityHanging) && !(var11 instanceof FCEntityCanvas));
-            // END FCMOD
 
             return false;
         }
@@ -353,12 +348,4 @@
      * Drop the item currently on this item frame.
      */
     public abstract void dropItemStack();
-    
-    // FCMOD: Code added
-    @Override
-    protected boolean ShouldSetPositionOnLoad()
-    {
-    	return false;
-    }
-    // END FCMOD
 }
--- EntityItem.java	Thu Dec 20 13:05:13 2018
+++ EntityItem.java	Fri Apr 20 22:33:11 2018
@@ -2,8 +2,6 @@
 
 import java.util.Iterator;
 
-import net.minecraft.server.MinecraftServer;
-
 public class EntityItem extends Entity
 {
     /**
@@ -79,19 +77,7 @@
         this.prevPosY = this.posY;
         this.prevPosZ = this.posZ;
         this.motionY -= 0.03999999910593033D;
-        // FCMOD: Added
-        UpdateHardcoreBuoy();
-        // END FCMOD
-        // FCMOD: Changed this to reverse Mojang's "fix" to items getting stuck in blocks
-        // and to reduce discrepancies between client and server by pushing only on server
-        /*
         this.noClip = this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
-        */
-        if ( !worldObj.isRemote )
-        {
-        	pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
-        }
-        // END FCMOD
         this.moveEntity(this.motionX, this.motionY, this.motionZ);
         boolean var1 = (int)this.prevPosX != (int)this.posX || (int)this.prevPosY != (int)this.posY || (int)this.prevPosZ != (int)this.posZ;
 
@@ -135,15 +121,10 @@
 
         ++this.age;
 
-        // FCMOD: Code change
-        /*
         if (!this.worldObj.isRemote && this.age >= 6000)
         {
             this.setDead();
         }
-        */
-        CheckForItemDespawn();
-        // END FCMOD
     }
 
     /**
@@ -257,14 +238,6 @@
         else
         {
             this.setBeenAttacked();
-	        // FCMOD: Code added
-	        if ( !worldObj.isRemote && !isDead && getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
-	        {
-	    		DetonateBlastingOil();
-	    		
-	    		return false;
-		    }
-	        // END FCMOD
             this.health -= par2;
 
             if (this.health <= 0)
@@ -288,10 +261,6 @@
         {
             par1NBTTagCompound.setCompoundTag("Item", this.getEntityItem().writeToNBT(new NBTTagCompound()));
         }
-        
-        // FCMOD: Code added
-        par1NBTTagCompound.setLong( "fcDespawnTime", m_lAbsoluteItemDespawnTime );
-	    // END FCMOD    
     }
 
     /**
@@ -304,13 +273,6 @@
         NBTTagCompound var2 = par1NBTTagCompound.getCompoundTag("Item");
         this.setEntityItemStack(ItemStack.loadItemStackFromNBT(var2));
 
-        // FCMOD: Code added
-	    if ( par1NBTTagCompound.hasKey( "fcDespawnTime" ) )
-	    {
-	    	m_lAbsoluteItemDespawnTime = par1NBTTagCompound.getLong( "fcDespawnTime" );
-	    }
-	    // END FCMOD
-	    
         if (this.getEntityItem() == null)
         {
             this.setDead();
@@ -417,343 +379,4 @@
         this.getDataWatcher().updateObject(10, par1ItemStack);
         this.getDataWatcher().setObjectWatched(10);
     }
-
-    // FCMOD: Code added
-    private long m_lAbsoluteItemDespawnTime = 0;
-    
-    private void UpdateHardcoreBuoy()
-    {
-        if ( FCBetterThanWolves.IsHardcoreBuoyEnabled( worldObj ) )
-        {
-	        int numDepthChecks = 10;
-	        double d = 0.0D;
-	        double dBoundingYOffset = 0.10D;
-	
-	        for ( int j = 0; j < numDepthChecks; j++ )
-	        {
-	            double d2 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 0) ) * ( 0.375D ) ) + dBoundingYOffset;
-	            double d8 = ( boundingBox.minY + ( ( boundingBox.maxY - boundingBox.minY) * (double)(j + 1) ) * ( 0.375D ) ) + dBoundingYOffset;
-	            
-	            AxisAlignedBB axisalignedbb = AxisAlignedBB.getAABBPool().getAABB(boundingBox.minX, d2, boundingBox.minZ, boundingBox.maxX, d8, boundingBox.maxZ);
-	
-	            if ( worldObj.isAABBInMaterial( axisalignedbb, Material.water ) )
-	            {
-	                d += 1.0D / (double)numDepthChecks;
-	            }
-	            else 
-	            {
-	            	break;
-	            }
-	        }
-	        
-	        if ( d > 0.001D )
-	        {
-	    		if ( !IsInUndertow() )
-	    		{
-		        	float fBuoyancyShifted = getEntityItem().getItem().GetBuoyancy( getEntityItem().getItemDamage() ) + 1.0F;
-		        	
-		        	// positive velocity due to boyancy
-		        	
-		        	motionY += 0.04D * fBuoyancyShifted * d;
-	    		}
-		  
-		        // drag due to being in water
-		        
-	        	motionX *= 0.90F;
-	        	motionY *= 0.90F;
-	        	motionZ *= 0.90F;	        	
-	        }	        
-        }
-    }
-
-    @Override
-    protected void doBlockCollisions()
-    {
-		//Inherited function added so that blocks like Hoppers get collision events with items on top.  
-    	// Copy of code from Entity.java, changes marked with FCMOD.
-
-        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
-        // FCMOD: code change
-        /*
-        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
-        */
-        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
-        // END FCMOD
-        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
-        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
-        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
-        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
-
-        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
-        {
-            for (int k1 = i; k1 <= l; k1++)
-            {
-                for (int l1 = j; l1 <= i1; l1++)
-                {
-                    for (int i2 = k; i2 <= j1; i2++)
-                    {
-                        int j2 = worldObj.getBlockId(k1, l1, i2);
-
-                        if (j2 > 0)
-                        {
-                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private boolean IsInUndertow()
-    {
-        int minI = MathHelper.floor_double( boundingBox.minX);
-        int maxI = MathHelper.floor_double( boundingBox.maxX + 1.0D);
-        
-        int minJ = MathHelper.floor_double( boundingBox.minY);
-        int maxJ = MathHelper.floor_double( boundingBox.maxY + 1.0D);
-        
-        int minK = MathHelper.floor_double( boundingBox.minZ);
-        int maxK = MathHelper.floor_double( boundingBox.maxZ + 1.0D );
-
-        for ( int i = minI; i < maxI; i++ )
-        {
-            for ( int j = minJ; j < maxJ; j++ )
-            {
-                for ( int k = minK; k < maxK; k++ )
-                {
-                	if ( DoesBlockHaveUndertow( i, j, k ) )
-            		{
-                		return true;
-            		}                	
-                }
-            }
-        }
-
-        return false;
-    }
-    
-    private boolean DoesBlockHaveUndertow( int i, int j, int k )
-    {
-		int iBlockID = worldObj.getBlockId( i, j, k );
-		
-		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
-		{
-			int iFluidHeight = worldObj.getBlockMetadata( i, j, k );
-			
-			if ( iFluidHeight >= 8 )
-			{
-				return true;
-			}
-	    		
-			iBlockID = worldObj.getBlockId( i, j - 1, k );
-	    		
-    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
-    		{
-    			iFluidHeight = worldObj.getBlockMetadata( i, j - 1, k );
-    			
-    			if ( iFluidHeight >= 8 )
-    			{
-    				return true;
-    			}
-    		}	    	 
-	    		
-    		iBlockID = worldObj.getBlockId( i, j + 1, k );
-    		
-    		if (  iBlockID == Block.waterMoving.blockID || iBlockID == Block.waterStill.blockID )
-    		{
-    			iFluidHeight = worldObj.getBlockMetadata( i, j + 1, k );
-    			
-    			if ( iFluidHeight >= 8 )
-    			{
-    				return true;
-    			}
-    		}	    	 
-		}
-		
-		return false;
-    }    
-    
-    @Override
-    protected void fall( float fFallDistance )
-    {
-        super.fall( fFallDistance );
-
-        if ( !worldObj.isRemote )
-        {
-	        if ( getEntityItem().getItem().itemID == FCBetterThanWolves.fcItemBlastingOil.itemID )
-	        {
-	        	if ( fFallDistance > 3F )
-	        	{
-	        		DetonateBlastingOil();
-	        	}
-		    }
-        }
-    }
-    
-    private void DetonateBlastingOil()
-    {
-		int iStackSize = getEntityItem().stackSize;
-		
-    	health = 0;
-		setDead();
-		
-		if ( iStackSize > 0 )
-		{
-			// cap the explosion size at that of TNT to avoid overly weaponzing Blasting Oil
-			
-	        float fExplosionSize = 1.5F + ( ( iStackSize - 1 ) * 2.5F / 63.0F );
-
-	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
-		}
-    }
-
-    @Override
-    protected boolean pushOutOfBlocks(double par1, double par3, double par5)
-    {
-    	// Inherited function added to revert Mojang's changes 
-
-        int var7 = MathHelper.floor_double(par1);
-        int var8 = MathHelper.floor_double(par3);
-        int var9 = MathHelper.floor_double(par5);
-        double var10 = par1 - (double)var7;
-        double var12 = par3 - (double)var8;
-        double var14 = par5 - (double)var9;
-
-        if (this.worldObj.isBlockNormalCube(var7, var8, var9))
-        {
-            boolean var16 = !this.worldObj.isBlockNormalCube(var7 - 1, var8, var9);
-            boolean var17 = !this.worldObj.isBlockNormalCube(var7 + 1, var8, var9);
-            boolean var18 = !this.worldObj.isBlockNormalCube(var7, var8 - 1, var9);
-            boolean var19 = !this.worldObj.isBlockNormalCube(var7, var8 + 1, var9);
-            boolean var20 = !this.worldObj.isBlockNormalCube(var7, var8, var9 - 1);
-            boolean var21 = !this.worldObj.isBlockNormalCube(var7, var8, var9 + 1);
-            byte var22 = -1;
-            double var23 = 9999.0D;
-
-            if (var16 && var10 < var23)
-            {
-                var23 = var10;
-                var22 = 0;
-            }
-
-            if (var17 && 1.0D - var10 < var23)
-            {
-                var23 = 1.0D - var10;
-                var22 = 1;
-            }
-
-            if (var18 && var12 < var23)
-            {
-                var23 = var12;
-                var22 = 2;
-            }
-
-            if (var19 && 1.0D - var12 < var23)
-            {
-                var23 = 1.0D - var12;
-                var22 = 3;
-            }
-
-            if (var20 && var14 < var23)
-            {
-                var23 = var14;
-                var22 = 4;
-            }
-
-            if (var21 && 1.0D - var14 < var23)
-            {
-                var23 = 1.0D - var14;
-                var22 = 5;
-            }
-
-            float var25 = this.rand.nextFloat() * 0.2F + 0.1F;
-
-            if (var22 == 0)
-            {
-                this.motionX = (double)(-var25);
-            }
-
-            if (var22 == 1)
-            {
-                this.motionX = (double)var25;
-            }
-
-            if (var22 == 2)
-            {
-                this.motionY = (double)(-var25);
-            }
-
-            if (var22 == 3)
-            {
-                this.motionY = (double)var25;
-            }
-
-            if (var22 == 4)
-            {
-                this.motionZ = (double)(-var25);
-            }
-
-            if (var22 == 5)
-            {
-                this.motionZ = (double)var25;
-            }
-
-            return true;
-        }
-        else
-        {
-            return false;
-        }
-    }
-    
-    @Override
-    public boolean IsItemEntity()
-    {
-    	return true;
-    }
-    
-    @Override
-    public boolean CanEntityTriggerTripwire()
-    {
-    	return false;
-    }
-    
-    private void CheckForItemDespawn()
-    {
-        if ( !worldObj.isRemote )
-        {
-	        if ( m_lAbsoluteItemDespawnTime > 0 )
-	        {
-	        	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
-	        	
-				long lOverworldTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime();
-				
-				if ( lOverworldTime >= m_lAbsoluteItemDespawnTime  )
-				{
-					setDead();
-				}				
-	        }
-	        else
-	        {
-		        if ( age >= 6000 )
-		        {
-		            setDead();
-		        }
-	        }
-        }
-    }
-    
-    public void SetEntityItemAsDroppedOnPlayerDeath( EntityPlayer player )
-    {
-    	// set items dropped on player death to despawn 1 Minecraft day (20 minutes) later
-    	// using getTotalWorldTime() here so that /time commands and time advancement due to HC Spawn don't affect it
-    	
-    	m_lAbsoluteItemDespawnTime = MinecraftServer.getServer().worldServers[0].getTotalWorldTime() + 24000L;
-    }    
-    
-    static public boolean InstallationIntegrityTestEntityItem()
-    {
-    	return true;
-    }
-    // END FCMOD    
 }
--- EntityLightningBolt.java	Tue Nov 20 14:18:22 2018
+++ EntityLightningBolt.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 11/20/2018
-
 package net.minecraft.src;
 
 import java.util.List;
--- EntityList.java	Fri May  4 13:30:08 2018
+++ EntityList.java	Fri Apr 20 22:33:11 2018
@@ -27,12 +27,7 @@
     /**
      * adds a mapping between Entity classes and both a string representation and an ID
      */
-    // FCMOD: Code change
-    /*
     private static void addMapping(Class par0Class, String par1Str, int par2)
-    */
-    public static void addMapping(Class par0Class, String par1Str, int par2)
-    // END FCMOD
     {
         stringToClassMapping.put(par1Str, par0Class);
         classToStringMapping.put(par0Class, par1Str);
@@ -246,56 +241,4 @@
         addMapping(EntityVillager.class, "Villager", 120, 5651507, 12422002);
         addMapping(EntityEnderCrystal.class, "EnderCrystal", 200);
     }
-    
-    // FCMOD: Added    
-    public static void AddMapping( Class entityClass, String sName, int iID )
-    {
-    	addMapping( entityClass, sName, iID );
-    }
-    
-    public static boolean RemoveMapping( String sName, boolean bRemoveEgg )
-    {
-    	Integer iID = (Integer)stringToIDMapping.get( sName );
-    		
-    	if ( iID != null )
-    	{
-	    	Class mappedClass = (Class)IDtoClassMapping.get( Integer.valueOf( iID ) );
-	    	
-	    	if ( mappedClass != null )
-	    	{
-	    		stringToClassMapping.remove( sName );
-	    		classToStringMapping.remove( mappedClass );
-	    		IDtoClassMapping.remove( iID );
-	    		classToIDMapping.remove( mappedClass );
-	    		stringToIDMapping.remove( sName );
-	    		
-	    		if ( bRemoveEgg )
-	    		{
-		    		// may or may not have an egg, but this is a safe operation
-	    			
-	    			entityEggs.remove( iID );
-	    		}
-	    		
-	    		return true;
-	    	}
-    	}
-    	
-    	return false;
-    }
-    
-    public static boolean ReplaceExistingMapping( Class newClass, String sName )
-    {    	
-    	Integer iID = (Integer)stringToIDMapping.get( sName );
-		
-    	if ( iID != null )
-    	{
-    		if ( RemoveMapping( sName, false ) ) // egg mapping intentionally left in place
-    		{    		
-    			addMapping( newClass, sName, iID );
-    		}
-    	}
-    	
-    	return false;
-    }
-    // END FCMOD
 }
--- EntityLiving.java	Sun Nov 22 13:20:30 2020
+++ EntityLiving.java	Fri Apr 20 22:33:11 2018
@@ -12,36 +12,16 @@
      * An array of probabilities that determines whether a random enchantment should be added to the held item. Indexed
      * by difficulty.
      */
-	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
-	/*
     private static final float[] enchantmentProbability = new float[] {0.0F, 0.0F, 0.1F, 0.2F};
-    */
-    private static final float[] enchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
-    // END FCMOD
 
     /** Probability to get enchanted armor */
-	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
-	/*
     private static final float[] armorEnchantmentProbability = new float[] {0.0F, 0.0F, 0.25F, 0.5F};
-    */
-    private static final float[] armorEnchantmentProbability = new float[] {0.05F, 0.05F, 0.05F, 0.05F};
-    // END FCMOD
 
     /** Probability to get armor */
-	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
-    /*
     private static final float[] armorProbability = new float[] {0.0F, 0.0F, 0.05F, 0.07F};
-    */
-    private static final float[] armorProbability = new float[] {0.0025F, 0.0025F, 0.0025F, 0.0025F};
-    // END FCMOD
 
     /** Probability to pick up loot */
-	// FCMOD: Changed to unify accross difficulty levels and to adjust for balance
-    /*
     public static final float[] pickUpLootProability = new float[] {0.0F, 0.1F, 0.15F, 0.45F};
-    */
-    public static final float[] pickUpLootProability = new float[] {0.15F, 0.15F, 0.15F, 0.15F};
-    // END FCMOD
     public int maxHurtResistantTime = 20;
     public float field_70769_ao;
     public float field_70770_ap;
@@ -117,15 +97,10 @@
     public float prevCameraPitch;
     public float cameraPitch;
 
-    // FCMOD: Changed for clarity with Entity.isDead.
-    /*
-    protected boolean dead = false;
-    */
     /**
-     * Tells if a creature has shed its mortal coil.  Entity.isDead is whether an entity is flagged to be removed from the game
+     * This gets set on entity death, but never used. Looks like a duplicate of isDead
      */
-    protected boolean isLivingDead = false;
-    // END FCMOD
+    protected boolean dead = false;
 
     /** The experience points the Entity gives. */
     protected int experienceValue;
@@ -150,14 +125,8 @@
     protected int recentlyHit = 0;
 
     /** is only being set, has no uses as of MC 1.1 */
-    // FCMOD: Changed to public
-    /*
     private EntityLiving entityLivingToAttack = null;
     private int revengeTimer = 0;
-    */
-    public EntityLiving entityLivingToAttack = null;
-    public int revengeTimer = 0;
-    // END FCMOD
     private EntityLiving lastAttackingEntity = null;
     public int arrowHitTimer = 0;
     protected HashMap activePotionsMap = new HashMap();
@@ -272,10 +241,6 @@
         }
 
         this.stepHeight = 0.5F;
-        
-        // FCMOD: Code added to prevent all living sounds playing very rapidly as entities are loaded (was particularly noticeable with ghasts)
-        livingSoundTime = -getTalkInterval();
-        // END FCMOD
     }
 
     protected int func_96121_ay()
@@ -363,11 +328,8 @@
 
     public boolean attackEntityAsMob(Entity par1Entity)
     {
-        // FCMOD: Changed
-        //this.setLastAttackingEntity(par1Entity);
-        //return false;
-        return MeleeAttack( par1Entity );
-        // END FCMOD
+        this.setLastAttackingEntity(par1Entity);
+        return false;
     }
 
     /**
@@ -382,13 +344,6 @@
      * Sets the active target the Task system uses for tracking
      */
     public void setAttackTarget(EntityLiving par1EntityLiving)
-    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingSetAttackTarget(par1EntityLiving);
-    }
-    
-    protected void EntityLivingSetAttackTarget(EntityLiving par1EntityLiving)
-    // END FCMOD
     {
         this.attackTarget = par1EntityLiving;
     }
@@ -398,12 +353,7 @@
      */
     public boolean canAttackClass(Class par1Class)
     {
-    	// FCMOD: Changed
-    	/*
         return EntityCreeper.class != par1Class && EntityGhast.class != par1Class;
-        */
-        return FCEntityCreeper.class != par1Class && FCEntityGhast.class != par1Class;
-        // END FCMOD
     }
 
     /**
@@ -506,14 +456,10 @@
     /**
      * returns true if the entity provided in the argument can be seen. (Raytrace)
      */
-	// FCMOD: Code removed and replaced later so that entities can be seen through blocks that don't stop movement
-	/*
     public boolean canEntityBeSeen(Entity par1Entity)
     {
         return this.worldObj.rayTraceBlocks(this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY + (double)this.getEyeHeight(), this.posZ), this.worldObj.getWorldVec3Pool().getVecFromPool(par1Entity.posX, par1Entity.posY + (double)par1Entity.getEyeHeight(), par1Entity.posZ)) == null;
     }
-    */
-    // END FCMOD
 
     /**
      * Returns true if other Entities should be prevented from moving through this Entity.
@@ -607,12 +553,7 @@
         }
         else
         {
-        	// FCMOD: Code change for players to recover air gradually
-        	/*
             this.setAir(300);
-            */
-        	RecoverAirSupply();
-        	// END FCMOD
         }
 
         this.prevCameraPitch = this.cameraPitch;
@@ -667,13 +608,6 @@
             }
         }
 
-        // FCMOD: Added to prevent problems with the AI sometimes going into limbo due to dead targets 
-        if ( attackTarget != null && !attackTarget.isEntityAlive() )
-        {
-    		setAttackTarget( null );
-        }
-        // END FCMOD
-
         this.updatePotionEffects();
         this.field_70763_ax = this.field_70764_aw;
         this.prevRenderYawOffset = this.renderYawOffset;
@@ -705,17 +639,6 @@
                     this.worldObj.spawnEntityInWorld(new EntityXPOrb(this.worldObj, this.posX, this.posY, this.posZ, var2));
                 }
             }
-            // FCMOD: Code added to spawn Dragon Orbs when the creature is not killed by a player
-            else if (!worldObj.isRemote && !isChild())
-	        {
-            	int iExperienceDropped = getExperiencePoints(attackingPlayer);
-
-            	if ( iExperienceDropped > 0 )
-            	{
-            		worldObj.spawnEntityInWorld(new EntityXPOrb(worldObj, posX, posY, posZ, getExperiencePoints(attackingPlayer), true ) );
-            	}
-	        }
-	        // END FCMOD
 
             this.setDead();
 
@@ -1010,12 +933,6 @@
             }
             else
             {
-            	// FCMOD: Code added
-            	if ( par1DamageSource == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
-        		{
-            		m_iRecentlyOnChoppingBlockCountdown = m_iOnChoppingBlockMaxCountdown;
-            	}
-            	// END FCMOD
                 if ((par1DamageSource == DamageSource.anvil || par1DamageSource == DamageSource.fallingBlock) && this.getEquipmentInSlot(4) != null)
                 {
                     this.getEquipmentInSlot(4).damageItem(par2 * 4 + this.rand.nextInt(par2 * 2), this);
@@ -1092,9 +1009,6 @@
                         }
 
                         this.attackedAtYaw = (float)(Math.atan2(var7, var9) * 180.0D / Math.PI) - this.rotationYaw;
-                        // FCMOD: Added to limit knockback with crappy weapons
-                        if ( par2 > 1 || var4.isSprinting() )
-                    	// END FCMOD
                         this.knockBack(var4, par2, var9, var7);
                     }
                     else
@@ -1270,10 +1184,7 @@
     {
         this.isAirBorne = true;
         float var7 = MathHelper.sqrt_double(par3 * par3 + par5 * par5);
-        // FCMOD: Changed
-        //float var8 = 0.4F;
-        float var8 = KnockbackMagnitude();
-        // END FCMOD
+        float var8 = 0.4F;
         this.motionX /= 2.0D;
         this.motionY /= 2.0D;
         this.motionZ /= 2.0D;
@@ -1290,8 +1201,6 @@
     /**
      * Called when the mob's health reaches 0.
      */
-    // FCMOD: Function removed and replaced by custom one below
-    /*
     public void onDeath(DamageSource par1DamageSource)
     {
         Entity var2 = par1DamageSource.getEntity();
@@ -1337,8 +1246,6 @@
 
         this.worldObj.setEntityState(this, (byte)3);
     }
-    */
-    // END FCMOD
 
     protected void dropRareDrop(int par1) {}
 
@@ -1346,13 +1253,6 @@
      * Drop 0-2 items of this living's type
      */
     protected void dropFewItems(boolean par1, int par2)
-    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingDropFewItems( par1, par2 );
-    }
-    
-    protected void EntityLivingDropFewItems(boolean par1, int par2)
-    // END FCMOD
     {
         int var3 = this.getDropItemId();
 
@@ -1384,13 +1284,6 @@
      * Called when the mob is falling. Calculates and applies fall damage.
      */
     protected void fall(float par1)
-    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingFall(par1);
-    }
-    
-    protected void EntityLivingFall(float par1)
-    // END FCMOD
     {
         super.fall(par1);
         int var2 = MathHelper.ceiling_float_int(par1 - 3.0F);
@@ -1434,12 +1327,6 @@
             this.motionZ *= 0.800000011920929D;
             this.motionY -= 0.02D;
 
-            // FCMOD: Code added to apply move penalties in water
-            float fModifier = GetSwimmingHorizontalModifier();
-            motionX *= fModifier;
-            motionZ *= fModifier;
-            // END FCMOD
-
             if (this.isCollidedHorizontally && this.isOffsetPositionInLiquid(this.motionX, this.motionY + 0.6000000238418579D - this.posY + var9, this.motionZ))
             {
                 this.motionY = 0.30000001192092896D;
@@ -1466,25 +1353,12 @@
 
             if (this.onGround)
             {
-            	// FCMOD: Changed
-            	/*
                 var3 = 0.54600006F;
                 int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
-                */
-            	var3 = GetDefaultSlipperinessOnGround();
-                int var4 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
-                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
-                	MathHelper.floor_double(this.posZ));
-            	// END FCMOD
 
                 if (var4 > 0)
                 {
-                	// FCMOD: Changed
-                	/*
                     var3 = Block.blocksList[var4].slipperiness * 0.91F;
-                    */
-                	var3 = GetSlipperinessRelativeToBlock( var4 ) * 0.91F;
-                	// END FCMOD
                 }
             }
 
@@ -1514,25 +1388,12 @@
 
             if (this.onGround)
             {
-            	// FCMOD: Changed
-            	/*
                 var3 = 0.54600006F;
                 int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
-                */
-            	var3 = GetDefaultSlipperinessOnGround();
-                int var6 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), 
-                	MathHelper.floor_double(this.boundingBox.minY - 0.25F), // reduced from full block offset above to not slip on partial blocks like slabs 
-                	MathHelper.floor_double(this.posZ));
-            	// END FCMOD
 
                 if (var6 > 0)
                 {
-                	// FCMOD: Changed
-                	/*
                     var3 = Block.blocksList[var6].slipperiness * 0.91F;
-                    */
-                	var3 = GetSlipperinessRelativeToBlock( var6 );
-                	// END FCMOD
                 }
             }
 
@@ -1573,10 +1434,6 @@
                 {
                     this.motionY = 0.0D;
                 }
-                // FCMOD: Code added to apply move penalties on ladders                
-                float fModifier = GetLadderVerticalMovementModifier();
-                motionY *= fModifier;
-                // END FCMOD
             }
 
             this.moveEntity(this.motionX, this.motionY, this.motionZ);
@@ -1624,8 +1481,6 @@
     /**
      * returns true if this entity is by a ladder, false otherwise
      */
-    // FCMOD: Removed and replaced later
-    /*
     public boolean isOnLadder()
     {
         int var1 = MathHelper.floor_double(this.posX);
@@ -1634,8 +1489,6 @@
         int var4 = this.worldObj.getBlockId(var1, var2, var3);
         return var4 == Block.ladder.blockID || var4 == Block.vine.blockID;
     }
-    */
-    // END FCMOD
 
     /**
      * (abstract) Protected helper method to write subclass entity data to NBT.
@@ -1784,13 +1637,6 @@
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
-    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingOnLivingUpdate();
-    }
-    
-    protected void EntityLivingOnLivingUpdate()
-    // END FCMOD
     {
         if (this.jumpTicks > 0)
         {
@@ -1862,19 +1708,9 @@
 
         if (this.isJumping)
         {
-        	// FCMOD: Line change
-        	/*
             if (!this.isInWater() && !this.handleLavaMovement())
-            */
-            if ( ( !this.isInWater() && !this.handleLavaMovement() ) || !CanSwim() )
-        	// END FCMOD
             {
-            	// FCMOD: Changed
-            	/*
                 if (this.onGround && this.jumpTicks == 0)
-                */
-                if ( CanJump() && ( onGround || CanJumpMidWater() ) && this.jumpTicks == 0)
-        		// END FCMOD            		
                 {
                     this.jump();
                     this.jumpTicks = 10;
@@ -1910,12 +1746,7 @@
         this.worldObj.theProfiler.endSection();
         this.worldObj.theProfiler.startSection("looting");
 
-        // FCMOD: Changed for "isLivingDead"
-        /*
         if (!this.worldObj.isRemote && this.canPickUpLoot() && !this.dead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
-        */
-        if (!this.worldObj.isRemote && this.canPickUpLoot() && !isLivingDead && this.worldObj.getGameRules().getGameRuleBooleanValue("mobGriefing"))
-        // END FCMOD
         {
             List var2 = this.worldObj.getEntitiesWithinAABB(EntityItem.class, this.boundingBox.expand(1.0D, 0.0D, 1.0D));
             Iterator var12 = var2.iterator();
@@ -2004,9 +1835,6 @@
         }
 
         this.worldObj.theProfiler.endSection();
-        // FCMOD: Added
-        ModSpecificOnLivingUpdate();
-        // END FCMOD
     }
 
     protected void func_85033_bc()
@@ -2042,7 +1870,6 @@
 
     /**
      * Returns whether the entity is in a local (client) world
-     * FCNOTE: This is horribly named.  For everything other than EntityPlayerSP, this returns true if !world.isRemote
      */
     protected boolean isClientWorld()
     {
@@ -2074,12 +1901,7 @@
             this.motionY += (double)((float)(this.getActivePotionEffect(Potion.jump).getAmplifier() + 1) * 0.1F);
         }
 
-        // FCMOD: Changed to avoid jump exploit in shallow water while weighted
-		/*
         if (this.isSprinting())
-		*/
-        if (isSprinting() && !isInWater())
-    	// END FCMOD
         {
             float var1 = this.rotationYaw * 0.017453292F;
             this.motionX -= (double)(MathHelper.sin(var1) * 0.2F);
@@ -2100,8 +1922,6 @@
     /**
      * Makes the entity despawn if requirements are reached
      */
-    // FCMOD: Removed and replaced
-    /*
     protected void despawnEntity()
     {
         if (!this.persistenceRequired)
@@ -2131,17 +1951,8 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     protected void updateAITasks()
-    // FCMOD: Added to allow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingUpdateAITasks();
-    }
-    
-    protected void EntityLivingUpdateAITasks()
-    // END FCMOD
     {
         ++this.entityAge;
         this.worldObj.theProfiler.startSection("checkDespawn");
@@ -2447,12 +2258,6 @@
 
         if (var12 > 0)
         {
-            // FCMOD: Code added to not display potion particles if all effects come from beacons        
-            if ( HasOnlyAmbientPotionEffects( activePotionsMap.values() ) )
-            {
-            	return;
-            }
-            // END FCMOD
             boolean var4 = false;
 
             if (!this.isInvisible())
@@ -2541,8 +2346,6 @@
 
     public boolean isPotionApplicable(PotionEffect par1PotionEffect)
     {
-    	// FCMOD: Code removed to get rid of undead special casing on potion use
-    	/*
         if (this.getCreatureAttribute() == EnumCreatureAttribute.UNDEAD)
         {
             int var2 = par1PotionEffect.getPotionID();
@@ -2552,8 +2355,6 @@
                 return false;
             }
         }
-        */
-    	// END FCMOD
 
         return true;
     }
@@ -2598,8 +2399,6 @@
      * This method returns a value to be applied directly to entity speed, this factor is less than 1 when a slowdown
      * potion effect is applied, more than 1 when a haste potion effect is applied and 2 for fleeing entities.
      */
-    // FCMOD: Function removed and replaced later
-    /*
     public float getSpeedModifier()
     {
         float var1 = 1.0F;
@@ -2621,8 +2420,6 @@
 
         return var1;
     }
-    */
-    // END FCMOD
 
     /**
      * Sets the position of the entity and updates the 'last' variables
@@ -2676,8 +2473,6 @@
         }
         else
         {
-        	// FCTODO: As far as I can tell, the following code can never be anything other than zero unless health is greater than max health (which shouldn't happen), 
-        	// and thus has no effect.  Figure out what's going on here and if difficulty actually impacts anything.
             int var1 = (int)((float)this.health - (float)this.getMaxHealth() * 0.33F);
             var1 -= (3 - this.worldObj.difficultySetting) * 4;
 
@@ -2742,9 +2537,6 @@
                 if (!var5 && var4.isItemStackDamageable())
                 {
                     int var6 = Math.max(var4.getMaxDamage() - 25, 1);
-                    // FCMOD: Code added to provide a better range on damage
-                    var6 = Math.max( (int)((float)var4.getMaxDamage() * 0.95F), 1);
-                    // END FCMOD
                     int var7 = var4.getMaxDamage() - this.rand.nextInt(this.rand.nextInt(var6) + 1);
 
                     if (var7 > var6)
@@ -2769,23 +2561,12 @@
      * Makes entity wear random armor based on difficulty
      */
     protected void addRandomArmor()
-    // FCMOD: Added to alow calling this method directly regardless of class hierarchy
-    {
-    	EntityLivingAddRandomArmor();
-    }
-    
-    protected void EntityLivingAddRandomArmor()
-    // END FCMOD
     {
         if (this.rand.nextFloat() < armorProbability[this.worldObj.difficultySetting])
         {
             int var1 = this.rand.nextInt(2);
             float var2 = this.worldObj.difficultySetting == 3 ? 0.1F : 0.25F;
 
-            // FCMOD: Code added to make armor drop rate equal on all difficulty levels
-            var2 = 0.1F;
-            // END FCMOD
-
             if (this.rand.nextFloat() < 0.095F)
             {
                 ++var1;
@@ -2817,10 +2598,6 @@
                     if (var5 != null)
                     {
                         this.setCurrentItemOrArmor(var3 + 1, new ItemStack(var5));
-                        
-                        // FCMOD: Code added to increase armor drop on mobs
-                        equipmentDropChances[var3 + 1] = 0.75F;
-                        // END FCMOD
                     }
                 }
             }
@@ -2886,8 +2663,6 @@
     /**
      * Params: Armor slot, Item tier
      */
-    // FCMOD: Function removed and replaced by custom one below
-    /*
     public static Item getArmorItemForSlot(int par0, int par1)
     {
         switch (par0)
@@ -2984,19 +2759,12 @@
                 return null;
         }
     }
-    */
-    // END FCMOD
 
     protected void func_82162_bC()
     {
         if (this.getHeldItem() != null && this.rand.nextFloat() < enchantmentProbability[this.worldObj.difficultySetting])
         {
-        	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
-        	/*
             EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
-            */
-            EnchantmentHelper.addRandomEnchantment(this.rand, this.getHeldItem(), 7 * this.rand.nextInt(6));
-        	// END FCMOD
         }
 
         for (int var1 = 0; var1 < 4; ++var1)
@@ -3005,12 +2773,7 @@
 
             if (var2 != null && this.rand.nextFloat() < armorEnchantmentProbability[this.worldObj.difficultySetting])
             {
-            	// FCMOD: Code change to make enchant strength on mob drops uniform accross difficulty levels
-            	/*
                 EnchantmentHelper.addRandomEnchantment(this.rand, var2, 5 + this.worldObj.difficultySetting * this.rand.nextInt(6));
-                */
-                EnchantmentHelper.addRandomEnchantment(this.rand, var2, 7 * this.rand.nextInt(6));
-            	// END FCMOD
             }
         }
     }
@@ -3018,10 +2781,6 @@
     /**
      * Initialize this creature.
      */
-    /**
-     * FCNOTE: this function is only called when creatures spawn into the world, NOT
-     * when they are birthed or loaded.
-     */
     public void initCreature() {}
 
     /**
@@ -3128,603 +2887,8 @@
         this.canPickUpLoot = par1;
     }
 
-    // FCMOD: Changed for clarity
-    //public boolean func_104002_bU()
-    public boolean GetIsPersistent()
-    // END FCMOD
+    public boolean func_104002_bU()
     {
         return this.persistenceRequired;
     }
-
-    // FCMOD: Added New
-    private int m_iRecentlyOnChoppingBlockCountdown = 0;
-    
-    public static final int m_iOnChoppingBlockMaxCountdown = 40;
-    
-    public boolean isOnLadder()
-    {
-        int i = MathHelper.floor_double( posX );
-        int j = MathHelper.floor_double( boundingBox.minY );
-        int k = MathHelper.floor_double( posZ );
-        
-        Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
-        
-    	return block != null && block.IsBlockClimbable( worldObj, i, j, k );  
-    }
-    
-    protected void ModSpecificOnLivingUpdate()
-    {
-    	if ( m_iRecentlyOnChoppingBlockCountdown > 0 )
-    	{
-    		m_iRecentlyOnChoppingBlockCountdown--;
-    	}
-    }    
-    
-    public float getSpeedModifier()
-    {
-        float fMoveSpeed = 1.0F;
-
-        if (this.isPotionActive(Potion.moveSlowdown))
-        {
-            fMoveSpeed *= 1.0F - 0.15F * (float)(this.getActivePotionEffect(Potion.moveSlowdown).getAmplifier() + 1);
-        }
-
-        if ( onGround && IsAffectedByMovementModifiers() )
-        {
-        	int iGroundI = MathHelper.floor_double( posX );
-        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
-        	int iGroundK = MathHelper.floor_double( posZ );
-        	
-        	if ( FCUtilsWorld.IsGroundCoverOnBlock( worldObj, iGroundI, iGroundJ, iGroundK ) )
-        	{
-        		fMoveSpeed *= 0.8F;
-        	}
-        	
-        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-        	
-        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-        	{
-        		float fHalfWidth = width / 2F;
-        		
-        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
-
-        		int iCenterGroundI = iGroundI;
-        		
-        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
-	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-	        	
-	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-	        	{
-	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
-		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-		        	
-		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-		        	{
-		        		iGroundI = iCenterGroundI;
-		        		
-		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
-			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-			        	
-			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-			        	{
-			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
-				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
-			        	}
-		        	}
-	        	}	        	
-        	}
-        	
-        	if ( blockOn != null )
-        	{
-        		fMoveSpeed *= blockOn.GetMovementModifier( worldObj, iGroundI, iGroundJ, iGroundK );        		
-        	}
-        	
-        	fMoveSpeed *= GetLandMovementModifier();
-        }
-        
-        if ( fMoveSpeed < 0.0F)
-        {
-            fMoveSpeed = 0.0F;
-        }
-
-        return fMoveSpeed;
-    }
-    
-    protected float GetHealthAndExhaustionModifier()
-    {
-    	return 1.0F;
-    }
-    
-    protected float GetSwimmingHorizontalModifier()
-    {
-    	return GetHealthAndExhaustionModifier();
-    }
-    
-    protected float GetLandMovementModifier()
-    {
-    	return GetHealthAndExhaustionModifier();
-    }
-    
-    protected float GetLadderVerticalMovementModifier()
-    {
-    	return GetHealthAndExhaustionModifier();
-    }
-    
-    public static Item getArmorItemForSlot(int par0, int par1)
-    {
-        switch (par0)
-        {
-            case 4:
-            	
-                if ( par1 == 4 )
-                {
-                    return Item.helmetChain;
-                }
-                else
-                {
-                    return Item.helmetIron;
-                }
-
-            case 3:
-
-                if (par1 == 4)
-                {
-                    return Item.plateChain;
-                }
-                else
-                {
-                    return Item.plateIron;
-                }
-
-            case 2:
-
-                if (par1 == 4)
-                {
-                    return Item.legsChain;
-                }
-                else
-                {
-                    return Item.legsIron;
-                }
-
-            case 1:
-
-                if (par1 == 4)
-                {
-                    return Item.bootsChain;
-                }
-                else
-                {
-                    return Item.bootsIron;
-                }
-
-            default:
-            	
-                return null;
-        }
-    }
-    
-    public void onDeath( DamageSource source )
-    {
-    	EntityLivingOnDeath( source );
-    }
-    
-    public void EntityLivingOnDeath( DamageSource source )
-    {
-        EntityLiving killCreditedEntity = this.func_94060_bK();
-
-        if (this.scoreValue >= 0 && killCreditedEntity != null)
-        {
-            killCreditedEntity.addToPlayerScore(this, this.scoreValue);
-        }
-
-        Entity sourceEntity = source.getEntity();
-
-        if ( sourceEntity != null )
-        {
-            sourceEntity.onKillEntity( this );
-        }
-
-        isLivingDead = true;
-
-        if ( !worldObj.isRemote )
-        {
-            if ( !isChild() && worldObj.getGameRules().getGameRuleBooleanValue( "doMobLoot" ) )
-            {
-                int iLootingModifier = GetAmbientLootingModifier();
-
-                if ( sourceEntity instanceof EntityPlayer )
-                {
-                    int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
-                    
-                    if ( iPlayerLootingModifier > iLootingModifier )
-                    {
-                    	iLootingModifier = iPlayerLootingModifier;
-                    }
-                }
-
-                dropFewItems( true, iLootingModifier);
-                dropEquipment( true, iLootingModifier);
-                
-                CheckForRareDrop( source, iLootingModifier );
-
-                CheckForHeadDrop( source, iLootingModifier );
-                
-            	if ( worldObj.getWorldInfo().getGameType() != EnumGameType.CREATIVE )
-            	{
-            		CheckForScrollDrop();
-            	}
-            }
-        }
-
-        this.worldObj.setEntityState(this, (byte)3);
-    }
-
-    protected void CheckForRareDrop( DamageSource source, int iLootingModifier )
-    {
-        int iChance = rand.nextInt(800) - ( iLootingModifier * 4 );
-
-        if ( iChance < 5 )
-        {
-            dropRareDrop( iChance <= 0 ? 1 : 0 );
-        }        
-    }
-    
-    public void CheckForScrollDrop()
-    {
-    }
-    
-    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
-    {
-        Entity sourceEntity = source.getEntity();
-
-        int iHeadChance = rand.nextInt(200);
-        
-        if ( sourceEntity instanceof EntityPlayer )
-        {
-            iHeadChance -= iLootingModifier;
-            
-        	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
-        		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
-        	{
-        		iHeadChance = iHeadChance >> 2;
-    		}
-		}
-        else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock || m_iRecentlyOnChoppingBlockCountdown > 0 )
-        {
-    		iHeadChance = iHeadChance >> 2;
-        }
-        
-        if ( iHeadChance < 5 )
-        {
-            dropHead();
-        }   
-    }
-    
-    protected int GetAmbientLootingModifier()
-    {
-    	int iLocI = MathHelper.floor_double( posX );
-    	int iLocJ = MathHelper.floor_double( posY );
-    	int iLocK = MathHelper.floor_double( posZ );
-    	
-    	return worldObj.GetAmbientLootingEffectAtLocation( iLocI, iLocJ, iLocK );
-    }
-    
-    protected void dropHead()
-    {
-    }
-    
-    public boolean CanJump()
-    {
-    	return true;
-    }
-    
-    public boolean CanSwim()
-    {
-    	return !isWeighted();
-    }
-    
-    public boolean isWeighted()
-    {
-		int iWeight = GetWornArmorWeight();
-		
-		if ( iWeight >= 10 )
-		{
-			return true;
-		}
-		
-    	return IsWeightedByHeadCrab();
-    }
-    
-    protected boolean IsWeightedByHeadCrab()
-    {
-    	return HasHeadCrabbedSquid();
-    }
-    
-    @Override
-    public void OnFlungBySquidTentacle( FCEntitySquid squid )
-    {
-    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
-    	
-        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
-    }
-    
-    @Override
-    public void OnHeadCrabbedBySquid( FCEntitySquid squid )
-    {
-    	// doesn't call attackEntityFrom() by default so that monsters remain chill about it and don't attack back
-    	
-        playSound( getHurtSound(), getSoundVolume(), getSoundPitch() );        
-    }
-    
-	protected int GetWornArmorWeight()
-	{
-		int iWeight = 0;
-		
-		for ( int iTempSlot = 0; iTempSlot < 4; iTempSlot++ )
-		{
-			ItemStack tempStack = this.getCurrentArmor( iTempSlot );
-			
-			if ( tempStack != null )
-			{
-				iWeight += tempStack.getItem().GetWeightWhenWorn();
-			}
-		}
-        
-		return iWeight;
-	}
-	
-    private boolean HasOnlyAmbientPotionEffects( Collection effectCollection )
-    {    	
-        if ( effectCollection != null && !effectCollection.isEmpty() )
-        {
-            Iterator effectIterator = effectCollection.iterator();
-
-            while (effectIterator.hasNext())
-            {
-                PotionEffect tempEffect = (PotionEffect)effectIterator.next();
-                
-                if ( !tempEffect.getIsAmbient() )
-                {
-                	return false;
-                }
-            }
-            
-        	return true;
-        }
-        
-    	return false;
-    }
-    
-    public void SpawnerInitCreature()
-    {
-    	initCreature();
-    }
-    
-    /** Initialize state variables which may affect ability to spawn, such as bounding box size */
-    public void PreInitCreature() {}
-    
-    public boolean canEntityBeSeen( Entity entity )
-    {
-    	// Vanilla code replaced so that entities can be seen through blocks that don't stop movement
-    	
-        return worldObj.rayTraceBlocks_do_do( 
-        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
-        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
-    		(double)entity.getEyeHeight(), entity.posZ ), false, true ) == null;
-    }
-    
-    public boolean CanEntityCenterOfMassBeSeen( Entity entity )
-    {
-    	// Same as above, but to other entities' center rather than eye to eye
-    	
-        return worldObj.rayTraceBlocks_do_do( 
-        	worldObj.getWorldVec3Pool().getVecFromPool( posX, posY + (double)getEyeHeight(), posZ ), 
-        	worldObj.getWorldVec3Pool().getVecFromPool( entity.posX, entity.posY + 
-    		( entity.height / 2F ), entity.posZ ), false, true ) == null;
-    }
-    
-    protected void RecoverAirSupply()
-    {
-		setAir(300);		
-    }
-    
-    public void SetPersistent( boolean bPersistant )
-    {
-    	persistenceRequired = bPersistant;
-    }
-    
-    @Override
-    public boolean DoesEntityApplyToSpawnCap()
-    {
-    	// entities with persistance set do not apply to the spawn cap
-    	
-    	return !GetIsPersistent();
-    }
-    
-    @Override
-	public void OutOfUpdateRangeUpdate()
-	{
-    	despawnEntity();
-	}
-	
-	public float GetDefaultSlipperinessOnGround()
-    {
-        return 0.54600006F;
-    }
-    
-	public float GetSlipperinessRelativeToBlock( int iBlockID )
-	{
-    	return Block.blocksList[iBlockID].slipperiness  * 0.91F;
-	}
-	
-	public boolean CanJumpMidWater()
-	{
-		return false;
-	}
-	
-	public void OnClimbWhileSwimming()
-	{
-	}
-	
-    protected void despawnEntity()
-    {
-    	// FCCHUNK: Decide on updates around original spawn
-        if ( !persistenceRequired && canDespawn() )
-        {
-        	int iChunkX = MathHelper.floor_double( posX / 16D ); 
-    		int iChunkZ = MathHelper.floor_double( posZ / 16D );
-    		
-    		if ( !worldObj.IsChunkActive( iChunkX, iChunkZ ) )
-    		{
-        		setDead();    			
-    		}
-    		else
-    		{
-	            EntityPlayer closestPlayer = worldObj.getClosestPlayerToEntity( this, 
-	            	MinDistFromPlayerForDespawn() );
-	        	
-	            if ( closestPlayer != null )
-	            {
-                	// don't despawn creatures close to a player
-                	
-                    entityAge = 0;
-	            }	
-	            else if ( entityAge > 600 && rand.nextInt( 800 ) == 0 ) 
-	            {
-	                setDead();
-	            }
-    		}
-        }
-        else
-        {
-            entityAge = 0;
-        }
-    }
-    
-    protected double MinDistFromPlayerForDespawn()
-    {
-    	return 32D;
-    }
-    
-    protected boolean IsInsideSpawnAreaAroundPlayer( EntityPlayer player )
-    {
-    	return IsInsideSpawnAreaAroundChunk( 
-    		MathHelper.floor_double( player.posX / 16D ), 
-    		MathHelper.floor_double( player.posZ / 16D ) ); 
-    }
-    
-    protected boolean IsInsideSpawnAreaAroundOriginalSpawn()
-    {
-    	return worldObj.provider.dimensionId == 0 && 
-    		IsInsideSpawnAreaAroundChunk( worldObj.worldInfo.getSpawnX() >> 4,
-    			worldObj.worldInfo.getSpawnZ() >> 4 );
-    }
-    
-    protected boolean IsInsideSpawnAreaAroundChunk( int iChunkX, int iChunkZ )
-    {
-        int iValidRange = worldObj.GetMobSpawnRangeInChunks();
-        
-        int iEntityChunkX = MathHelper.floor_double( posX / 16D );
-        int iDeltaX = iChunkX - iEntityChunkX;
-        
-        if ( iDeltaX >= -iValidRange && iDeltaX <= iValidRange )
-        {
-	        int iEntityChunkZ = MathHelper.floor_double( posZ / 16D );
-	        int iDeltaZ = iChunkZ - iEntityChunkZ;
-	        
-	        if ( iDeltaZ >= -iValidRange && iDeltaZ <= iValidRange )
-	        {
-	        	return true;
-	        }
-        }   
-                    
-        return false;
-    }
-    
-    @Override
-    public boolean AttractsLightning()
-    {
-    	return true;
-    }
-    
-    public int GetMeleeAttackStrength( Entity target )
-    {
-    	return 2;
-    }
-    
-    public boolean MeleeAttack( Entity target )
-    {
-        setLastAttackingEntity( target );
-        
-        int iStrength = GetMeleeAttackStrength( target );
-
-        if ( isPotionActive( Potion.damageBoost ) )
-        {
-            iStrength += 3 << getActivePotionEffect( Potion.damageBoost ).getAmplifier();
-        }
-
-        if ( isPotionActive( Potion.weakness ) )
-        {
-            iStrength -= 2 << getActivePotionEffect( Potion.weakness ).getAmplifier();
-        }
-
-        int iKnockback = 0;
-
-        if ( target instanceof EntityLiving )
-        {
-            iStrength += EnchantmentHelper.getEnchantmentModifierLiving( this, 
-            	(EntityLiving)target );
-            
-            iKnockback += EnchantmentHelper.getKnockbackModifier( this, (EntityLiving)target );
-        }
-
-        boolean bAttackSuccess = target.attackEntityFrom( DamageSource.causeMobDamage( this ), 
-        	iStrength );
-
-        if ( bAttackSuccess )
-        {
-            if ( iKnockback > 0 )
-            {
-                target.addVelocity( 
-                	-MathHelper.sin( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F, 
-                	0.1D, 
-                	MathHelper.cos( rotationYaw * (float)Math.PI / 180F ) * iKnockback * 0.5F );
-                
-                motionX *= 0.6D;
-                motionZ *= 0.6D;
-            }
-
-            int iFireModifier = EnchantmentHelper.getFireAspectModifier( this );
-
-            if ( iFireModifier > 0 )
-            {
-                target.setFire( iFireModifier * 4 );
-            }
-            else if ( isBurning() && rand.nextFloat() < 0.6F )
-            {
-                target.setFire( 4 );
-            }
-
-            if ( target instanceof EntityLiving )
-            {
-                EnchantmentThorns.func_92096_a(this, (EntityLiving)target, rand);
-            }
-        }
-
-        return bAttackSuccess;
-    }
-    
-    public float KnockbackMagnitude()
-    {
-    	return 0.4F;
-    }
-    
-    static public boolean InstallationIntegrityTest()
-    {
-    	return true;
-    }
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- EntityMagmaCube.java	Sun Sep 30 13:19:15 2018
+++ EntityMagmaCube.java	Fri Apr 20 22:33:11 2018
@@ -1,9 +1,6 @@
 package net.minecraft.src;
 
-// FCMOD: Changed
-//public class EntityMagmaCube extends EntitySlime
-public class EntityMagmaCube extends FCEntitySlime
-// END FCMOD
+public class EntityMagmaCube extends EntitySlime
 {
     public EntityMagmaCube(World par1World)
     {
--- EntityMinecart.java	Mon Jul 15 15:04:50 2013
+++ EntityMinecart.java	Fri Apr 20 22:33:11 2018
@@ -672,25 +672,9 @@
         }
         else
         {
-            // FCMOD: Changed the following for less drag on non-ridden carts
-            /*
             this.motionX *= 0.9599999785423279D;
             this.motionY *= 0.0D;
             this.motionZ *= 0.9599999785423279D;
-            */
-            if ( FCBetterThanWolves.fcDisableMinecartChanges )
-            {
-                motionX *= 0.96D;
-                motionY *= 0.0D;
-                motionZ *= 0.96D;
-        	}
-            else
-            {
-                motionX *= 0.985D;
-                motionY *= 0.0D;
-                motionZ *= 0.985D;
-            }
-            // END FCMOD
         }
     }
 
@@ -1049,12 +1033,4 @@
     {
         return this.entityName;
     }
-    
-    // FCMOD: Code added
-    @Override
-    public boolean CanCollideWithEntity( Entity entity )
-    {
-    	return !entity.IsItemEntity();
-    }
-    // END FCMOD
 }
--- EntityMinecartChest.java	Sun Apr  1 22:49:32 2018
+++ EntityMinecartChest.java	Fri Apr 20 22:33:11 2018
@@ -15,17 +15,7 @@
     public void killMinecart(DamageSource par1DamageSource)
     {
         super.killMinecart(par1DamageSource);
-        
-        // FCMOD: Changed
-        //this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
-    	dropItemWithOffset( FCBetterThanWolves.fcItemSawDust.itemID, 6, 0.0F );
-    	dropItemWithOffset( Item.stick.itemID, 2, 0.0F );
-    	
-        if ( !worldObj.isRemote )
-        {        
-			playSound( "mob.zombie.woodbreak", 0.25F, 0.75F + ( worldObj.rand.nextFloat() * 0.25F ) );
-        }
-        // END FCMOD        
+        this.dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
     }
 
     /**
--- EntityMob.java	Wed Feb 27 13:51:19 2019
+++ EntityMob.java	Fri Apr 20 22:33:11 2018
@@ -13,13 +13,6 @@
      * use this to react to sunlight and start to burn.
      */
     public void onLivingUpdate()
-    // FCMOD: Addded so that method can be called directly regardless of hierarchy
-    {
-    	EntityMobOnLivingUpdate();
-    }
-    
-    public void EntityMobOnLivingUpdate()
-    // END FCMOD
     {
         this.updateArmSwingProgress();
         float var1 = this.getBrightness(1.0F);
@@ -59,13 +52,6 @@
      * Called when the entity is attacked.
      */
     public boolean attackEntityFrom(DamageSource par1DamageSource, int par2)
-    // FCMOD: Addded so that method can be called directly regardless of hierarchy
-    {
-    	return EntityMobAttackEntityFrom(par1DamageSource, par2);
-    }
-    
-    public boolean EntityMobAttackEntityFrom(DamageSource par1DamageSource, int par2)
-    // END FCMOD
     {
         if (this.isEntityInvulnerable())
         {
@@ -79,9 +65,6 @@
             {
                 if (var3 != this)
                 {
-                	// FCMOD: Code added so that mobs won't lose their target if they take damage from an environmental source
-                	if ( var3 != null )
-            		// END FCMOD
                     this.entityToAttack = var3;
                 }
 
@@ -98,8 +81,6 @@
         }
     }
 
-    // FCMOD: Removed and moved up in hiearchy
-	/*
     public boolean attackEntityAsMob(Entity par1Entity)
     {
         int var2 = this.getAttackStrength(par1Entity);
@@ -139,12 +120,6 @@
             {
                 par1Entity.setFire(var5 * 4);
             }
-            // FCMOD: Added so all mobs set fire to others when burning, not just zombies
-            else if ( isBurning() && rand.nextFloat() < 0.6F )
-            {
-                par1Entity.setFire( 4 );
-            }
-            // END FCMOD
 
             if (par1Entity instanceof EntityLiving)
             {
@@ -154,20 +129,11 @@
 
         return var4;
     }
-    */
-    // END FCMOD
 
     /**
      * Basic mob attack. Default to touch of death in EntityCreature. Overridden by each mob to define their attack.
      */
     protected void attackEntity(Entity par1Entity, float par2)
-    // FCMOD: Addded so that method can be called directly regardless of hierarchy
-    {
-    	EntityMobAttackEntity( par1Entity, par2 );
-    }
-    
-    protected void EntityMobAttackEntity(Entity par1Entity, float par2)
-    // END FCMOD
     {
         if (this.attackTime <= 0 && par2 < 2.0F && par1Entity.boundingBox.maxY > this.boundingBox.minY && par1Entity.boundingBox.minY < this.boundingBox.maxY)
         {
@@ -219,10 +185,7 @@
      */
     public boolean getCanSpawnHere()
     {
-    	// FCMOD: Changed
-        //return this.isValidLightLevel() && super.getCanSpawnHere();
-    	return isValidLightLevel() && super.getCanSpawnHere() && CanSpawnOnBlockBelow();
-        // END FCMOD
+        return this.isValidLightLevel() && super.getCanSpawnHere();
     }
 
     /**
@@ -232,60 +195,4 @@
     {
         return 2;
     }
-    
-    // FCMOD: Added New
-    @Override
-    public int GetMeleeAttackStrength( Entity target )
-    {
-    	return getAttackStrength( target );
-    }
-    
-    protected boolean CanSpawnOnBlockBelow()
-    {
-        int i = MathHelper.floor_double( posX );
-        int j = (int)boundingBox.minY - 1;
-        int k = MathHelper.floor_double( posZ );
-        
-        return CanSpawnOnBlock( worldObj.getBlockId( i, j, k ) );        
-    }
-    
-    protected boolean CanSpawnOnBlock( int iBlockID )
-    {
-    	return iBlockID != Block.leaves.blockID;
-    }
-
-    protected void CheckForCatchFireInSun()
-    {
-        if ( !worldObj.isRemote && worldObj.isDaytime() && !isChild() && !inWater )
-        {
-            float fBrightness = getBrightness( 1F );
-
-            if ( fBrightness > 0.5F && rand.nextFloat() * 30F < ( fBrightness - 0.4F ) * 2F && 
-            	worldObj.canBlockSeeTheSky( MathHelper.floor_double( posX ), 
-            		MathHelper.floor_double( posY + (double)getEyeHeight() ), 
-            		MathHelper.floor_double( posZ ) ) )
-            {
-            	// check to make sure water isn't directly below to prevent catching fire while bobbing
-            	
-            	int iBlockBelowID = worldObj.getBlockId( MathHelper.floor_double( posX ), 
-            		MathHelper.floor_double( posY - 0.1F ), MathHelper.floor_double( posZ ) );
-            	
-            	Block blockBelow = Block.blocksList[iBlockBelowID];
-            	
-            	if ( blockBelow == null || blockBelow.blockMaterial != Material.water ) 
-            	{            	                                    
-	            	// client
-	                //ItemStack headStack = getCurrentItemOrArmor( 4 );
-	            	// server
-	                ItemStack headStack = getEquipmentInSlot( 4 );
-	
-	                if ( headStack == null && !HasHeadCrabbedSquid() )
-	                {
-	                    setFire( 8 );
-	                }
-            	}
-            }
-        }
-    }
-    // END FCMOD
 }
--- EntityMooshroom.java	Sat Jan 12 23:28:08 2019
+++ EntityMooshroom.java	Fri Apr 20 22:33:11 2018
@@ -1,9 +1,6 @@
 package net.minecraft.src;
 
-// FCMOD: Changed
-//public class EntityMooshroom extends EntityCow
-public class EntityMooshroom extends FCEntityCow
-// END FCMOD
+public class EntityMooshroom extends EntityCow
 {
     public EntityMooshroom(World par1World)
     {
@@ -15,8 +12,6 @@
     /**
      * Called when a player interacts with a mob. e.g. gets milk from a cow, gets into the saddle on a pig.
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean interact(EntityPlayer par1EntityPlayer)
     {
         ItemStack var2 = par1EntityPlayer.inventory.getCurrentItem();
@@ -54,7 +49,7 @@
                     this.worldObj.spawnEntityInWorld(new EntityItem(this.worldObj, this.posX, this.posY + (double)this.height, this.posZ, new ItemStack(Block.mushroomRed)));
                 }
             }
-            
+
             return true;
         }
         else
@@ -62,8 +57,6 @@
             return super.interact(par1EntityPlayer);
         }
     }
-    */
-    // END FCMOD    
 
     public EntityMooshroom func_94900_c(EntityAgeable par1EntityAgeable)
     {
@@ -73,10 +66,7 @@
     /**
      * This function is used when two same-species animals in 'love mode' breed to generate the new baby animal.
      */
-    // FCMOD: Changed
-    //public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
-    public FCEntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
-    // END FCMOD
+    public EntityCow spawnBabyAnimal(EntityAgeable par1EntityAgeable)
     {
         return this.func_94900_c(par1EntityAgeable);
     }
@@ -85,78 +75,4 @@
     {
         return this.func_94900_c(par1EntityAgeable);
     }
-
-    // FCMOD: Added New
-    @Override
-    public void CheckForGrazeSideEffects( int i, int j, int k )
-    {
-    	// override to get rid of mooshroom conversion on eat mycellium
-    }
-    
-    @Override
-    public void ConvertToMooshroom()
-    {
-    }
-    
-    @Override
-    public void onLivingUpdate()
-    {
-        if ( !worldObj.isRemote )
-        {
-            CheckForMyceliumSpread();
-        }
-
-        super.onLivingUpdate();
-    }
-    
-    @Override
-    public boolean interact( EntityPlayer player )
-    {
-        ItemStack heldStack = player.inventory.getCurrentItem();
-
-        if ( heldStack != null && heldStack.itemID == Item.bowlEmpty.itemID && GotMilk() )
-        {
-            attackEntityFrom( DamageSource.generic, 0 );
-            
-            if ( !worldObj.isRemote )
-        	{
-            	SetGotMilk( false );
-            	
-		        worldObj.playAuxSFX( FCBetterThanWolves.m_iCowMilkedAuxFXID,
-	                MathHelper.floor_double( posX ), (int)posY,
-	                MathHelper.floor_double( posZ ), 0 );
-            }
-            
-            if ( heldStack.stackSize == 1 )
-            {
-                player.inventory.setInventorySlotContents( player.inventory.currentItem, 
-                	new ItemStack( Item.bowlSoup ) );
-            }
-            else if ( player.inventory.addItemStackToInventory( new ItemStack( Item.bowlSoup ) ) ) 
-            {
-                player.inventory.decrStackSize(player.inventory.currentItem, 1);
-            }
-            
-            return true;
-        }
-        
-        // skip over parent to avoid vanilla milking
-        
-        return EntityAnimalInteract( player ); 
-    }
-    
-	//------------- Class Specific Methods ------------//
-    
-    private void CheckForMyceliumSpread()
-    {
-    	if ( worldObj.provider.dimensionId != 1 && rand.nextInt( 1000 ) == 0 )
-    	{
-    		FCBlockMycelium.CheckForMyceliumSpreadToRandomBlockAround( worldObj,
-    			MathHelper.floor_double( posX ), (int)posY - 1, 
-    			MathHelper.floor_double( posZ ) );
-    	}
-    }
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD    
 }
--- EntityOcelot.java	Sun Sep 30 14:34:14 2018
+++ EntityOcelot.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/30/2018
-
 package net.minecraft.src;
 
 public class EntityOcelot extends EntityTameable
--- EntityPig.java	Mon Jul 23 17:50:25 2018
+++ EntityPig.java	Fri Apr 20 22:33:11 2018
@@ -1,9 +1,4 @@
-// FCMOD: Class changes deprecated 07/23/2018
-
 package net.minecraft.src;
-
-import java.util.Iterator;
-import java.util.List;
 
 public class EntityPig extends EntityAnimal
 {
--- EntityPigZombie.java	Fri Sep 28 14:44:53 2018
+++ EntityPigZombie.java	Fri Apr 20 22:33:11 2018
@@ -2,10 +2,7 @@
 
 import java.util.List;
 
-// FCMOD: Changed
-//public class EntityPigZombie extends EntityZombie
-public class EntityPigZombie extends FCEntityZombie
-// END FCMOD
+public class EntityPigZombie extends EntityZombie
 {
     /** Above zero if this PigZombie is Angry. */
     private int angerLevel = 0;
@@ -117,10 +114,7 @@
     /**
      * Causes this PigZombie to become angry at the supplied Entity (which will be a player).
      */
-    // FCMOD: Changed
-    //private void becomeAngryAt(Entity par1Entity)
-    protected void becomeAngryAt(Entity par1Entity)
-    // END FCMOD
+    private void becomeAngryAt(Entity par1Entity)
     {
         this.entityToAttack = par1Entity;
         this.angerLevel = 400 + this.rand.nextInt(400);
--- EntityPlayer.java	Wed Dec 23 15:43:49 2020
+++ EntityPlayer.java	Fri Apr 20 22:33:11 2018
@@ -100,10 +100,7 @@
     public EntityPlayer(World par1World)
     {
         super(par1World);
-        // FCMOD: Changed
-        //this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
-        inventoryContainer = new FCContainerPlayer( inventory, !par1World.isRemote, this );
-        // END FCMOD
+        this.inventoryContainer = new ContainerPlayer(this.inventory, !par1World.isRemote, this);
         this.openContainer = this.inventoryContainer;
         this.yOffset = 1.62F;
         ChunkCoordinates var2 = par1World.getSpawnPoint();
@@ -125,29 +122,8 @@
         this.dataWatcher.addObject(16, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(17, Byte.valueOf((byte)0));
         this.dataWatcher.addObject(18, Integer.valueOf(0));
-        
-        // FCMOD: Added
-        dataWatcher.addObject( m_iHasValidMagneticPointForLocationDataWatcherID, new Byte( (byte)0 ) );
-        dataWatcher.addObject( m_iStongestMagneticPointForLocationIDataWatcherID, new Integer( 0 ) );
-        dataWatcher.addObject( m_iStongestMagneticPointForLocationKDataWatcherID, new Integer( 0 ) );
-        dataWatcher.addObject( m_iGloomLevelDataWatcherID, new Byte( (byte)0 ) );
-        dataWatcher.addObject( m_iFatPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
-        dataWatcher.addObject( m_iHungerPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
-        dataWatcher.addObject( m_iHealthPenaltyLevelDataWatcherID, new Byte( (byte)0 ) );
-        
-        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, new Integer( 0 ) );
-        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, new Integer( 0 ) );
-        dataWatcher.addObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, new Integer( 0 ) );
-        // END FCMOD
     }
 
-    // FCMOD: Added (server only to match client)
-    public int getItemInUseCount()
-    {
-        return this.itemInUseCount;
-    }
-    // END FCMOD
-
     /**
      * Checks if the entity is currently using an item (e.g., bow, food, sword) by holding down the useItemButton
      */
@@ -187,35 +163,17 @@
      */
     public void onUpdate()
     {
-    	// FCMOD: Added
-    	m_iTimesCraftedThisTick = 0;
-        m_iTicksSinceEmoteSound++;
-    	// END FCMOD
-    	
         if (this.itemInUse != null)
         {
             ItemStack var1 = this.inventory.getCurrentItem();
 
-            // FCMOD: Changed
-            //if (var1 == this.itemInUse)
-            if ( var1 == this.itemInUse || 
-            	( var1 != null && itemInUse.getItem().IgnoreDamageWhenComparingDuringUse() && 
-        		var1.itemID == itemInUse.itemID && ItemStack.areItemStackTagsEqual( itemInUse, var1 ) ) )
-        	// END FCMOD
-            {
-            	// FCMOD: Added
-            	itemInUse = var1;
-            	// END FCMOD
-            	
+            if (var1 == this.itemInUse)
+            {
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(var1, 5);
                 }
 
-                // FCMOD: Added
-        		var1.getItem().UpdateUsingItem( var1, this.worldObj, this );
-                // END FCMOD 
-
                 if (--this.itemInUseCount == 0 && !this.worldObj.isRemote)
                 {
                     this.onItemUseFinish();
@@ -328,10 +286,6 @@
         {
             this.foodStats.onUpdate(this);
         }
-        
-        // FCMOD: Added
-        UpdateModStatusVariables();
-        // END FCMOD
     }
 
     /**
@@ -350,10 +304,6 @@
         return 10;
     }
 
-    // FCMOD: Comment added
-    /**
-	/* the playSound function both plays the sound locally on the client, and plays it remotely on the server without it being sent again to the same player
-	 */ // END FCMOD
     public void playSound(String par1Str, float par2, float par3)
     {
         this.worldObj.playSoundToNearExcept(this, par1Str, par2, par3);
@@ -499,9 +449,6 @@
         super.onLivingUpdate();
         this.landMovementFactor = this.capabilities.getWalkSpeed();
         this.jumpMovementFactor = this.speedInAir;
-        // FCMOD: Code added to apply move penalties to jumping
-        jumpMovementFactor *= GetJumpingHorizontalMovementModifier();        
-        // END FCMOD
 
         if (this.isSprinting())
         {
@@ -679,9 +626,6 @@
                 var3.motionX = (double)(-MathHelper.sin(var6) * var5);
                 var3.motionZ = (double)(MathHelper.cos(var6) * var5);
                 var3.motionY = 0.20000000298023224D;
-                // FCMOD: Code added: par2 flag indicates that the item has been dropped on death
-                var3.SetEntityItemAsDroppedOnPlayerDeath( this );
-                // END FCMOD
             }
             else
             {
@@ -714,19 +658,9 @@
     /**
      * Returns how strong the player is against the specified block at this moment
      */
-    // FCMOD: Code change
-    /*
     public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2)
-    */
-    public float getCurrentPlayerStrVsBlock(Block par1Block, int i, int j, int k)
-    // END FCMOD
     {
-        // FCMOD: Code change
-        /*
         float var3 = this.inventory.getStrVsBlock(par1Block);
-        */
-        float var3 = this.inventory.getStrVsBlock(worldObj, par1Block, i, j, k);
-    	// END FCMOD
 
         if (var3 > 1.0F)
         {
@@ -737,12 +671,7 @@
             {
                 float var6 = (float)(var4 * var4 + 1);
 
-                // FCMOD: Code change
-                /*
                 if (!var5.canHarvestBlock(par1Block) && var3 <= 1.0F)
-                */
-                if (!var5.canHarvestBlock( worldObj, par1Block, i, j, k) && var3 <= 1.0F)
-                // END FCMOD
                 {
                     var3 += var6 * 0.08F;
                 }
@@ -772,10 +701,6 @@
         {
             var3 /= 5.0F;
         }
-        
-        // FCMOD: Added
-        var3 *= GetMiningSpeedModifier();
-        // END FCMOD        
 
         return var3;
     }
@@ -783,14 +708,10 @@
     /**
      * Checks if the player has the ability to harvest a block (checks current inventory item for a tool if necessary)
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return this.inventory.canHarvestBlock(par1Block);
     }
-    */
-    // END FCMOD
 
     /**
      * (abstract) Protected helper method to read subclass entity data from NBT.
@@ -828,9 +749,6 @@
             NBTTagList var3 = par1NBTTagCompound.getTagList("EnderItems");
             this.theInventoryEnderChest.loadInventoryFromNBT(var3);
         }
-        // FCMOD: Code added
-        ReadModDataFromNBT( par1NBTTagCompound );
-        // END FCMOD
     }
 
     /**
@@ -859,9 +777,6 @@
         this.foodStats.writeNBT(par1NBTTagCompound);
         this.capabilities.writeCapabilitiesToNBT(par1NBTTagCompound);
         par1NBTTagCompound.setTag("EnderItems", this.theInventoryEnderChest.saveInventoryToNBT());
-        // FCMOD: Code added
-        WriteModDataToNBT( par1NBTTagCompound );
-        // END FCMOD
     }
 
     /**
@@ -963,14 +878,6 @@
                     }
 
                     this.addStat(StatList.damageTakenStat, par2);
-                    // FCMOD: Code added
-                    if ( !isDead && IsCarryingBlastingOil() )
-                    {
-                    	DetonateCarriedBlastingOil();
-                    	
-                    	return false;
-                    }
-                    // END FCMOD
                     return super.attackEntityFrom(par1DamageSource, par2);
                 }
             }
@@ -990,13 +897,7 @@
      */
     protected void alertWolves(EntityLiving par1EntityLiving, boolean par2)
     {
-    	// FCMOD: Added to make sure that wolves don't attack if sitting
-    	par2 = true;
-    	// END FCMOD
-    	// FCMOD: Changed
-        //if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
-        if (!(par1EntityLiving instanceof FCEntityCreeper) && !(par1EntityLiving instanceof FCEntityGhast))
-    	// END FCMOD
+        if (!(par1EntityLiving instanceof EntityCreeper) && !(par1EntityLiving instanceof EntityGhast))
         {
             if (par1EntityLiving instanceof EntityWolf)
             {
@@ -1069,10 +970,6 @@
         {
             if (!par1DamageSource.isUnblockable() && this.isBlocking())
             {
-        		// FCMOD: Code added
-        		OnBlockedDamage( par1DamageSource, par2 );
-        		// END FCMOD
-        		
                 par2 = 1 + par2 >> 1;
             }
 
@@ -1209,15 +1106,6 @@
                     ++var3;
                 }
 
-                // FCMOD: Code added to modify player attack damage by health and exhaustion
-                float fModifier = GetMeleeDamageModifier();
-                
-                if ( fModifier < 0.99F )
-                {
-                	var2 = (int)((float)var2 * fModifier);                	
-                }
-                // END FCMOD
-
                 if (var2 > 0 || var4 > 0)
                 {
                     boolean var5 = this.fallDistance > 0.0F && !this.onGround && !this.isOnLadder() && !this.isInWater() && !this.isPotionActive(Potion.blindness) && this.ridingEntity == null && par1Entity instanceof EntityLiving;
@@ -1316,12 +1204,6 @@
 
                     this.addExhaustion(0.3F);
                 }
-                // FCMOD: Code added
-                else // else from "if (var2 > 0 || var4 > 0)" above, indicating zero damage attack
-                {
-            		OnZeroDamageAttack();
-                }
-                // END FCMOD
             }
         }
     }
@@ -1365,11 +1247,6 @@
      */
     public EnumStatus sleepInBedAt(int par1, int par2, int par3)
     {
-    	// FCMOD: Code added
-        return EnumStatus.OTHER_PROBLEM;
-        // END FCMOD
-    	// FCMOD: Code removed
-        /*
         if (!this.worldObj.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
@@ -1449,8 +1326,6 @@
         }
 
         return EnumStatus.OK;
-        */
-        // END FCMOD
     }
 
     private void func_71013_b(int par1)
@@ -1620,10 +1495,6 @@
             this.spawnChunk = null;
             this.spawnForced = false;
         }
-        
-        // FCMOD: Code added
-        m_iSpawnDimension = 0;
-        // END FCMOD
     }
 
     /**
@@ -1647,8 +1518,6 @@
         super.jump();
         this.addStat(StatList.jumpStat, 1);
 
-        // FCMOD: Changed
-        /*
         if (this.isSprinting())
         {
             this.addExhaustion(0.8F);
@@ -1657,9 +1526,6 @@
         {
             this.addExhaustion(0.2F);
         }
-        */
-        AddExhaustionForJump();
-        // END FCMOD
     }
 
     /**
@@ -1697,13 +1563,6 @@
         {
             int var7;
 
-            // FCMOD: Added
-            if ( isInWater() && par3 > 0D && CanSwim() )
-            {
-                addExhaustion( 0.025F );
-            }
-            // END FCMOD
-            
             if (this.isInsideOfMaterial(Material.water))
             {
                 var7 = Math.round(MathHelper.sqrt_double(par1 * par1 + par3 * par3 + par5 * par5) * 100.0F);
@@ -1711,12 +1570,7 @@
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceDoveStat, var7);
-                    // FCMOD: Code change
-                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
-                    */
-                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
-                    // END FCMOD
                 }
             }
             else if (this.isInWater())
@@ -1726,12 +1580,7 @@
                 if (var7 > 0)
                 {
                     this.addStat(StatList.distanceSwumStat, var7);
-                    // FCMOD: Code change
-                    /*
                     this.addExhaustion(0.015F * (float)var7 * 0.01F);
-                    */
-                    this.AddExhaustionWithoutVisualFeedback(0.015F * (float)var7 * 0.01F);
-                    // END FCMOD
                 }
             }
             else if (this.isOnLadder())
@@ -1755,12 +1604,7 @@
                     }
                     else
                     {
-                        // FCMOD: Code change
-                        /*
                         this.addExhaustion(0.01F * (float)var7 * 0.01F);
-                        */
-                        this.AddExhaustionWithoutVisualFeedback(0.01F * (float)var7 * 0.01F);
-                        // END FCMOD
                     }
                 }
             }
@@ -1924,9 +1768,6 @@
         {
             if (!this.worldObj.isRemote)
             {
-            	// FCMOD: Code added        	
-            	par1 *= GetArmorExhaustionModifier();
-        		// END FCMOD
                 this.foodStats.addExhaustion(par1);
             }
         }
@@ -1942,12 +1783,6 @@
 
     public boolean canEat(boolean par1)
     {
-    	// FCMOD: Code added to prevent player from eating while having the hunger effect
-        if ( isPotionActive( Potion.hunger ) )
-        {
-        	return false;
-        }
-    	// END FCMOD
         return (par1 || this.foodStats.needFood()) && !this.capabilities.disableDamage;
     }
 
@@ -2002,12 +1837,7 @@
                 {
                     ItemStack var6 = this.getCurrentEquippedItem();
 
-                    // FCMOD: Code change
-                    /*
                     if (var6.canHarvestBlock(var5) || var6.getStrVsBlock(var5) > 1.0F)
-                    */
-                    if (var6.canHarvestBlock(worldObj, var5, par1, par2, par3) || var6.getStrVsBlock(worldObj, var5, par1, par2, par3) > 1.0F)
-                	// END FCMOD
                     {
                         return true;
                     }
@@ -2020,13 +1850,6 @@
 
     public boolean canPlayerEdit(int par1, int par2, int par3, int par4, ItemStack par5ItemStack)
     {
-    	// FCMOD: Code added to prevent the player from placing blocks while in mid air
-    	if ( !capabilities.isCreativeMode && !onGround && !inWater && !isOnLadder() && ridingEntity == null && !handleLavaMovement() )
-    	{
-    		return false;
-    	}
-    	// END FCMOD
-    	
         return this.capabilities.allowEdit ? true : (par5ItemStack != null ? par5ItemStack.func_82835_x() : false);
     }
 
@@ -2203,1072 +2026,4 @@
     {
         return ScorePlayerTeam.func_96667_a(this.getTeam(), this.username);
     }
-
-    // FCMOD: Added New
-    public ChunkCoordinates m_HardcoreSpawnChunk;
-    
-    public long m_lTimeOfLastSpawnAssignment = 0;
-    public long m_lTimeOfLastDimensionSwitch = 0;
-    public long m_lRespawnAssignmentCooldownTimer = 0;
-    
-    public int m_iSpawnDimension = 0;
-    public int m_iTimesCraftedThisTick = 0;
-    public int m_iInGloomCounter = 0;
-    public int m_iAirRecoveryCountdown = 0;    
-    public int m_iTicksSinceEmoteSound = 0;
-    
-	protected float m_fCurrentMiningSpeedModifier = 1F;
-    
-    public static final int m_iGloomCounterBetweenStateChanges = 1200; // 1 minute
-    
-	private static final int m_iStongestMagneticPointForLocationIDataWatcherID = 22;
-	private static final int m_iStongestMagneticPointForLocationKDataWatcherID = 23;
-	private static final int m_iHasValidMagneticPointForLocationDataWatcherID = 24;
-	private static final int m_iGloomLevelDataWatcherID = 25;
-	private static final int m_iFatPenaltyLevelDataWatcherID = 26;
-	private static final int m_iHungerPenaltyLevelDataWatcherID = 27;
-	private static final int m_iHealthPenaltyLevelDataWatcherID = 28;
-    
-	private static final int m_iSpawnChunksVisualizationLocationIDataWatcherID = 29;
-	private static final int m_iSpawnChunksVisualizationLocationJDataWatcherID = 30;
-	private static final int m_iSpawnChunksVisualizationLocationKDataWatcherID = 31;
-	
-	private static final int m_iTicksBetweenEmoteSounds = 10;
-	
-	public static final float m_fExhaustionJumping = 0.2F;
-	public static final float m_fExhaustionJumpingSprinting = 1.0F;
-	
-    protected void ReadModDataFromNBT( NBTTagCompound tag )
-    {
-	    if ( tag.hasKey( "fcTimeOfLastSpawnAssignment" ) )
-	    {
-	    	m_lTimeOfLastSpawnAssignment = tag.getLong( "fcTimeOfLastSpawnAssignment" );
-	    }
-	    
-	    if ( tag.hasKey( "fcTimeOfLastDimensionSwitch" ) )
-	    {
-	    	m_lTimeOfLastDimensionSwitch = tag.getLong( "fcTimeOfLastDimensionSwitch" );
-	    }
-	    
-	    if ( tag.hasKey( "fcHCSpawnX" ) && tag.hasKey( "fcHCSpawnY" ) && tag.hasKey( "fcHCSpawnZ" ) )
-	    {
-	        m_HardcoreSpawnChunk = new ChunkCoordinates( tag.getInteger( "fcHCSpawnX" ), tag.getInteger( "fcHCSpawnY" ), tag.getInteger( "fcHCSpawnZ" ) );
-	    }
-	    
-	    if ( tag.hasKey( "fcSpawnDimension" ) )
-	    {
-	    	m_iSpawnDimension = tag.getInteger( "fcSpawnDimension" );
-	    }	    	    
-	    
-	    if ( tag.hasKey( "fcGloomLevel" ) )
-	    {
-	    	SetGloomLevel( tag.getInteger( "fcGloomLevel" ) );
-	    }
-	    
-	    if ( tag.hasKey( "fcGloomCounter" ) )
-	    {
-	    	m_iInGloomCounter = tag.getInteger( "fcGloomCounter" );
-	    }
-    }
-    
-    protected void WriteModDataToNBT( NBTTagCompound tag )
-    {
-	 	tag.setLong( "fcTimeOfLastSpawnAssignment", m_lTimeOfLastSpawnAssignment );
-	 	
-	 	tag.setLong( "fcTimeOfLastDimensionSwitch", m_lTimeOfLastDimensionSwitch );
-	    
-	    if ( m_HardcoreSpawnChunk != null )
-	    {
-	        tag.setInteger( "fcHCSpawnX", m_HardcoreSpawnChunk.posX );
-	        tag.setInteger( "fcHCSpawnY", m_HardcoreSpawnChunk.posY );
-	        tag.setInteger( "fcHCSpawnZ", m_HardcoreSpawnChunk.posZ );
-	    }
-	    
-	 	tag.setInteger( "fcSpawnDimension", m_iSpawnDimension );
-	 	
-	 	tag.setInteger( "fcGloomLevel", GetGloomLevel() );
-	 	tag.setInteger( "fcGloomCounter", m_iInGloomCounter );
-    }
-    
-    @Override
-    protected int decreaseAirSupply( int iAirSupply )
-    {
-        m_iAirRecoveryCountdown = 20;
-        
-        int iEnchantmentLevel = EnchantmentHelper.getRespiration(this);
-        
-        if ( iEnchantmentLevel > 0 && IsWearingSoulforgedHelm() )
-        {
-    		if ( this.worldObj.getWorldTime() % 100 == 0 )
-    		{
-    			worldObj.playSoundAtEntity( this, 
-            		"random.breath", 
-            		0.75F + rand.nextFloat() * 0.5F, 
-            		0.5F + rand.nextFloat() * 0.025F );
-    		}    		
-
-        	if ( rand.nextInt( ( iEnchantmentLevel * iEnchantmentLevel + 1 ) ) > 0 )
-        	{
-        		return iAirSupply;
-        	}
-        	else
-        	{
-                return iAirSupply - 1;
-        	}        	
-        }
-        else
-        {
-        	return super.decreaseAirSupply( iAirSupply );
-        }
-    }
-    
-    @Override
-    protected void RecoverAirSupply()
-    {
-    	if ( m_iAirRecoveryCountdown > 0 )
-    	{
-    		m_iAirRecoveryCountdown--;
-    		
-    	}
-    	else
-    	{
-        	int iCurrentAir = getAir();
-        	
-        	if ( iCurrentAir < 300 )
-        	{
-        		iCurrentAir += 10;
-        		
-        		if ( iCurrentAir > 300 )
-        		{
-        			iCurrentAir = 300;
-        		}
-        		setAir( iCurrentAir + 1 );
-        	}
-        	else
-        	{
-        		setAir(300);
-        	}
-    	}
-    }
-    
-	@Override
-    public boolean isOnLadder()
-    {
-		return GetHealthPenaltyLevel() < 4 && super.isOnLadder();
-    }
-	
-	@Override
-    public boolean CanJump()
-    {		
-    	return health > 4 && foodStats.getFoodLevel() > 12 && (int)foodStats.getSaturationLevel() < 18;
-    }
-	
-	@Override
-    public boolean CanSwim()
-    {		
-    	return !isWeighted() && health > 4;
-    }
-	
-	@Override
-	protected int GetWornArmorWeight()
-	{
-		int iWeight = 0;
-		
-        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
-        {
-        	ItemStack tempStack = inventory.armorInventory[iSlot];
-        	
-            if ( tempStack != null )
-            {
-                iWeight += tempStack.getItem().GetWeightWhenWorn();
-            }
-        }
-        
-		return iWeight;
-	}
-	
-	public float GetArmorExhaustionModifier()
-	{
-		float fModifier = 1.0F;
-		
-		int iWeight = GetWornArmorWeight();
-		
-		if ( iWeight > 0 )
-		{
-			// set to cap at a 2 times modifier with full plate armor
-			
-			fModifier += (float)iWeight / 44F;
-		}
-		
-		return fModifier;
-	}
-	
-	
-	public boolean IsWearingFullSuitSoulforgedArmor()
-	{
-        for ( int iSlot = 0; iSlot < inventory.armorInventory.length; iSlot++ )
-        {
-            if ( inventory.armorInventory[iSlot] == null || !( inventory.armorInventory[iSlot].getItem() instanceof FCItemArmorRefined ) )
-            {
-                return false;
-            }
-        }
-        
-		return true;
-	}
-	
-    protected boolean IsWearingSoulforgedHelm()
-	{
-        return inventory.armorInventory[3] != null && 
-        	inventory.armorInventory[3].getItem().itemID == 
-    		FCBetterThanWolves.fcItemPlateHelm.itemID;
-	}
-	
-    protected boolean IsWearingSoulforgedBoots()
-	{
-        return inventory.armorInventory[0] != null && 
-        	inventory.armorInventory[0].getItem().itemID == 
-    		FCBetterThanWolves.fcItemPlateBoots.itemID;
-	}
-    
-    public boolean IsWearingEnderSpectacles()
-    {
-        return inventory.armorInventory[3] != null && 
-        	inventory.armorInventory[3].getItem().itemID == 
-    		FCBetterThanWolves.fcItemEnderSpectacles.itemID;
-    }
-    
-	@Override
-    protected void playStepSound( int i, int j, int k, int iBlockID )
-    {
-		float fHealthAndExhaustionModifier = GetHealthAndExhaustionModifier();
-		
-		if ( fHealthAndExhaustionModifier < 0.26F )
-		{
-			// play grunting along with step
-			
-			float fGruntVolume = ( 1F - fHealthAndExhaustionModifier ) * 0.75F;
-			
-			worldObj.playSoundAtEntity( this, 
-        		"random.classic_hurt", 0.5F, 
-        		1F + rand.nextFloat() * 0.1F);
-		}
-		
-		if ( IsWearingSoulforgedBoots() )
-		{
-	        int iBlockAboveID = worldObj.getBlockId( i, j + 1, k );
-	        Block blockAbove = Block.blocksList[iBlockAboveID];
-	        
-	        if ( blockAbove != null && blockAbove.IsGroundCover( ) )
-	        {
-	        	StepSound stepSound = blockAbove.stepSound;
-	            
-	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.75F );
-	        }
-	        else if ( !Block.blocksList[iBlockID].blockMaterial.isLiquid() )
-	        {
-		        StepSound stepSound = Block.blocksList[iBlockID].GetStepSound( worldObj, i, j, k );    	
-
-	            worldObj.playSoundAtEntity( this, stepSound.getStepSound(), stepSound.getVolume() * 0.3F, stepSound.getPitch() * 0.5F );
-	        }
-		}
-		else
-		{
-			super.playStepSound( i, j, k, iBlockID );
-		}
-    }
-
-	@Override
-    protected float GetHealthAndExhaustionModifier()
-    {
-		float fModifier = 1.0F;
-
-		int iPenaltyLevel = GetMaximumStatusPenaltyLevel();
-		
-		if ( iPenaltyLevel >= 2 )
-		{
-			if ( iPenaltyLevel >= 3 )
-			{
-				if ( iPenaltyLevel >= 4 )
-				{
-					fModifier = 0.25F;
-				}
-				else
-				{
-					fModifier = 0.5F;
-				}
-			} 
-			else
-			{
-				fModifier = 0.75F;
-			}
-		}
-		
-    	return fModifier;
-    }
-    
-    protected float GetHealthAndExhaustionModifierWithSightlessModifier()
-    {
-		float fModifier = GetHealthAndExhaustionModifier();
-		
-		if ( GetGloomLevel() > 0 )
-		{
-			fModifier *= 0.5F;
-		}
-		
-    	return fModifier;
-    }
-    
-	@Override
-    protected float GetSwimmingHorizontalModifier()
-    {
-		return GetHealthAndExhaustionModifierWithSightlessModifier();
-    }
-    
-	@Override
-    protected float GetLandMovementModifier()
-    {
-		return GetHealthAndExhaustionModifierWithSightlessModifier();
-    }
-    
-	@Override
-    protected float GetLadderVerticalMovementModifier()
-    {
-		return GetHealthAndExhaustionModifierWithSightlessModifier();
-    }    
-    
-	protected float GetJumpingHorizontalMovementModifier()        
-    {
-		return GetHealthAndExhaustionModifierWithSightlessModifier();
-    }
-    
-	protected void SetMiningSpeedModifier( float fModifier )
-	{
-		if ( fModifier > 1F )
-		{
-			// cap it just in case the client sends an invalid speed to the server
-			
-			fModifier = 1F;
-		}
-		
-		m_fCurrentMiningSpeedModifier = fModifier;
-	}
-	
-    protected float GetMiningSpeedModifier()
-    {
-		return m_fCurrentMiningSpeedModifier;
-    }
-    
-    protected float UpdateMiningSpeedModifier()
-    {
-    	m_fCurrentMiningSpeedModifier = GetHealthAndExhaustionModifierWithSightlessModifier();
-    	
-    	return m_fCurrentMiningSpeedModifier;
-    }
-    
-    protected float GetMeleeDamageModifier()
-    {
-		return GetHealthAndExhaustionModifierWithSightlessModifier();
-    }
-    
-    public float GetBowPullStrengthModifier()
-    {
-    	return GetHealthAndExhaustionModifier();
-    }
-    
-	public boolean HasStatusPenalty()
-	{
-        return getHealth() <= 10 || foodStats.getFoodLevel() <= 24 || (int)foodStats.getSaturationLevel() >= 12;
-	}
-	
-	public int GetMaximumStatusPenaltyLevel()
-	{
-		int iMaximumPenaltyLevel = GetHealthPenaltyLevel();
-		int iHungerPenaltyLevel = GetHungerPenaltyLevel();
-		
-		if ( iHungerPenaltyLevel > iMaximumPenaltyLevel )
-		{
-			iMaximumPenaltyLevel = iHungerPenaltyLevel;
-		}
-		
-		int iFatPenaltyLevel = GetFatPenaltyLevel();
-		
-		if ( iFatPenaltyLevel > iMaximumPenaltyLevel )
-		{
-			iMaximumPenaltyLevel = iFatPenaltyLevel;
-		}
-		
-		return iMaximumPenaltyLevel;
-	}
-	
-    protected boolean IsCarryingBlastingOil()
-    {	
-    	return inventory.hasItem( FCBetterThanWolves.fcItemBlastingOil.itemID );
-    }
-    
-	protected void DetonateCarriedBlastingOil()
-	{
-		if ( !worldObj.isRemote )
-		{
-	    	int iHellfireCount = FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemHellfireDust.itemID, -1 );
-	    	
-	    	float fExplosionSize = ( iHellfireCount * 10.0F ) / 64.0F;
-	    	
-	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, Item.gunpowder.itemID, -1 ) * 10.0F ) / 64.0F;
-	    	
-	    	fExplosionSize += ( FCUtilsInventory.CountItemsInInventory( inventory, FCBetterThanWolves.fcItemBlastingOil.itemID, -1 ) * 10.0F ) / 64.0F;
-	    	
-	    	int iTNTCount = FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
-	    	
-	    	if ( iTNTCount > 0 )
-	    	{
-	    		if ( fExplosionSize < 4.0F )
-	    		{
-	    			fExplosionSize = 4.0F;
-	    		}
-	    		
-	        	fExplosionSize += FCUtilsInventory.CountItemsInInventory( inventory, Block.tnt.blockID, -1 );
-	    	}
-	    	
-	    	if ( fExplosionSize < 1.5F )
-	    	{
-	    		fExplosionSize = 1.5F;
-	    	}
-	    	else if ( fExplosionSize > 10.0F )
-	    	{
-	    		fExplosionSize = 10.0F;
-	    	}
-	    	
-	    	FCUtilsInventory.ClearInventoryContents( inventory );
-	    	
-			health = 0;
-			
-			onDeath( DamageSource.generic );
-			
-	        worldObj.createExplosion( null, posX, posY, posZ, fExplosionSize, true );
-		}		
-	}
-	
-	@Override
-    protected void dropHead()
-    {
-        EntityItem skullEntity = entityDropItem( new ItemStack( Item.skull.itemID, 1, 3 ), 0.0F );
-        
-        if ( skullEntity != null )
-        {
-        	// client
-        	ItemStack stack = skullEntity.getEntityItem();
-        	// server
-        	//ItemStack stack = skullEntity.func_92059_d();
-        	
-            NBTTagCompound tag = stack.getTagCompound();
-
-            if ( tag == null)
-            {
-                tag = new NBTTagCompound();
-                
-                stack.setTagCompound( tag );
-            }
-
-            tag.setString( "SkullOwner", username );
-        }
-    }
-    
-    public boolean HasValidMagneticPointForLocation()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iHasValidMagneticPointForLocationDataWatcherID ) > 0;
-    }
-    
-    public int GetStongestMagneticPointForLocationI()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationIDataWatcherID );
-    }
-    
-    public int GetStongestMagneticPointForLocationK()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iStongestMagneticPointForLocationKDataWatcherID );
-    }
-    
-    public void SetHasValidMagneticPointForLocation( boolean bValid )
-    {
-    	byte bValidByte = 0;
-    	
-    	if ( bValid )
-    	{
-    		bValidByte = 1;
-    	}
-    	
-        dataWatcher.updateObject( m_iHasValidMagneticPointForLocationDataWatcherID, Byte.valueOf( bValidByte ) );
-    }
-    
-    public void SetStongestMagneticPointForLocationI( int iLocationI )
-    {
-        dataWatcher.updateObject( m_iStongestMagneticPointForLocationIDataWatcherID, Integer.valueOf( iLocationI ) );
-    }
-    
-    public void SetStongestMagneticPointForLocationK( int iLocationK )
-    {
-        dataWatcher.updateObject( m_iStongestMagneticPointForLocationKDataWatcherID, Integer.valueOf( iLocationK ) );
-    }
-    
-    public int GetGloomLevel()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iGloomLevelDataWatcherID );
-    }
-    
-    public void SetGloomLevel( int iGloomLevel )
-    {
-        dataWatcher.updateObject( m_iGloomLevelDataWatcherID, Byte.valueOf( (byte)iGloomLevel ) );
-    }
-    
-    public int GetFatPenaltyLevel()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iFatPenaltyLevelDataWatcherID );
-    }
-    
-    public void SetFatPenaltyLevel( int iPenaltyLevel )
-    {
-        dataWatcher.updateObject( m_iFatPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
-    }
-    
-    public int GetHungerPenaltyLevel()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iHungerPenaltyLevelDataWatcherID );
-    }
-    
-    public void SetHungerPenaltyLevel( int iPenaltyLevel )
-    {
-        dataWatcher.updateObject( m_iHungerPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
-    }
-    
-    public int GetHealthPenaltyLevel()
-    {
-        return dataWatcher.getWatchableObjectByte( m_iHealthPenaltyLevelDataWatcherID );
-    }
-    
-    public void SetHealthPenaltyLevel( int iPenaltyLevel )
-    {
-        dataWatcher.updateObject( m_iHealthPenaltyLevelDataWatcherID, Byte.valueOf( (byte)iPenaltyLevel ) );
-    }
-    
-    public int GetSpawnChunksVisualizationLocationI()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationIDataWatcherID );
-    }
-    
-    public int GetSpawnChunksVisualizationLocationJ()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationJDataWatcherID );
-    }
-    
-    public int GetSpawnChunksVisualizationLocationK()
-    {
-        return dataWatcher.getWatchableObjectInt( m_iSpawnChunksVisualizationLocationKDataWatcherID );
-    }
-    
-    public void SetSpawnChunksVisualization( int iLocationI, int iLocationJ, int iLocationK )
-    {
-        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationIDataWatcherID, 
-        	Integer.valueOf( iLocationI ) );
-        
-        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationJDataWatcherID, 
-        	Integer.valueOf( iLocationJ ) );
-        
-        dataWatcher.updateObject( m_iSpawnChunksVisualizationLocationKDataWatcherID, 
-        	Integer.valueOf( iLocationK ) );
-    }
-    
-    public boolean HasRespawnCoordinates()
-    {
-    	return spawnChunk != null;
-    }
-    
-    /*
-     * returns zero if a valid spawn location is found
-     * 1 = invalid forced spawn location
-     * 2 = missing beacon
-     * 3 = Beacon is out of range
-     * 4 = Area around beacon is obstructed
-     */
-    public int GetValidatedRespawnCoordinates( World newWorld, ChunkCoordinates respawnLocation )
-    {
-    	int iReturnValue = 0;
-    	
-    	int iOldDimension = dimension;
-    	int iNewDimension = m_iSpawnDimension;
-    	
-        IChunkProvider chunkProvider = newWorld.getChunkProvider();
-        
-        ChunkCoordinates validatedCoords = null;
-        
-        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ - 4 >> 4 );
-        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ - 4 >> 4 );
-        chunkProvider.loadChunk( spawnChunk.posX - 4 >> 4, spawnChunk.posZ + 4 >> 4 );
-        chunkProvider.loadChunk( spawnChunk.posX + 4 >> 4, spawnChunk.posZ + 4 >> 4 );
-
-        if ( spawnForced )
-        {
-            Material targetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
-            Material aboveTargetMaterial = newWorld.getBlockMaterial( spawnChunk.posX, spawnChunk.posY + 1, spawnChunk.posZ );
-            
-            boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
-            boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
-            
-            if ( IsValidRespawnLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) )
-            {
-            	validatedCoords = spawnChunk;
-            }
-            else
-            {
-            	iReturnValue = 1;
-            }
-        }
-        else
-        {        
-    		iReturnValue = 2;
-    		
-	        if ( newWorld.getBlockId( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ ) == Block.beacon.blockID )
-	        {
-	        	FCTileEntityBeacon beaconEnt = (FCTileEntityBeacon)newWorld.getBlockTileEntity( spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ );
-	        	
-	        	if ( beaconEnt != null )
-	        	{
-	        		int iBeaconEffect = beaconEnt.getPrimaryEffect();
-	        		
-	        		if ( iBeaconEffect == FCTileEntityBeacon.m_iEffectIDSpawnPoint )
-	        		{
-	        			int iBeaconPowerLevel = beaconEnt.getLevels();
-	        		
-	        			if ( iBeaconPowerLevel > 0 )
-	        			{
-	        				iReturnValue = 3;
-	        				
-		        			if ( iBeaconPowerLevel >= 4 || iOldDimension == iNewDimension )
-		        			{
-		        				boolean bInRange = true;
-		        				
-		        				if ( iBeaconPowerLevel < 3 )
-		        				{
-		        					int iMaxRange = 160;
-		        					
-		        					if ( iBeaconPowerLevel == 2 )
-		        					{
-		        						iMaxRange = 2000;
-		        					}
-		        					
-		        					int iDeltaX = Math.abs( (int)posX - spawnChunk.posX );
-		        					
-		        					if ( iDeltaX > iMaxRange )
-		        					{
-		        						bInRange = false;
-		        					}
-		        					else
-		        					{
-			        					int iDeltaZ = Math.abs( (int)posZ - spawnChunk.posZ );
-			        					
-			        					if ( iDeltaZ > iMaxRange )
-			        					{
-			        						bInRange = false;
-			        					}
-		        					}
-		        				}
-		        				
-		        				if ( bInRange )
-		        				{	        				
-		        					validatedCoords = GetRandomValidSpawnAroundBeaconLocation( newWorld, spawnChunk.posX, spawnChunk.posY, spawnChunk.posZ, iBeaconPowerLevel );
-		        					
-		        					if ( validatedCoords != null )
-		        					{
-		        						iReturnValue = 0;
-		        						beaconEnt.m_bPlayerRespawnedAtBeacon = true;
-		        					}
-		        					else
-		        					{
-		        						iReturnValue = 4;
-		        					}
-		        				}
-		        			}
-	        			}
-	        		}
-	        	}
-	        }
-	        
-	        if ( validatedCoords != null )
-	        {
-	        	respawnLocation.posX = validatedCoords.posX;
-	        	respawnLocation.posY = validatedCoords.posY;
-	        	respawnLocation.posZ = validatedCoords.posZ;
-	        }
-        }
-        
-        return iReturnValue;
-    }
-    
-    private boolean IsValidRespawnLocation( World world, int i, int j, int k )
-    {
-        Material targetMaterial = world.getBlockMaterial( i, j, k );
-        Material aboveTargetMaterial = world.getBlockMaterial( i, j + 1, k );
-        
-        boolean bValidTarget = !targetMaterial.isSolid() && !targetMaterial.isLiquid();
-        boolean bValidAboveTarget = !aboveTargetMaterial.isSolid() && !aboveTargetMaterial.isLiquid();
-        
-        return bValidTarget && bValidAboveTarget;
-	}
-    
-    private ChunkCoordinates GetRandomValidSpawnAroundBeaconLocation( World world, int i, int j, int k, int iBeaconLevel )
-    {
-    	for ( int iAttempt = 0; iAttempt < 20; iAttempt++ )
-    	{
-    		int iDistance = rand.nextInt( iBeaconLevel ) + 1;    		
-    		
-    		// generate a random point around the edge at the specified distance
-    		
-    		int iPrimaryOffset = rand.nextInt( 2 ) * iDistance;
-    		
-			if ( rand.nextInt( 2 ) == 0 )
-			{
-				iPrimaryOffset = -iPrimaryOffset;
-			}
-			
-    		int iSecondaryOffset = rand.nextInt( iBeaconLevel * 2 + 1 ) - iBeaconLevel;
-    		
-    		int iXOffset = iPrimaryOffset; 
-			int iYOffset = -( iDistance - 1 );
-    		int iZOffset = iSecondaryOffset;
-    		
-			if ( rand.nextInt( 2 ) == 0 )
-			{
-	    		iXOffset = iSecondaryOffset;
-	    		iZOffset = iPrimaryOffset;
-			}
-			
-			int iISpawn = i + iXOffset;
-			int iJSpawn = j + iYOffset;
-			int iKSpawn = k + iZOffset;
-			
-        	if ( world.doesBlockHaveSolidTopSurface( iISpawn, iJSpawn - 1, iKSpawn ) && IsValidRespawnLocation( world, iISpawn, iJSpawn, iKSpawn ) )
-        	{
-                return new ChunkCoordinates( iISpawn, iJSpawn, iKSpawn );
-            }
-    	}
-    	
-        return null;
-    }
-
-    // overloaded vanilla function with added dimension param
-    public void setSpawnChunk( ChunkCoordinates coords, boolean bForced, int iDimension )
-    {
-        if ( coords != null )
-        {
-            spawnChunk = new ChunkCoordinates(coords);
-            spawnForced = bForced;
-            m_iSpawnDimension = iDimension;
-        }
-        else
-        {
-            spawnChunk = null;
-            spawnForced = false;
-            m_iSpawnDimension = 0;            
-        }        
-    }
-    
-	public void AddRawChatMessage( String message )
-	{
-	}
-	
-	boolean IsCurrentToolEffectiveOnBlock( Block targetBlock, int i, int j, int k )
-	{
-        float var2 = 1.0F;
-
-        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
-        
-        if ( currentItemStack != null )
-        {
-            return currentItemStack.getItem().IsEfficientVsBlock( currentItemStack, worldObj, targetBlock, i, j, k );
-        }
-
-		return false;
-	}
-    
-    public boolean canHarvestBlock( Block par1Block, int i, int j, int k )
-    {
-        return this.inventory.canHarvestBlock( worldObj, par1Block, i, j, k );
-    }
-    
-    public boolean AddStackToCurrentHeldStackIfEmpty( ItemStack stack )
-    {
-    	if ( getCurrentEquippedItem() == null )
-    	{
-    		inventory.setInventorySlotContents( inventory.currentItem, stack.copy() );
-    		
-    		return true;
-    	}
-    	
-    	return false;
-    }    
-    	
-    protected void UpdateModStatusVariables()
-    {
-    	UpdateGloomState();
-    	
-    	UpdateHungerPenaltyLevel();
-    	
-    	UpdateFatPenaltyLevel();
-    	
-    	UpdateHealthPenaltyLevel();
-    }
-
-    protected void UpdateGloomState() {}
-    
-	protected void UpdateHungerPenaltyLevel() {}
-	
-    protected void UpdateFatPenaltyLevel() {}
-	
-	protected void UpdateHealthPenaltyLevel() {}
-	
-	protected void OnBlockedDamage( DamageSource source, int iDamage )
-	{
-        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
-        
-        if ( currentItemStack != null )
-        {
-        	currentItemStack.damageItem( 1, this );
-        }
-	}
-	
-    @Override
-    public double getMountedYOffset()
-    {
-        return (double)height * 0.025D;
-    }
-    
-    public void AddExhaustionWithoutVisualFeedback( float fAmount )
-    {
-        addExhaustion( fAmount );
-    }
-    
-    public void AddHarvestBlockExhaustion( int iBlockID, int iBlockI, int iBlockJ, int iBlockK, int iBlockMetadata )
-    {
-    	float fExhaustionConsumed = 0.025F; // default exhaustion amount
-    	
-        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
-        
-        if ( currentItemStack != null )
-        {
-        	fExhaustionConsumed = currentItemStack.getItem().GetExhaustionOnUsedToHarvestBlock( iBlockID, worldObj, iBlockI, iBlockJ, iBlockK, iBlockMetadata );
-        }
-    	
-    	if ( fExhaustionConsumed > 0F )
-    	{
-    		addExhaustion( fExhaustionConsumed );
-    	}
-    }
-    
-    protected void OnZeroDamageAttack()
-    {
-    }
-    
-    protected boolean IsPlayerHoldingSail()
-    {
-        ItemStack currentItemStack = inventory.mainInventory[inventory.currentItem];
-        
-        if ( currentItemStack != null )
-        {
-    		return currentItemStack.itemID == FCBetterThanWolves.fcItemWindMillBlade.itemID;
-        }
-        
-        return false;
-    }
-    
-    @Override
-	public boolean AppliesConstantForceWhenRidingBoat()
-	{
-		return IsPlayerHoldingSail();
-	}
-	
-    @Override
-	public double MovementModifierWhenRidingBoat()
-	{
-        double dModifier = 0.35D;
-        
-        if ( IsPlayerHoldingSail() )
-        {
-			dModifier = 1.0D;
-    	}
-        
-		return dModifier;
-	}
-
-    @Override
-    public void unmountEntity( Entity riddenEntity )
-    {
-        double dUnmountX = posX;
-        double dUnmountY = posY;
-        double dUnmountZ = posZ;
-
-        if (riddenEntity != null)
-        {
-            dUnmountX = riddenEntity.posX;
-            dUnmountY = riddenEntity.boundingBox.minY + (double)riddenEntity.height;
-            dUnmountZ = riddenEntity.posZ;
-        }
-        
-        double dLookOffsetX = -MathHelper.cos( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
-        double dLookOffsetZ = -MathHelper.sin( ( rotationYaw - 90 ) * (float)Math.PI / 180.0F );
-        
-        int iMaxSuitability = 0;
-        
-        for ( double dTempLookOffset = 2.0D; dTempLookOffset > 0.1D; dTempLookOffset -= 0.5D )
-        {
-        	double dTempXOffset = dLookOffsetX * dTempLookOffset;
-        	double dTempZOffset = dLookOffsetZ * dTempLookOffset;
-        	
-        	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
-        	
-        	if (  iTempSuitability > iMaxSuitability )
-        	{
-                dUnmountX = posX + dTempXOffset;
-                dUnmountY = posY + 1.0D;
-                dUnmountZ = posZ + dTempZOffset;
-                
-                iMaxSuitability = iTempSuitability;
-        	}
-        }
-        
-        if ( iMaxSuitability <= 0 )
-        {
-	        for ( double dTempXOffset = -1.5D; dTempXOffset < 2.0D; ++dTempXOffset )
-	        {
-	            for ( double dTempZOffset = -1.5D; dTempZOffset < 2.0D; ++dTempZOffset )
-	            {
-	            	int iTempSuitability = GetDismountLocationSuitability( dTempXOffset, dTempZOffset );
-	            	
-	            	if (  iTempSuitability > iMaxSuitability )
-	            	{
-	                    dUnmountX = posX + dTempXOffset;
-	                    dUnmountY = posY + 1.0D;
-	                    dUnmountZ = posZ + dTempZOffset;
-	                    
-	                    iMaxSuitability = iTempSuitability;
-	            	}
-	            }
-	        }
-        }
-
-        setLocationAndAngles(dUnmountX, dUnmountY, dUnmountZ, this.rotationYaw, this.rotationPitch);
-    }
-    
-    private boolean IsSolidBlockToDismountOn( int i, int j, int k )
-    {
-    	return worldObj.doesBlockHaveSolidTopSurface( i , j, k )  || worldObj.getBlockMaterial( i, j, k ) == Material.ice;    
-	}
-    
-    /**
-     * Returns a value of zero or higher, with larger numbers indicating greater suitability
-     */
-    private int GetDismountLocationSuitability( double dPosOffsetX, double dPosOffsetZ )
-    {
-    	int i = MathHelper.floor_double( posX + dPosOffsetX );
-    	int j = MathHelper.floor_double( posY ); 
-    	int k = MathHelper.floor_double( posZ + dPosOffsetZ );
-    	
-        AxisAlignedBB dTempBoundingBox = boundingBox.getOffsetBoundingBox( dPosOffsetX, 1.0D, dPosOffsetZ );
-
-        if ( worldObj.getCollidingBlockBounds( dTempBoundingBox ).isEmpty() )
-        {
-	        if ( IsSolidBlockToDismountOn( i, j, k ) )
-	        {
-	            return 3;
-	        }
-	        else if ( IsSolidBlockToDismountOn( i, j - 1, k ) )
-	        {
-	            return 2;
-	            
-	        }
-	        else if ( worldObj.getBlockMaterial( i, j - 1, k ) == Material.water )
-	        {
-	        	return 1;
-	        }
-        }
-        
-        return 0;
-    }
-    
-    public void AddExhaustionForJump()
-    {
-	    if ( isSprinting() )
-	    {
-			addExhaustion( m_fExhaustionJumpingSprinting );
-	    }
-	    else
-	    {
-			addExhaustion( m_fExhaustionJumping );
-	    }
-    }
-    
-    public void SetItemInUseCount( int iCount )
-    {
-        itemInUseCount = iCount;
-    }
-    
-    @Override
-    public boolean GetCanBeHeadCrabbed( boolean bSquidInWater )
-    {
-    	return isEntityAlive() && !capabilities.disableDamage && 
-			riddenByEntity == null && ridingEntity == null;
-    }
-    
-    @Override
-    public boolean IsValidOngoingAttackTargetForSquid()
-    {
-    	return isEntityAlive();
-    }
-    
-    @Override
-	public boolean IsImmuneToHeadCrabDamage()
-	{
-		return IsWearingSoulforgedHelm();
-	}
-    
-    public boolean IsLocalPlayerAndHittingBlock()
-    {
-    	return false;
-    }
-	
-    @Override
-    public void MountEntityRemote( Entity entityToMount )
-    {
-    	// Fix described in MC-1291 for players dissapearing after riding boats in SMP
-    	// Bypasses toggle type behavior of mounting and dismounting if multiple packets
-    	// are received for a player.
-    	
-    	if ( ridingEntity != entityToMount )
-    	{
-    		super.mountEntity( entityToMount );
-    	}
-    }
-    
-    public boolean CanDrink()
-    {
-        return !isPotionActive( Potion.hunger );
-    }
-    
-    public void OnCantConsume()
-    {
-    	if ( !worldObj.isRemote && m_iTicksSinceEmoteSound >= m_iTicksBetweenEmoteSounds )    		
-    	{    		
-            worldObj.playAuxSFX( FCBetterThanWolves.m_iEatFailAuxFXID,           
-            	MathHelper.floor_double( posX ), 
-            	MathHelper.floor_double( posY ), 
-            	MathHelper.floor_double( posZ ), 0 );    
-            
-            m_iTicksSinceEmoteSound = 0;
-    	}
-    }
-    
-    static public boolean InstallationIntegrityTestPlayer()
-    {
-    	return true;
-    }
-    // END FCMOD
 }
--- EntityPlayerMP.java	Tue Feb 26 20:08:28 2019
+++ EntityPlayerMP.java	Fri Apr 20 22:33:11 2018
@@ -33,10 +33,6 @@
     public double managedPosZ;
 
     /** LinkedList that holds the loaded chunks. */
-    /**
-     * FCNOTE: Deprecated list used by vanilla PlayerInstance and PlayerManager to track watched
-     * chunks
-     */
     public final List loadedChunks = new LinkedList();
 
     /** entities added to this list will  be packet29'd to the player */
@@ -192,8 +188,6 @@
             this.playerNetServerHandler.sendPacket(new Packet29DestroyEntity(var2));
         }
 
-        // FCMOD: Changed
-        /*
         if (!this.loadedChunks.isEmpty())
         {
             ArrayList var6 = new ArrayList();
@@ -232,13 +226,6 @@
                 }
             }
         }
-        */
-        SendChunksToClient();
-        // END FCMOD
-
-        // FCMOD: Code Added
-        ModSpecificOnUpdate();
-        // END FCMOD
     }
 
     public void setEntityHealth(int par1)
@@ -275,21 +262,12 @@
                 }
             }
 
-        	// FCMOD: Code changed to relay changes in food saturation
-        	/*
             if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry)
-        	*/
-        	if (this.getHealth() != this.lastHealth || this.lastFoodLevel != this.foodStats.getFoodLevel() || this.foodStats.getSaturationLevel() == 0.0F != this.wasHungry ||
-        		m_iLastFoodSaturation != (int)( foodStats.getSaturationLevel() * 8F ) )
-    		// END FCMOD
             {
                 this.playerNetServerHandler.sendPacket(new Packet8UpdateHealth(this.getHealth(), this.foodStats.getFoodLevel(), this.foodStats.getSaturationLevel()));
                 this.lastHealth = this.getHealth();
                 this.lastFoodLevel = this.foodStats.getFoodLevel();
                 this.wasHungry = this.foodStats.getSaturationLevel() == 0.0F;
-            	// FCMOD: Code added
-            	m_iLastFoodSaturation = (int)( foodStats.getSaturationLevel() * 8F );
-            	// END FCMOD
             }
 
             if (this.experienceTotal != this.lastExperience)
@@ -319,10 +297,6 @@
             this.inventory.dropAllItems();
         }
 
-        // FCMOD: Code added
-        CustomModDrops( par1DamageSource );
-        // END FCMOD
-
         Collection var2 = this.worldObj.getScoreboard().func_96520_a(ScoreObjectiveCriteria.field_96642_c);
         Iterator var3 = var2.iterator();
 
@@ -428,10 +402,7 @@
     /**
      * gets description packets from all TileEntity's that override func_20070
      */
-    // FCMOD: Changed (server only) to match name on client
-    //private void getTileEntityInfo(TileEntity par1TileEntity)
-    private void sendTileEntityToPlayer(TileEntity par1TileEntity)
-    // END FCMOD
+    private void getTileEntityInfo(TileEntity par1TileEntity)
     {
         if (par1TileEntity != null)
         {
@@ -528,10 +499,7 @@
     {
         this.getNextWindowId();
         this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, 1, "Crafting", 9, true));
-        // FCMOD: Changed
-        //this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
-        openContainer = new FCContainerWorkbench( inventory, worldObj, par1, par2, par3 );
-        // END FCMOD
+        this.openContainer = new ContainerWorkbench(this.inventory, this.worldObj, par1, par2, par3);
         this.openContainer.windowId = this.currentWindowId;
         this.openContainer.onCraftGuiOpened(this);
     }
@@ -645,16 +613,9 @@
         this.getNextWindowId();
         this.openContainer = new ContainerMerchant(this.inventory, par1IMerchant, this.worldObj);
         this.openContainer.windowId = this.currentWindowId;
-        // FCMOD: Code moved slightly later to avoid init order problems
-        /*
         this.openContainer.onCraftGuiOpened(this);
-        */
-        // END FCMOD
         InventoryMerchant var3 = ((ContainerMerchant)this.openContainer).getMerchantInventory();
         this.playerNetServerHandler.sendPacket(new Packet100OpenWindow(this.currentWindowId, 6, par2Str == null ? "" : par2Str, var3.getSizeInventory(), par2Str != null));
-        // FCMOD: Code moved from above to avoid init order problems
-        this.openContainer.onCraftGuiOpened(this);
-        // END FCMOD
         MerchantRecipeList var4 = par1IMerchant.getRecipes(this);
 
         if (var4 != null)
@@ -968,560 +929,4 @@
     {
         return new ChunkCoordinates(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY + 0.5D), MathHelper.floor_double(this.posZ));
     }
-
-    // FCMOD: Added
-    public LinkedList<ChunkCoordIntPair> m_chunksToBeSentToClient = 
-    	new LinkedList<ChunkCoordIntPair>();
-    
-    private int m_iLastFoodSaturation = -99999999;
-	private int m_iExhaustionWithTimeCounter = 0;
-	
-	private static final int m_iExhaustionWithTimePeriod = 600; // once per 30 seconds
-	private static final float m_fExhaustionWithTimeAmount = 0.5F; // set with above to begin starving to death after 160 minutes if you're fully obese, losing 1 hunger every 4 minutes	
-    
-    private static final float m_fMinimumGloomBiteChance = 0.01F; 
-    private static final float m_fMaximumGloomBiteChance = 0.05F; // 1/second
-    
-	private static final int m_iDelayBetweenZeroDamageAttackSounds = 20; 
-	private long m_lTimeOfLastZeroDamageAttackSound = 0;
-	
-    @Override
-    protected void CheckForHeadDrop( DamageSource source, int iLootingModifier )
-    {
-	    Entity sourceEntity = source.getEntity();        
-	    int iHeadChance = this.rand.nextInt(200);        
-	    
-        iHeadChance -= iLootingModifier;
-    	
-	    if ( sourceEntity instanceof EntityPlayer)
-	    {
-	    	if ( ((EntityPlayer)sourceEntity).getHeldItem() != null && 
-	    		((EntityPlayer)sourceEntity).getHeldItem().getItem().itemID == FCBetterThanWolves.fcItemBattleAxe.itemID )
-	    	{
-	    		// 100% chance of decapitation with Battle Axe in PvP
-	    		
-	    		iHeadChance = 0;
-	    	}
-	    }
-	    else if ( source == FCDamageSourceCustom.m_DamageSourceChoppingBlock )
-	    {
-			iHeadChance = 0;
-	    }
-	    
-	    if ( iHeadChance < 5 )
-	    {
-	        dropHead();
-	    }
-    }
-    
-    private void CustomModDrops( DamageSource source )
-    {
-	    Entity sourceEntity = source.getEntity();        
-        int iLootingModifier = GetAmbientLootingModifier();
-
-        if ( sourceEntity instanceof EntityPlayer )
-        {
-            int iPlayerLootingModifier = EnchantmentHelper.getLootingModifier((EntityLiving)sourceEntity);
-            
-            if ( iPlayerLootingModifier > iLootingModifier )
-            {
-            	iLootingModifier = iPlayerLootingModifier;
-            }
-        }
-        
-        DropMysteryMeat( iLootingModifier );
-        
-        CheckForHeadDrop( source, iLootingModifier );
-    }
-    
-    private void DropMysteryMeat( int iLootingModifier )
-    {
-        if ( !HasHeadCrabbedSquid() )
-        {
-	    	// only drop mystery meat periodically to prevent people killing themselves repeatedly for food.
-	    	// With HC Spawn enabled, it only happens when the player will be moved to a new spawn location.
-	    	
-			long lOverworldTime = MinecraftServer.getServer().worldServers[0].getWorldTime();
-			
-			if ( m_lTimeOfLastSpawnAssignment == 0 || m_lTimeOfLastSpawnAssignment > lOverworldTime || 
-				lOverworldTime - m_lTimeOfLastSpawnAssignment >= FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
-			{
-				int iDropItemID = FCBetterThanWolves.fcItemRawMysteryMeat.itemID;
-				
-				if ( isBurning() )
-				{
-					iDropItemID = FCBetterThanWolves.fcItemMeatBurned.itemID;
-				}
-		    	
-		        int iFat = ( (int)foodStats.getSaturationLevel() ) / 2;
-		        
-		        int iNumDropped = 1 + iFat;
-		
-		        for ( int iTempCount = 0; iTempCount < iNumDropped; ++iTempCount )
-		        {        	
-		            dropItem( iDropItemID, 1 );
-		        }
-			}
-        }
-    }
-    
-    private void ModSpecificOnUpdate()
-    {
-        UpdateExhaustionWithTime();
-        
-        UpdateHealthAndHungerEffects();
-        
-        UpdateMagneticInfluences();
-        
-        UpdateSpawnChunksVisualization();
-        
-    	NotifyBlockWalkedOn();
-    }
-    
-	private void UpdateMagneticInfluences()
-	{
-		if ( ( worldObj.getTotalWorldTime() + entityId ) % 40 != 0 )
-		{
-			// stagger these updates as they can be performance intensive
-			 
-			return;
-		}
-		 
-		FCMagneticPoint strongestPoint = null;
-		double dStrongestFieldStrength = 0.0D;
-		 
-	    if ( worldObj.provider.isSurfaceWorld() )
-	    {
-	    	ChunkCoordinates spawnPos = worldObj.getSpawnPoint();
-	    	 
-	    	strongestPoint = new FCMagneticPoint( spawnPos.posX, 0, spawnPos.posZ, 2 );
-	    	 
-	    	dStrongestFieldStrength = strongestPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
-	    	 
-	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
-	         
-	        while ( pointIterator.hasNext() )
-	        {
-	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
-	        	 
-	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPosition( posX, posZ );
-	        	 
-	        	if ( dTempFieldStrength > dStrongestFieldStrength )
-	        	{
-	        		strongestPoint = tempPoint;
-	        		dStrongestFieldStrength = dTempFieldStrength;
-	        	}
-	        }
-	    }
-	    else
-	    {
-	        Iterator pointIterator = worldObj.GetMagneticPointList().m_MagneticPoints.iterator();
-	         
-	        while ( pointIterator.hasNext() )
-	        {
-	        	FCMagneticPoint tempPoint = (FCMagneticPoint)pointIterator.next();
-	        	 
-	        	double dTempFieldStrength = tempPoint.GetFieldStrengthRelativeToPositionWithBackgroundNoise( posX, posZ );
-	        	 
-	        	if ( dTempFieldStrength > dStrongestFieldStrength )
-	        	{
-	        		strongestPoint = tempPoint;
-	        		dStrongestFieldStrength = dTempFieldStrength;
-	        	}
-	        }
-	    }         
-	     
-	    if ( strongestPoint != null )
-	    {
-	    	SetHasValidMagneticPointForLocation( true );
-	    	SetStongestMagneticPointForLocationI( strongestPoint.m_iIPos );
-	    	SetStongestMagneticPointForLocationK( strongestPoint.m_iKPos );
-	    }
-	    else
-	    {
-	    	SetHasValidMagneticPointForLocation( false );
-	    }
-	}
-	
-	private void UpdateSpawnChunksVisualization()
-	{
-		if ( worldObj.provider.dimensionId == 0 && ( IsWearingEnderSpectacles() || 
-			isPotionActive( FCBetterThanWolves.potionTrueSight ) ) )
-		{
-			SetSpawnChunksVisualization( worldObj.worldInfo.getSpawnX(),
-				worldObj.worldInfo.getSpawnY(), worldObj.worldInfo.getSpawnZ() );
-		}
-		else
-		{
-			SetSpawnChunksVisualization( 0, 0, 0 );
-		}
-	}
-	
-    private void UpdateExhaustionWithTime()
-    {
-    	m_iExhaustionWithTimeCounter++;
-    	
-    	if ( m_iExhaustionWithTimeCounter >= m_iExhaustionWithTimePeriod )
-    	{
-            if ( !capabilities.disableDamage ) // disable hunger drain in creative
-            {
-            	foodStats.addExhaustion( m_fExhaustionWithTimeAmount );
-            }
-            
-    		m_iExhaustionWithTimeCounter = 0;
-    	}
-    }
-    
-    private void UpdateHealthAndHungerEffects()
-    {
-    	if ( !isDead && ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
-    	{
-    		if ( foodStats.getFoodLevel() <= 0 && foodStats.getSaturationLevel() <= 0F )
-    		{
-                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
-    		}
-    		
-    		if ( health <= 2 )
-    		{
-                addPotionEffect( new PotionEffect( Potion.blindness.getId(), 180, 0, true ) );                            
-    		}
-    	}
-    }
-    
-    @Override
-    protected void UpdateGloomState()
-    {
-    	if ( !isDead )
-    	{
-    		if ( IsInGloom() )
-    		{
-    			m_iInGloomCounter++;
-    			
-    			if ( GetGloomLevel() == 0 || ( m_iInGloomCounter > m_iGloomCounterBetweenStateChanges && GetGloomLevel() < 3 ) )
-    			{
-    				SetGloomLevel( GetGloomLevel() + 1 );
-    				
-    				m_iInGloomCounter = 0;
-    			}
-    			
-    			if ( GetGloomLevel() >= 3 )
-    			{
-    		    	if ( ( worldObj.getTotalWorldTime() + (long)entityId ) % 80L == 0L )
-    		    	{
-		                addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
-    		    	}
-    		    	
-    		    	// gloom bites
-    		    	
-    	    		float fCounterProgress = (float)m_iInGloomCounter / (float)m_iGloomCounterBetweenStateChanges;
-    	    		
-    	    		if ( fCounterProgress > 1.0F )
-    	    		{
-    	    			fCounterProgress = 1.0F;
-    	    		}
-
-            		float fGloomBiteChance = m_fMinimumGloomBiteChance + ( m_fMaximumGloomBiteChance - m_fMinimumGloomBiteChance ) * fCounterProgress;        		
-    	    		
-            		if ( rand.nextFloat() < fGloomBiteChance )
-            		{
-            			if ( attackEntityFrom( FCDamageSourceCustom.m_DamageSourceGloom, 1 ) )
-            			{            			
-	            			if ( health <= 0 )
-	            			{
-	            	        	worldObj.playAuxSFX( FCBetterThanWolves.m_iBurpSoundAuxFXID, 
-	            	        		MathHelper.floor_double( posX ), MathHelper.floor_double( posY ), MathHelper.floor_double( posZ ), 0 );
-	            			}
-            			}
-            		}
-		    	}
-    		}
-    		else
-    		{
-        		SetGloomLevel( 0 );
-        		
-        		m_iInGloomCounter = 0;
-    		}   		    		
-    	}
-    }
-
-    @Override
-    protected void UpdateFatPenaltyLevel()
-    {
-        int iFat = (int)foodStats.getSaturationLevel();
-    	int iFatLevel = 4;
-        
-        if ( iFat < 12 )
-        {
-        	iFatLevel = 0;
-        }
-        else if ( iFat < 14 )
-        {
-        	iFatLevel = 1;
-        }
-        else if ( iFat < 16 )
-        {
-        	iFatLevel = 2;
-        }
-        else if ( iFat < 18 )
-        {
-        	iFatLevel = 3;
-        }
-    	
-    	SetFatPenaltyLevel( iFatLevel );
-    }
-	
-    @Override
-	protected void UpdateHungerPenaltyLevel()
-	{
-        int iHunger = foodStats.getFoodLevel();
-        int iPenaltyLevel = 5;
-        
-        if ( iHunger > 24 )
-        {
-        	iPenaltyLevel = 0;
-        }
-        else if ( iHunger > 18 )
-        {
-        	iPenaltyLevel = 1;
-        }
-        else if ( iHunger > 12 )
-        {
-        	iPenaltyLevel = 2;
-        }
-        else if ( iHunger > 6 )
-        {
-        	iPenaltyLevel = 3;
-        }
-        else if ( iHunger > 0 || foodStats.getSaturationLevel() > 0F )
-        {
-        	iPenaltyLevel = 4;
-        }
-        
-        SetHungerPenaltyLevel( iPenaltyLevel );
-	}
-	
-    @Override
-	protected void UpdateHealthPenaltyLevel()
-	{
-		int iHealth = getHealth();
-        int iPenaltyLevel = 5;
-        
-        if ( iHealth > 10 )
-        {
-        	iPenaltyLevel = 0;
-        }
-        else if ( iHealth > 8 )
-        {
-        	iPenaltyLevel = 1;
-        }
-        else if ( iHealth > 6 )
-        {
-        	iPenaltyLevel = 2;
-        }
-        else if ( iHealth > 4 )
-        {
-        	iPenaltyLevel = 3;
-        }
-        else if ( iHealth > 2 )
-        {
-        	iPenaltyLevel = 4;
-        }
-        
-        SetHealthPenaltyLevel( iPenaltyLevel );
-	}
-	
-    private boolean IsInGloom()
-    {
-        if ( !capabilities.disableDamage ) // disable darkness effects in creative
-        {
-	        if ( !isPotionActive( Potion.nightVision ) && worldObj.provider.dimensionId == 0 )
-	        {
-		        int i = MathHelper.floor_double( posX );
-		        int j = MathHelper.floor_double( posY - yOffset );
-		        int k = MathHelper.floor_double( posZ );
-		        
-		        int iOldSkylightSubtracted = worldObj.skylightSubtracted;
-		        
-		        float fSunBrightness = worldObj.ComputeOverworldSunBrightnessWithMoonPhases();
-		        
-		        if ( fSunBrightness < 0.02D )
-		        {
-		        	// world is in gloom, no skylight at all
-		        	worldObj.skylightSubtracted = 15;
-		        }
-		        else
-		        {
-		        	worldObj.skylightSubtracted = (int)( ( 1F - fSunBrightness ) * 11.9F );
-		        }
-
-		        float fBlockInLightValue = worldObj.getLightBrightness( i, j, k );
-		        
-		        float fBlockAboveLightValue = worldObj.getLightBrightness( i, j + 1, k );
-		        
-		        if ( fBlockAboveLightValue > fBlockInLightValue )
-		        {
-		        	fBlockInLightValue = fBlockAboveLightValue;
-		        }
-		        
-		        worldObj.skylightSubtracted = iOldSkylightSubtracted;
-		        
-		    	return fBlockInLightValue < 0.001F;
-	        }
-        }
-        
-        return false;
-    }
-    
-	@Override    
-	public void AddRawChatMessage( String message )
-	{
-		playerNetServerHandler.sendPacket( new Packet3Chat( message ) );
-	}
-
-	@Override
-    protected void OnZeroDamageAttack()
-    {
-		long lCurrentTime = worldObj.getWorldTime();
-		
-		if ( lCurrentTime > m_lTimeOfLastZeroDamageAttackSound + m_iDelayBetweenZeroDamageAttackSounds )
-		{
-			worldObj.playSoundAtEntity( this, 
-	    		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
-	    		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
-			
-			m_lTimeOfLastZeroDamageAttackSound = lCurrentTime;
-		}
-    }
-
-	@Override
-    public void OnStruckByLightning( FCEntityLightningBolt boltEntity )
-    {
-        if ( !capabilities.disableDamage )
-        {
-            dealFireDamage( 12 );
-            
-            setFire( 8 );
-
-        	FlingAwayFromEntity( boltEntity, 2D );
-    		
-    		worldObj.playSoundAtEntity( this, 
-        		"random.classic_hurt", 1.0F +  rand.nextFloat() * 0.25F, 
-        		getSoundPitch() * 1.20F + rand.nextFloat() * 0.1F);
-    		
-            addPotionEffect( new PotionEffect( Potion.blindness.getId(), 90, 0, true ) );
-            
-            addPotionEffect( new PotionEffect( Potion.confusion.getId(), 180, 0, true ) );                            
-        }
-    }
-	
-    public int IncrementAndGetWindowID()
-    {
-        this.currentWindowId = this.currentWindowId % 100 + 1;
-        
-        return currentWindowId;
-    }
-    
-    private void NotifyBlockWalkedOn()
-    {
-        if ( onGround )
-        {
-        	int iGroundI = MathHelper.floor_double( posX );
-        	int iGroundJ = MathHelper.floor_double( posY - 0.03D - (double)yOffset ); // same calc used for step sound
-        	int iGroundK = MathHelper.floor_double( posZ );
-        	
-        	Block blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-
-        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-        	{
-        		float fHalfWidth = width / 2F;
-        		
-        		// block we are standing on directly is air or has no collision box.  Check the horizontal extents of our box for a movement modifier
-
-        		int iCenterGroundI = iGroundI;
-        		
-        		iGroundI = MathHelper.floor_double( posX + fHalfWidth );	        		
-	        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-	        	
-	        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-	        	{
-	        		iGroundI = MathHelper.floor_double( posX - fHalfWidth );
-		        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-		        	
-		        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-		        	{
-		        		iGroundI = iCenterGroundI;
-		        		
-		        		iGroundK = MathHelper.floor_double( posZ + fHalfWidth );
-			        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];
-			        	
-			        	if ( blockOn == null || blockOn.getCollisionBoundingBoxFromPool( worldObj, iGroundI, iGroundJ, iGroundK ) == null )
-			        	{
-			        		iGroundK = MathHelper.floor_double( posZ - fHalfWidth );
-				        	blockOn = Block.blocksList[worldObj.getBlockId( iGroundI, iGroundJ, iGroundK )];					        	
-			        	}
-		        	}
-	        	}	        	
-        	}
-        	
-        	if ( blockOn != null )
-        	{
-        		blockOn.OnPlayerWalksOnBlock( worldObj, iGroundI, iGroundJ, iGroundK, this );        		
-        	}
-        }        
-    }
-    
-    public void SendChunksToClient()
-    {
-        if ( !m_chunksToBeSentToClient.isEmpty() )
-        {
-            Iterator<ChunkCoordIntPair> coordIterator = m_chunksToBeSentToClient.iterator();
-            
-            ArrayList<Chunk> chunksToSend = new ArrayList<Chunk>();
-            ArrayList<TileEntity> tileEntitiesToSend = new ArrayList<TileEntity>();
-
-            while ( coordIterator.hasNext() && chunksToSend.size() < 5 )
-            {
-                ChunkCoordIntPair tempCoord = coordIterator.next();
-                coordIterator.remove();
-
-                if ( tempCoord != null && worldObj.chunkExists( 
-                	tempCoord.chunkXPos, tempCoord.chunkZPos ) )
-                {
-                    chunksToSend.add( worldObj.getChunkFromChunkCoords(
-                    	tempCoord.chunkXPos, tempCoord.chunkZPos ) );
-                    
-                    tileEntitiesToSend.addAll( getServerForPlayer().getAllTileEntityInBox(
-                    	tempCoord.chunkXPos * 16, 0, tempCoord.chunkZPos * 16, 
-                    	tempCoord.chunkXPos * 16 + 16, 256, tempCoord.chunkZPos * 16 + 16));
-                }
-            }
-
-            if ( !chunksToSend.isEmpty() )
-            {
-	        	FCUtilsWorld.SendPacketToPlayer( playerNetServerHandler, 
-	        		new Packet56MapChunks( chunksToSend ) );
-	        	
-                Iterator<TileEntity> tileIterator = tileEntitiesToSend.iterator();
-
-                while ( tileIterator.hasNext() )
-                {
-                    TileEntity tempTile = (TileEntity)tileIterator.next();
-                    
-                    sendTileEntityToPlayer( tempTile );
-                }
-
-                Iterator<Chunk> chunkIterator = chunksToSend.iterator();
-
-                while ( chunkIterator.hasNext() )
-                {
-                    Chunk var10 = chunkIterator.next();
-                    
-                    // the following call checks for entities in the chunk, and starts the player
-                    // watching them for updates
-                    getServerForPlayer().getEntityTracker().func_85172_a( this, var10 );
-                }
-            }
-        }
-    }
-	// END FCMOD
 }
--- EntitySheep.java	Mon Jul 23 23:18:05 2018
+++ EntitySheep.java	Fri Apr 20 22:33:11 2018
@@ -1,9 +1,5 @@
-// FCMOD: Class changes deprecated 07/23/2018
-
 package net.minecraft.src;
 
-import java.util.Iterator;
-import java.util.List;
 import java.util.Random;
 
 public class EntitySheep extends EntityAnimal
@@ -99,7 +95,7 @@
      */
     protected int getDropItemId()
     {
-    	return Block.cloth.blockID;
+        return Block.cloth.blockID;
     }
 
     /**
--- EntitySilverfish.java	Tue Jan 22 17:08:33 2019
+++ EntitySilverfish.java	Fri Apr 20 22:33:11 2018
@@ -177,16 +177,7 @@
 
                 if (BlockSilverfish.getPosingIdByMetadata(var5))
                 {
-                	// FCMOD: Code change
-                	/*
                     this.worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], Block.silverfish.blockID, BlockSilverfish.getMetadataForBlockType(var5), 3);
-                    */
-                	int iNewBlockMetadata = FCBlockSilverfish.GetMetadataConversionOnInfest( var5, 
-                		worldObj.getBlockMetadata( var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9] ) );
-                	
-                    worldObj.setBlock(var1 + Facing.offsetsXForSide[var9], var2 + Facing.offsetsYForSide[var9], var3 + Facing.offsetsZForSide[var9], 
-                    	Block.silverfish.blockID, iNewBlockMetadata, 3);
-                	// END FCMOD
                     this.spawnExplosionParticle();
                     this.setDead();
                 }
@@ -250,34 +241,4 @@
     {
         return EnumCreatureAttribute.ARTHROPOD;
     }
-    
-    // FCMOD: Code added
-    @Override
-    protected void dropFewItems( boolean bKilledByPlayer, int iLootingModifier )
-    {
-    	if ( worldObj.provider.dimensionId == 1 )
-    	{
-	        int iDropChance = this.rand.nextInt( 5 ) - 3 + iLootingModifier;
-	
-	        if ( iDropChance > 0 )
-	        {
-	            dropItem( Item.clay.itemID, 1 );
-	        }
-    	}
-    }
-    
-    @Override
-    public void CheckForScrollDrop()
-    {    	
-    	if ( worldObj.provider.dimensionId == 1 )
-    	{
-	    	if ( rand.nextInt( 1000 ) == 0 )
-	    	{
-	    		ItemStack itemstack = new ItemStack( FCBetterThanWolves.fcItemArcaneScroll, 1, Enchantment.efficiency.effectId );
-	            
-	            entityDropItem(itemstack, 0.0F);
-	    	}
-    	}
-    }    
-    // END FCMOD
 }
--- EntitySkeleton.java	Wed Sep 26 13:23:04 2018
+++ EntitySkeleton.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/26/2018
-
 package net.minecraft.src;
 
 import java.util.Calendar;
--- EntitySlime.java	Mon Sep 24 14:38:20 2018
+++ EntitySlime.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/24/2018
-
 package net.minecraft.src;
 
 public class EntitySlime extends EntityLiving implements IMob
@@ -163,7 +161,7 @@
             }
 
             this.moveStrafing = 1.0F - this.rand.nextFloat() * 2.0F;
-            this.moveForward = (float)(1 * this.getSlimeSize());            
+            this.moveForward = (float)(1 * this.getSlimeSize());
         }
         else
         {
--- EntitySnowman.java	Thu Dec 27 22:17:34 2018
+++ EntitySnowman.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 12/27/2018
-
 package net.minecraft.src;
 
 public class EntitySnowman extends EntityGolem implements IRangedAttackMob
--- EntitySpider.java	Fri Jun 15 19:15:13 2018
+++ EntitySpider.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 public class EntitySpider extends EntityMob
--- EntityTameable.java	Sat Jan 12 21:32:25 2019
+++ EntityTameable.java	Fri Apr 20 22:33:11 2018
@@ -131,17 +131,4 @@
     {
         return this.aiSit;
     }
-
-    // FCMOD: Code Added
-    @Override
-    public boolean IsSecondaryTargetForSquid()
-    {
-    	return false;
-    }
-    
-    public boolean IsAITryingToSit()
-    {
-    	return aiSit.IsTryingToSit();
-    }
-    // END FCMOD
 }
--- EntityThrowable.java	Fri Jun 14 13:30:06 2013
+++ EntityThrowable.java	Fri Apr 20 22:33:11 2018
@@ -131,12 +131,7 @@
 
         Vec3 var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         Vec3 var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
-        // FCMOD: Code change to ignore transparent type blocks like tall grass
-        /*
         MovingObjectPosition var3 = this.worldObj.rayTraceBlocks(var16, var2);
-        */
-        MovingObjectPosition var3 = this.worldObj.rayTraceBlocks_do_do(var16, var2, false, true);
-        // END FCMOD
         var16 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX, this.posY, this.posZ);
         var2 = this.worldObj.getWorldVec3Pool().getVecFromPool(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
 
@@ -303,11 +298,4 @@
 
         return this.thrower;
     }
-    
-    // FCMOD: Code added
-    protected void SetThrower( EntityLiving throwerParam )
-    {
-    	thrower = throwerParam;
-    }
-    // END FCMOD
 }
--- EntityTracker.java	Wed Oct  3 14:21:25 2018
+++ EntityTracker.java	Fri Apr 20 22:33:11 2018
@@ -42,17 +42,6 @@
                 }
             }
         }
-        // FCMOD: Code added
-        else if ( par1Entity instanceof FCIEntityPacketHandler )
-        {
-        	FCIEntityPacketHandler fcEntity = (FCIEntityPacketHandler)par1Entity;
-        	
-        	// client
-            //addEntityToTracker( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
-            // server
-            trackEntity( par1Entity, fcEntity.GetTrackerViewDistance(), fcEntity.GetTrackerUpdateFrequency(), fcEntity.GetTrackMotion() );
-        }
-        // END FCMOD
         else if (par1Entity instanceof EntityFishHook)
         {
             this.trackEntity(par1Entity, 64, 5, true);
@@ -109,24 +98,15 @@
         {
             this.trackEntity(par1Entity, 80, 3, true);
         }
-        // FCMOD: Changed
-        //else if (par1Entity instanceof EntitySquid)
-        else if ( par1Entity instanceof FCEntitySquid )
-    	// END FCMOD
+        else if (par1Entity instanceof EntitySquid)
         {
             this.trackEntity(par1Entity, 64, 3, true);
         }
-        // FCMOD: Changed
-        //else if (par1Entity instanceof EntityWither)
-        else if ( par1Entity instanceof FCEntityWither )
-    	// END FCMOD
+        else if (par1Entity instanceof EntityWither)
         {
             this.trackEntity(par1Entity, 80, 3, false);
         }
-        // FCMOD: Changed
-        //else if (par1Entity instanceof EntityBat)
-        else if ( par1Entity instanceof FCEntityBat )
-    	// END FCMOD
+        else if (par1Entity instanceof EntityBat)
         {
             this.trackEntity(par1Entity, 80, 3, false);
         }
--- EntityTrackerEntry.java	Sun Oct 28 17:47:26 2018
+++ EntityTrackerEntry.java	Fri Apr 20 22:33:11 2018
@@ -105,12 +105,7 @@
             if (var24 != null && var24.getItem() instanceof ItemMap)
             {
                 MapData var26 = Item.map.getMapData(var24, this.trackedEntity.worldObj);
-                // FCMOD: Code change to send map data to all visible players rather than tracked ones
-                /*
                 Iterator var29 = par1List.iterator();
-                */
-                Iterator var29 = trackingPlayers.iterator();
-                // END FCMOD
 
                 while (var29.hasNext())
                 {
@@ -120,19 +115,12 @@
 
                     if (var31.playerNetServerHandler.getNumChunkDataPackets() <= 5)
                     {
-                    	// FCMOD: Code added so that players only receive data on their own position
-                    	var26.func_82568_a( var30 );
-                    	// END FCMOD
-
                         Packet var32 = Item.map.getUpdatePacket(var24, this.trackedEntity.worldObj, var31);
 
                         if (var32 != null)
                         {
                             var31.playerNetServerHandler.sendPacket(var32);
                         }
-                    	// FCMOD: Code added so that players only receive data on their own position
-                    	var26.playersVisibleOnMap.clear();
-                    	// END FCMOD
                     }
                 }
             }
@@ -399,15 +387,7 @@
 
     private boolean isPlayerWatchingThisChunk(EntityPlayerMP par1EntityPlayerMP)
     {
-    	// FCMOD: Changed    	
-        //return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
-        return par1EntityPlayerMP.getServerForPlayer().
-        	GetChunkTracker().IsChunkWatchedByPlayerAndSentToClient(
-        	// client 
-        	//par1EntityPlayerMP, this.myEntity.chunkCoordX, this.myEntity.chunkCoordZ);
-            // server
-    		par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
-        // END FCMOD
+        return par1EntityPlayerMP.getServerForPlayer().getPlayerManager().isPlayerWatchingChunk(par1EntityPlayerMP, this.trackedEntity.chunkCoordX, this.trackedEntity.chunkCoordZ);
     }
 
     public void updatePlayerEntities(List par1List)
@@ -425,21 +405,6 @@
             this.trackedEntity.worldObj.getWorldLogAgent().func_98236_b("Fetching addPacket for removed entity");
         }
 
-        // FCMOD: Code added.  This is at the top of all the following code due to some mod entities inheriting from the ones below
-        // client
-        //if ( myEntity instanceof FCIEntityPacketHandler )
-    	// server
-        if ( trackedEntity instanceof FCIEntityPacketHandler )        	
-        {
-        	// client
-        	//FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)myEntity;
-        	// server
-        	FCIEntityPacketHandler packetHandler = (FCIEntityPacketHandler)trackedEntity;
-        	
-    		return packetHandler.GetSpawnPacketForThisEntity();
-        }
-        // END FCMOD
-        
         if (this.trackedEntity instanceof EntityItem)
         {
             return new Packet23VehicleSpawn(this.trackedEntity, 2, 1);
--- EntityVillager.java	Tue Oct  2 00:31:46 2018
+++ EntityVillager.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Note that in the server version of this file, I've renamed functions to match the client
-
 package net.minecraft.src;
 
 import java.util.Collections;
@@ -19,25 +17,22 @@
     private EntityPlayer buyingPlayer;
 
     /** Initialises the MerchantRecipeList.java */
-    // FCMOD: Changed
-    //private MerchantRecipeList buyingList;
-    protected MerchantRecipeList buyingList;
-    // END FCMOD
-
+    private MerchantRecipeList buyingList;
     private int timeUntilReset;
-    
+
     /** addDefaultEquipmentAndRecipies is called if this is true */
     private boolean needsInitilization;
-    
     private int wealth;
 
     /** Last player to trade with this villager, used for aggressivity. */
     private String lastBuyingPlayer;
-    
     private boolean field_82190_bM;
     private float field_82191_bN;
 
-    private static final Map villagerStockList = new HashMap();
+    /** Selling list of Villagers items. */
+    private static final Map villagersSellingList = new HashMap();
+
+    /** Selling list of Blacksmith items. */
     private static final Map blacksmithSellingList = new HashMap();
 
     public EntityVillager(World par1World)
@@ -419,7 +414,7 @@
         switch (this.getProfession())
         {
             case 0:
-                addMerchantItem(var2, Item.wheat.itemID, this.rand, this.func_82188_j(0.9F));                
+                addMerchantItem(var2, Item.wheat.itemID, this.rand, this.func_82188_j(0.9F));
                 addMerchantItem(var2, Block.cloth.blockID, this.rand, this.func_82188_j(0.5F));
                 addMerchantItem(var2, Item.chickenRaw.itemID, this.rand, this.func_82188_j(0.5F));
                 addMerchantItem(var2, Item.fishCooked.itemID, this.rand, this.func_82188_j(0.4F));
@@ -567,7 +562,7 @@
      */
     private static int getRandomCountForItem(int par0, Random par1Random)
     {
-        Tuple var2 = (Tuple)villagerStockList.get(Integer.valueOf(par0));
+        Tuple var2 = (Tuple)villagersSellingList.get(Integer.valueOf(par0));
         return var2 == null ? 1 : (((Integer)var2.getFirst()).intValue() >= ((Integer)var2.getSecond()).intValue() ? ((Integer)var2.getFirst()).intValue() : ((Integer)var2.getFirst()).intValue() + par1Random.nextInt(((Integer)var2.getSecond()).intValue() - ((Integer)var2.getFirst()).intValue()));
     }
 
@@ -627,25 +622,25 @@
 
     static
     {
-        villagerStockList.put(Integer.valueOf(Item.coal.itemID), new Tuple(Integer.valueOf(16), Integer.valueOf(24)));
-        villagerStockList.put(Integer.valueOf(Item.ingotIron.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
-        villagerStockList.put(Integer.valueOf(Item.ingotGold.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
-        villagerStockList.put(Integer.valueOf(Item.diamond.itemID), new Tuple(Integer.valueOf(4), Integer.valueOf(6)));
-        villagerStockList.put(Integer.valueOf(Item.paper.itemID), new Tuple(Integer.valueOf(24), Integer.valueOf(36)));
-        villagerStockList.put(Integer.valueOf(Item.book.itemID), new Tuple(Integer.valueOf(11), Integer.valueOf(13)));
-        villagerStockList.put(Integer.valueOf(Item.writtenBook.itemID), new Tuple(Integer.valueOf(1), Integer.valueOf(1)));
-        villagerStockList.put(Integer.valueOf(Item.enderPearl.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
-        villagerStockList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(2), Integer.valueOf(3)));
-        villagerStockList.put(Integer.valueOf(Item.porkRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagerStockList.put(Integer.valueOf(Item.beefRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagerStockList.put(Integer.valueOf(Item.chickenRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
-        villagerStockList.put(Integer.valueOf(Item.fishCooked.itemID), new Tuple(Integer.valueOf(9), Integer.valueOf(13)));
-        villagerStockList.put(Integer.valueOf(Item.seeds.itemID), new Tuple(Integer.valueOf(34), Integer.valueOf(48)));
-        villagerStockList.put(Integer.valueOf(Item.melonSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
-        villagerStockList.put(Integer.valueOf(Item.pumpkinSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
-        villagerStockList.put(Integer.valueOf(Item.wheat.itemID), new Tuple(Integer.valueOf(18), Integer.valueOf(22)));
-        villagerStockList.put(Integer.valueOf(Block.cloth.blockID), new Tuple(Integer.valueOf(14), Integer.valueOf(22)));
-        villagerStockList.put(Integer.valueOf(Item.rottenFlesh.itemID), new Tuple(Integer.valueOf(36), Integer.valueOf(64)));
+        villagersSellingList.put(Integer.valueOf(Item.coal.itemID), new Tuple(Integer.valueOf(16), Integer.valueOf(24)));
+        villagersSellingList.put(Integer.valueOf(Item.ingotIron.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
+        villagersSellingList.put(Integer.valueOf(Item.ingotGold.itemID), new Tuple(Integer.valueOf(8), Integer.valueOf(10)));
+        villagersSellingList.put(Integer.valueOf(Item.diamond.itemID), new Tuple(Integer.valueOf(4), Integer.valueOf(6)));
+        villagersSellingList.put(Integer.valueOf(Item.paper.itemID), new Tuple(Integer.valueOf(24), Integer.valueOf(36)));
+        villagersSellingList.put(Integer.valueOf(Item.book.itemID), new Tuple(Integer.valueOf(11), Integer.valueOf(13)));
+        villagersSellingList.put(Integer.valueOf(Item.writtenBook.itemID), new Tuple(Integer.valueOf(1), Integer.valueOf(1)));
+        villagersSellingList.put(Integer.valueOf(Item.enderPearl.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
+        villagersSellingList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(2), Integer.valueOf(3)));
+        villagersSellingList.put(Integer.valueOf(Item.porkRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagersSellingList.put(Integer.valueOf(Item.beefRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagersSellingList.put(Integer.valueOf(Item.chickenRaw.itemID), new Tuple(Integer.valueOf(14), Integer.valueOf(18)));
+        villagersSellingList.put(Integer.valueOf(Item.fishCooked.itemID), new Tuple(Integer.valueOf(9), Integer.valueOf(13)));
+        villagersSellingList.put(Integer.valueOf(Item.seeds.itemID), new Tuple(Integer.valueOf(34), Integer.valueOf(48)));
+        villagersSellingList.put(Integer.valueOf(Item.melonSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
+        villagersSellingList.put(Integer.valueOf(Item.pumpkinSeeds.itemID), new Tuple(Integer.valueOf(30), Integer.valueOf(38)));
+        villagersSellingList.put(Integer.valueOf(Item.wheat.itemID), new Tuple(Integer.valueOf(18), Integer.valueOf(22)));
+        villagersSellingList.put(Integer.valueOf(Block.cloth.blockID), new Tuple(Integer.valueOf(14), Integer.valueOf(22)));
+        villagersSellingList.put(Integer.valueOf(Item.rottenFlesh.itemID), new Tuple(Integer.valueOf(36), Integer.valueOf(64)));
         blacksmithSellingList.put(Integer.valueOf(Item.flintAndSteel.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
         blacksmithSellingList.put(Integer.valueOf(Item.shears.itemID), new Tuple(Integer.valueOf(3), Integer.valueOf(4)));
         blacksmithSellingList.put(Integer.valueOf(Item.swordIron.itemID), new Tuple(Integer.valueOf(7), Integer.valueOf(11)));
@@ -692,21 +687,4 @@
         blacksmithSellingList.put(Integer.valueOf(Item.eyeOfEnder.itemID), new Tuple(Integer.valueOf(7), Integer.valueOf(11)));
         blacksmithSellingList.put(Integer.valueOf(Item.arrow.itemID), new Tuple(Integer.valueOf(-12), Integer.valueOf(-8)));
     }
-    
-    // FCMOD: Added to satisfy IMerchant
-    public int GetCurrentTradeLevel() 
-    {
-    	return 0;
-    }
-    
-    public int GetCurrentTradeXP()
-    {
-    	return 0;
-    }
-    
-    public int GetCurrentTradeMaxXP()
-    {
-    	return 0;
-    }
-    // END FCMOD
 }
--- EntityWaterMob.java	Thu Aug 29 15:46:53 2013
+++ EntityWaterMob.java	Fri Apr 20 22:33:11 2018
@@ -52,12 +52,7 @@
         int var1 = this.getAir();
         super.onEntityUpdate();
 
-        // FCMOD: Change to be more forgiving on whether the squid is in water or not 
-        /*
         if (this.isEntityAlive() && !this.isInsideOfMaterial(Material.water))
-        */
-        if (this.isEntityAlive() && !inWater)
-        // END FCMOD
         {
             --var1;
             this.setAir(var1);
--- EntityWitch.java	Sun Sep 23 13:07:03 2018
+++ EntityWitch.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/23/2018
-
 package net.minecraft.src;
 
 import java.util.Iterator;
--- EntityWither.java	Sat Oct 20 15:34:02 2018
+++ EntityWither.java	Fri Apr 20 22:33:11 2018
@@ -234,11 +234,7 @@
                 {
                     this.field_82223_h[var1 - 1] = this.ticksExisted + 10 + this.rand.nextInt(10);
 
-                    // FCMOD: Code removed so that skulls launch on easy difficulty
-                    /*
                     if (this.worldObj.difficultySetting >= 2)
-                    */
-                    // END FCMOD
                     {
                         int var10001 = var1 - 1;
                         int var10003 = this.field_82224_i[var1 - 1];
@@ -335,13 +331,7 @@
                                 int var10 = var15 + var19;
                                 int var11 = this.worldObj.getBlockId(var20, var9, var10);
 
-                                // FCMOD: Change
-                                /*
                                 if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID)
-                                */                                	
-                                if (var11 > 0 && var11 != Block.bedrock.blockID && var11 != Block.endPortal.blockID && var11 != Block.endPortalFrame.blockID &&
-                                	var11 != FCBetterThanWolves.fcSoulforgedSteelBlock.blockID )
-                            	// END FCMOD
                                 {
                                     var18 = this.worldObj.destroyBlock(var20, var9, var10, true) || var18;
                                 }
@@ -446,10 +436,7 @@
         double var15 = par2 - var9;
         double var17 = par4 - var11;
         double var19 = par6 - var13;
-        // FCMOD: Changed
-        //EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
-        FCEntityWitherSkull var21 = new FCEntityWitherSkull(this.worldObj, this, var15, var17, var19);
-        // END FCMOD
+        EntityWitherSkull var21 = new EntityWitherSkull(this.worldObj, this, var15, var17, var19);
 
         if (par8)
         {
--- EntityWitherSkull.java	Sat Oct 20 14:42:08 2018
+++ EntityWitherSkull.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 10/20/2018
-
 package net.minecraft.src;
 
 public class EntityWitherSkull extends EntityFireball
--- EntityWolf.java	Mon Sep 10 14:19:00 2018
+++ EntityWolf.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/10/2018
-
 package net.minecraft.src;
 
 public class EntityWolf extends EntityTameable
--- EntityXPOrb.java	Sun Dec 23 17:34:27 2018
+++ EntityXPOrb.java	Fri Apr 20 22:33:11 2018
@@ -2,10 +2,6 @@
 
 public class EntityXPOrb extends Entity
 {
-    // FCMOD: Code added
-    public boolean m_bNotPlayerOwned = false;
-    // END FCMOD
-    
     /**
      * A constantly increasing value that RenderXPOrb uses to control the colour shifting (Green / yellow)
      */
@@ -19,12 +15,7 @@
     private int xpOrbHealth = 5;
 
     /** This is how much XP this orb has. */
-    // FCMOD: Changed to public
-	/*
     private int xpValue;
-	*/
-    public int xpValue;
-    // END FCMOD
 
     /** The closest EntityPlayer to this orb. */
     private EntityPlayer closestPlayer;
@@ -32,23 +23,10 @@
     /** Threshold color for tracking players */
     private int xpTargetColor;
 
-    // FCMOD: Method added
-    public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8, boolean bNotPlayerOwned )
-    {
-    	this( par1World, par2, par4, par6, par8 );
-        m_bNotPlayerOwned = bNotPlayerOwned;
-    }
-    // END FCMOD
-
     public EntityXPOrb(World par1World, double par2, double par4, double par6, int par8)
     {
         super(par1World);
-        // FCMOD: Line changed so XP orbs will fit through tight spaces (set to same size as items)
-		/*
         this.setSize(0.5F, 0.5F);
-		*/
-        setSize(0.25F, 0.25F);
-        // END FCMOD
         this.yOffset = this.height / 2.0F;
         this.setPosition(par2, par4, par6);
         this.rotationYaw = (float)(Math.random() * 360.0D);
@@ -101,23 +79,13 @@
             this.playSound("random.fizz", 0.4F, 2.0F + this.rand.nextFloat() * 0.4F);
         }
 
-        // FCMOD: Changed to reduce discrepancies between client and server by 
-        // pusing only on server
-        //this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
-        if ( !worldObj.isRemote )
-        {
-            pushOutOfBlocks( posX, ( boundingBox.minY + boundingBox.maxY) / 2D, posZ );
-        }
-    	// END FCMOD
+        this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
         double var1 = 8.0D;
 
         if (this.xpTargetColor < this.xpColor - 20 + this.entityId % 100)
         {
             if (this.closestPlayer == null || this.closestPlayer.getDistanceSqToEntity(this) > var1 * var1)
             {
-				// FCMOD: Added
-		        if ( !m_bNotPlayerOwned )
-	        	// END FCMOD
                 this.closestPlayer = this.worldObj.getClosestPlayerToEntity(this, var1);
             }
 
@@ -129,21 +97,11 @@
             double var3 = (this.closestPlayer.posX - this.posX) / var1;
             double var5 = (this.closestPlayer.posY + (double)this.closestPlayer.getEyeHeight() - this.posY) / var1;
             double var7 = (this.closestPlayer.posZ - this.posZ) / var1;
-            // FCMOD: Code Changed for optimization
-            /*
             double var9 = Math.sqrt(var3 * var3 + var5 * var5 + var7 * var7);
             double var11 = 1.0D - var9;
 
             if (var11 > 0.0D)
             {
-            */
-            double dDistanceSq = var3 * var3 + var5 * var5 + var7 * var7;
-
-            if (dDistanceSq < 1.0D)
-            {
-                double var9 = Math.sqrt( dDistanceSq );
-                double var11 = 1.0D - var9;
-            // 	END FCMOD
                 var11 *= var11;
                 this.motionX += var3 / var9 * var11 * 0.1D;
                 this.motionY += var5 / var9 * var11 * 0.1D;
@@ -231,9 +189,6 @@
         par1NBTTagCompound.setShort("Health", (short)((byte)this.xpOrbHealth));
         par1NBTTagCompound.setShort("Age", (short)this.xpOrbAge);
         par1NBTTagCompound.setShort("Value", (short)this.xpValue);
-        // FCMOD: Code added        
-        par1NBTTagCompound.setBoolean("m_bNotPlayerOwned", m_bNotPlayerOwned);
-        // END FCMOD
     }
 
     /**
@@ -244,12 +199,6 @@
         this.xpOrbHealth = par1NBTTagCompound.getShort("Health") & 255;
         this.xpOrbAge = par1NBTTagCompound.getShort("Age");
         this.xpValue = par1NBTTagCompound.getShort("Value");
-        // FCMOD: Code added        
-        if ( par1NBTTagCompound.hasKey( "m_bNotPlayerOwned" ) )
-        {
-        	m_bNotPlayerOwned = par1NBTTagCompound.getBoolean( "m_bNotPlayerOwned" );
-        }
-        // END FCMOD
     }
 
     /**
@@ -257,12 +206,6 @@
      */
     public void onCollideWithPlayer(EntityPlayer par1EntityPlayer)
     {
-        // FCMOD: Code added
-    	if ( m_bNotPlayerOwned )
-    	{
-    		return;
-    	}
-    	// END FCMOD
         if (!this.worldObj.isRemote)
         {
             if (this.field_70532_c == 0 && par1EntityPlayer.xpCooldown == 0)
@@ -299,42 +242,4 @@
     {
         return false;
     }
-    
-    // FCMOD: inherited function added so that blocks like Hoppers get collision events with items on top.  
-    // Copy of code from Entity.java, changes marked with FCMOD.
-    @Override
-    protected void doBlockCollisions()
-    {
-        int i = MathHelper.floor_double(boundingBox.minX + 0.001D);
-        // FCMOD: code change
-        /*
-        int j = MathHelper.floor_double(boundingBox.minY + 0.001D);
-        */
-        int j = MathHelper.floor_double(boundingBox.minY - 0.01D);
-        // END FCMOD
-        int k = MathHelper.floor_double(boundingBox.minZ + 0.001D);
-        int l = MathHelper.floor_double(boundingBox.maxX - 0.001D);
-        int i1 = MathHelper.floor_double(boundingBox.maxY - 0.001D);
-        int j1 = MathHelper.floor_double(boundingBox.maxZ - 0.001D);
-
-        if (worldObj.checkChunksExist(i, j, k, l, i1, j1))
-        {
-            for (int k1 = i; k1 <= l; k1++)
-            {
-                for (int l1 = j; l1 <= i1; l1++)
-                {
-                    for (int i2 = k; i2 <= j1; i2++)
-                    {
-                        int j2 = worldObj.getBlockId(k1, l1, i2);
-
-                        if (j2 > 0)
-                        {
-                            Block.blocksList[j2].onEntityCollidedWithBlock(worldObj, k1, l1, i2, this);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    // END FCMOD
 }
--- EntityZombie.java	Fri Jun 15 19:08:01 2018
+++ EntityZombie.java	Fri Apr 20 22:33:11 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 06/15/2018
-
 package net.minecraft.src;
 
 import java.util.Calendar;
--- EnumAction.java	Fri Mar  9 17:57:38 2018
+++ EnumAction.java	Fri Apr 20 22:33:11 2018
@@ -6,9 +6,5 @@
     eat,
     drink,
     block,
-    // FCMOD: Changed
-    //bow;
-    bow,
-    miscUse;
-    // END FCMOD
+    bow;
 }
--- EnumArmorMaterial.java	Sun Sep 15 18:55:52 2013
+++ EnumArmorMaterial.java	Fri Apr 20 22:33:11 2018
@@ -2,16 +2,9 @@
 
 public enum EnumArmorMaterial
 {
-	// FCMOD: Change to increase durability of armors, and change iron enchantibility to equal diamond
-	/*
     CLOTH(5, new int[]{1, 3, 2, 1}, 15),
     CHAIN(15, new int[]{2, 5, 4, 1}, 12),
     IRON(15, new int[]{2, 6, 5, 2}, 9),
-    */
-    CLOTH(10, new int[]{1, 3, 2, 1}, 15),
-    CHAIN(20, new int[]{2, 5, 4, 1}, 12),
-    IRON(20, new int[]{2, 6, 5, 2}, 10),
-    // END FCMOD
     GOLD(7, new int[]{2, 5, 3, 1}, 25),
     DIAMOND(33, new int[]{3, 8, 6, 3}, 10);
 
--- EnumCreatureType.java	Fri Nov  9 11:48:36 2018
+++ EnumCreatureType.java	Fri Apr 20 22:33:11 2018
@@ -2,11 +2,7 @@
 
 public enum EnumCreatureType
 {
-	// FCMOD: Changed to increase mob cap to compensate for rectangular instead of spherical despawn
-	// volume causing decreased mob density	
-    //monster(IMob.class, 70, Material.air, false, false),
-    monster( IMob.class, 90, Material.air, false, false ),
-	// END FCMOD
+    monster(IMob.class, 70, Material.air, false, false),
     creature(EntityAnimal.class, 10, Material.air, true, true),
     ambient(EntityAmbientCreature.class, 15, Material.air, true, false),
     waterCreature(EntityWaterMob.class, 5, Material.water, true, false);
--- EnumToolMaterial.java	Fri Mar  8 15:35:23 2019
+++ EnumToolMaterial.java	Fri Apr 20 22:33:11 2018
@@ -2,24 +2,11 @@
 
 public enum EnumToolMaterial
 {
-	// FCMOD: Change to rebalance value of early game tools and value of iron
-	/*
     WOOD(0, 59, 2.0F, 0, 15),
     STONE(1, 131, 4.0F, 1, 5),
     IRON(2, 250, 6.0F, 2, 14),
     EMERALD(3, 1561, 8.0F, 3, 10),
     GOLD(0, 32, 12.0F, 0, 22);
-    */
-	// FCNOTE: Min efficiency is slightly greater than 1 due to > 1 test elsewhere in the code, 
-	// There's one such test in EntityPlayer.getCurrentPlayerStrVsBlock() but I'm not sure 
-	// it's the only one I was referring to in this comment when first written    
-	WOOD( 0, 10, 1.01F, 0, 0, 20, 2 ),  // no vanilla enchant of wood
-    STONE( 1, 50, 1.01F, 1, 5, 10, 1 ), 
-    IRON( 2, 500, 6F, 2, 14, 25, 2 ),
-    EMERALD( 3, 1561, 8F, 3, 14, 30, 2 ),
-    GOLD( 0, 32, 12F, 0, 22, 30, 3 ),
-    SOULFORGED_STEEL( 4, 2250, 12F, 4, 0, 30, 4 );
-    // END FCMOD
 
     /**
      * The level of material this tool can harvest (3 = DIAMOND, 2 = IRON, 1 = STONE, 0 = IRON/GOLD)
@@ -42,8 +29,6 @@
     /** Defines the natural enchantability factor of the material. */
     private final int enchantability;
 
-    // FCMOD: Changed
-    /*
     private EnumToolMaterial(int par3, int par4, float par5, int par6, int par7)
     {
         this.harvestLevel = par3;
@@ -52,20 +37,6 @@
         this.damageVsEntity = par6;
         this.enchantability = par7;
     }
-    */
-    private EnumToolMaterial( int iHarvestLevel, int iMaxUses, float fEffeciency, int iWeaponDamage, 
-    	int iEnchantability, int iInfernalMaxEnchantmentCost, int iInfernalMaxNumEnchants )
-    {
-        harvestLevel = iHarvestLevel;
-        maxUses = iMaxUses;
-        efficiencyOnProperMaterial = fEffeciency;
-        damageVsEntity = iWeaponDamage;
-        enchantability = iEnchantability;
-        
-        m_iInfernalMaxEnchantmentCost = iInfernalMaxEnchantmentCost;
-        m_iInfernalMaxNumEnchants = iInfernalMaxNumEnchants;
-    }    
-    // END FCMOD
 
     /**
      * The number of uses this material allows. (wood = 59, stone = 131, iron = 250, diamond = 1561, gold = 32)
@@ -115,19 +86,4 @@
     {
         return this == WOOD ? Block.planks.blockID : (this == STONE ? Block.cobblestone.blockID : (this == GOLD ? Item.ingotGold.itemID : (this == IRON ? Item.ingotIron.itemID : (this == EMERALD ? Item.diamond.itemID : 0))));
     }
-    
-    // FCMOD: Added New
-    private final int m_iInfernalMaxEnchantmentCost;
-    private final int m_iInfernalMaxNumEnchants;
-    
-    public int GetInfernalMaxEnchantmentCost()
-    {
-    	return m_iInfernalMaxEnchantmentCost;
-    }
-    
-    public int GetInfernalMaxNumEnchants()
-    {
-    	return m_iInfernalMaxNumEnchants;
-    }
-    // END FCMOD
 }
--- Explosion.java	Sun Jun  3 19:12:23 2018
+++ Explosion.java	Fri Apr 20 22:33:11 2018
@@ -28,10 +28,6 @@
     public List affectedBlockPositions = new ArrayList();
     private Map field_77288_k = new HashMap();
 
-    // FCMOD: Added
-    public boolean m_bSuppressFX = false;
-    // END FCMOD
-
     public Explosion(World par1World, Entity par2Entity, double par3, double par5, double par7, float par9)
     {
         this.worldObj = par1World;
@@ -86,14 +82,7 @@
                             if (var25 > 0)
                             {
                                 Block var26 = Block.blocksList[var25];
-                                
-                                // FCMOD: Changed
-                                /*
                                 float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : var26.getExplosionResistance(this.exploder);
-                                */
-                                float var27 = this.exploder != null ? this.exploder.func_82146_a(this, this.worldObj, var22, var23, var24, var26) : 
-                                	var26.getExplosionResistance(this.exploder, worldObj, var22, var23, var24);
-                                // END FCMOD
                                 var14 -= (var27 + 0.3F) * var21;
                             }
 
@@ -163,10 +152,6 @@
      */
     public void doExplosionB(boolean par1)
     {
-    	// FCMOD: Added
-    	if ( !m_bSuppressFX )
-    	{
-    	// END FCMOD
         this.worldObj.playSoundEffect(this.explosionX, this.explosionY, this.explosionZ, "random.explode", 4.0F, (1.0F + (this.worldObj.rand.nextFloat() - this.worldObj.rand.nextFloat()) * 0.2F) * 0.7F);
 
         if (this.explosionSize >= 2.0F && this.isSmoking)
@@ -177,9 +162,6 @@
         {
             this.worldObj.spawnParticle("largeexplode", this.explosionX, this.explosionY, this.explosionZ, 1.0D, 0.0D, 0.0D);
         }
-    	// FCMOD: Added
-    	}
-    	// END FCMOD
 
         Iterator var2;
         ChunkPosition var3;
@@ -225,24 +207,13 @@
                 {
                     Block var25 = Block.blocksList[var7];
 
-                    // FCMOD: Changed
-                    /*
                     if (var25.canDropFromExplosion(this))
                     {
                         var25.dropBlockAsItemWithChance(this.worldObj, var4, var5, var6, this.worldObj.getBlockMetadata(var4, var5, var6), 1.0F / this.explosionSize, 0);
                     }
-                    */
-                    var25.DropItemsOnDestroyedByExplosion( worldObj, var4, var5, var6, this );
-                    // END FCMOD
 
-                    // FCMOD: Changed to rearrange order so that blocks can still access their metadata when notified of an explosion
-                    /*
                     this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
                     var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
-                    */
-                    var25.onBlockDestroyedByExplosion(this.worldObj, var4, var5, var6, this);
-                    this.worldObj.setBlock(var4, var5, var6, 0, 0, 3);
-                    // END FCMOD
                 }
             }
         }
@@ -254,9 +225,6 @@
             while (var2.hasNext())
             {
                 var3 = (ChunkPosition)var2.next();
-                
-                // FCMOD: Changed
-                /*
                 var4 = var3.x;
                 var5 = var3.y;
                 var6 = var3.z;
@@ -267,20 +235,8 @@
                 {
                     this.worldObj.setBlock(var4, var5, var6, Block.fire.blockID);
                 }
-                */
-                if ( explosionRNG.nextInt( 3 ) == 0 && 
-                	FCBlockFire.CanFireReplaceBlock( worldObj, var3.x, var3.y, var3.z ) && 
-                	Block.fire.canPlaceBlockAt( worldObj, var3.x, var3.y, var3.z ) )
-                {
-                    this.worldObj.setBlock( var3.x, var3.y, var3.z, Block.fire.blockID );
-                }
-                // END FCMOD
             }
         }
-        
-        // FCMOD: Added
-        PerformSecondaryExplosions();
-        // END FCMOD
     }
 
     public Map func_77277_b()
@@ -292,41 +248,4 @@
     {
         return this.exploder == null ? null : (this.exploder instanceof EntityTNTPrimed ? ((EntityTNTPrimed)this.exploder).getTntPlacedBy() : (this.exploder instanceof EntityLiving ? (EntityLiving)this.exploder : null));
     }
-    
-    // FCMOD: Added
-    public List m_SecondaryExplosionList = null;
-    
-    public void AddSecondaryExplosionNoFX( double dPosX, double dPosY, double dPosZ, 
-    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
-    {
-    	if ( m_SecondaryExplosionList == null )
-    	{
-    		m_SecondaryExplosionList = new ArrayList();
-    	}
-    	
-        Explosion explosion = new Explosion( worldObj, null, dPosX, dPosY, dPosZ, fExplosionSize );
-        
-        explosion.isFlaming = bCreatesFlames;
-        explosion.isSmoking = bDestroysBlocks;
-        explosion.m_bSuppressFX = true;
-        
-        m_SecondaryExplosionList.add( explosion );
-    }
-    
-    private void PerformSecondaryExplosions()
-    {
-    	if ( m_SecondaryExplosionList != null )
-    	{
-    		Iterator tempIterator = m_SecondaryExplosionList.iterator();
-    		
-            while ( tempIterator.hasNext() )
-            {
-                Explosion tempExplosion = (Explosion)tempIterator.next();
-                
-                tempExplosion.doExplosionA();
-                tempExplosion.doExplosionB( false ); // false tells individual block destruction effects not to play
-            }
-    	}
-    }    
-    // END FCMOD
 }
--- FoodStats.java	Tue Feb 12 13:04:53 2019
+++ FoodStats.java	Fri Apr 20 22:33:11 2018
@@ -3,65 +3,38 @@
 public class FoodStats
 {
     /** The player's food level. */
-	// FCMOD: Code change to increase food meter resolution
-	/*
     private int foodLevel = 20;
-    */
-    private int foodLevel = 60;
-    // END FCMOD
 
     /** The player's food saturation. */
-    // FCMOD: Code change so that player spawns with zero fat
-    /*
     private float foodSaturationLevel = 5.0F;
-    */
-    private float foodSaturationLevel = 0F;
-    // END FCMOD
 
     /** The player's food exhaustion. */
     private float foodExhaustionLevel;
 
     /** The player's food timer value. */
     private int foodTimer = 0;
-    
-	// FCMOD: Code change to increase food meter resolution
-	/*
     private int prevFoodLevel = 20;
-    */
-    private int prevFoodLevel = 60;
-    // END FCMOD
 
     /**
      * Args: int foodLevel, float foodSaturationModifier
      */
-    // FCMOD: Code removed and replaced later by custom function
-    /*
     public void addStats(int par1, float par2)
     {
         this.foodLevel = Math.min(par1 + this.foodLevel, 20);
         this.foodSaturationLevel = Math.min(this.foodSaturationLevel + (float)par1 * par2 * 2.0F, (float)this.foodLevel);
     }
-	*/
-	// END FCMOD
 
     /**
      * Eat some food.
      */
     public void addStats(ItemFood par1ItemFood)
     {
-    	// FCMOD: Code change
-    	/*
         this.addStats(par1ItemFood.getHealAmount(), par1ItemFood.getSaturationModifier());
-        */
-        this.addStats(par1ItemFood.GetHungerRestored(), par1ItemFood.getSaturationModifier());
-        // END FCMOD
     }
 
     /**
      * Handles the food game logic.
      */
-    // FCMOD: Code removed and replaced later by custom function
-    /*
     public void onUpdate(EntityPlayer par1EntityPlayer)
     {
         int var2 = par1EntityPlayer.worldObj.difficultySetting;
@@ -110,8 +83,6 @@
             this.foodTimer = 0;
         }
     }
-	*/
-	// END FCMOD
 
     /**
      * Reads the food data for the player.
@@ -124,26 +95,6 @@
             this.foodTimer = par1NBTTagCompound.getInteger("foodTickTimer");
             this.foodSaturationLevel = par1NBTTagCompound.getFloat("foodSaturationLevel");
             this.foodExhaustionLevel = par1NBTTagCompound.getFloat("foodExhaustionLevel");
-            
-            // FCMOD: Code added
-            if ( !par1NBTTagCompound.hasKey("fcFoodLevelAdjusted"))
-            {
-            	foodLevel = foodLevel * 3;
-            	foodSaturationLevel = 0F;
-            }
-            
-            // sanity check the values as apparently they can get fucked up when importing from vanilla
-            
-            if ( foodLevel > 60 || foodLevel < 0 )
-            {
-            	foodLevel = 60;
-            }
-            
-            if ( foodSaturationLevel > 20F || foodSaturationLevel < 0F )
-            {
-            	foodSaturationLevel = 20F;
-            }
-            // END FCMOD
         }
     }
 
@@ -156,10 +107,6 @@
         par1NBTTagCompound.setInteger("foodTickTimer", this.foodTimer);
         par1NBTTagCompound.setFloat("foodSaturationLevel", this.foodSaturationLevel);
         par1NBTTagCompound.setFloat("foodExhaustionLevel", this.foodExhaustionLevel);
-        
-        // FCMOD: Code added
-        par1NBTTagCompound.setBoolean( "fcFoodLevelAdjusted", true );
-        // END FCMOD
     }
 
     /**
@@ -175,12 +122,7 @@
      */
     public boolean needFood()
     {
-    	// FCMOD: Code changed
-    	/*
         return this.foodLevel < 20;
-        */
-        return this.foodLevel < 60;    	
-        // END FCMOD
     }
 
     /**
@@ -198,111 +140,4 @@
     {
         return this.foodSaturationLevel;
     }
-
-    // FCMOD: Added to match client
-    public void setFoodLevel(int par1)
-    {
-        this.foodLevel = par1;
-    }
-    
-    public void setFoodSaturationLevel(float par1)
-    {
-        this.foodSaturationLevel = par1;
-    }    
-    // END FCMOD
-
-    // FCMOD: Added New
-    /**
-     * Note that iFoodGain is one third regular hunger gained, with 6 units being a full pip
-     */
-    public void addStats( int iFoodGain, float fFatMultiplier )
-    {
-    	int iPreviousFoodLevel = foodLevel;
-    	
-        foodLevel = Math.min( iFoodGain + foodLevel, 60);
-        
-        int iExcessFood = iFoodGain - ( foodLevel - iPreviousFoodLevel );
-        
-        if ( iExcessFood > 0 )
-        {
-        	// divide by 3 due to increased resolution
-        	
-            foodSaturationLevel = Math.min( foodSaturationLevel + (float)iExcessFood * fFatMultiplier / 3F, 20F );
-        }
-    }
-    
-    public void onUpdate( EntityPlayer player )
-    {
-    	// only called on server
-    	
-        int iDifficulty = player.worldObj.difficultySetting;
-        
-        prevFoodLevel = foodLevel;
-
-        if ( iDifficulty > 0 )
-        {
-	        // burn hunger
-	        
-	        while ( foodLevel > 0 && foodExhaustionLevel >= 1.33F && !ShouldBurnFatBeforeHunger() )
-	        {
-	            foodExhaustionLevel -= 1.33F;
-	            
-	            foodLevel = Math.max( foodLevel - 1, 0 );
-	        }
-	        
-	    	// burn fat
-	    	
-	        while ( foodExhaustionLevel >= 0.5F && ShouldBurnFatBeforeHunger() )
-	        {
-	    		foodExhaustionLevel -= 0.5F;
-	    		
-	            foodSaturationLevel = Math.max( foodSaturationLevel - 0.125F, 0F );
-	        }
-        }
-        else
-        {
-        	foodExhaustionLevel = 0F;
-        }
-
-        if ( foodLevel > 24 && player.shouldHeal() )
-        {
-            ++foodTimer;
-
-            if ( foodTimer >= 600 ) // once every 30 seconds
-            {
-                player.heal( 1 );
-                foodTimer = 0;
-            }
-        }
-        else if ( foodLevel <= 0 && foodSaturationLevel <= 0.01F )
-        {
-            ++foodTimer;
-
-            if ( foodTimer >= 80 )
-            {
-            	if ( iDifficulty > 0 )
-            	{
-            		player.attackEntityFrom( DamageSource.starve, 1 );
-            	}
-
-                foodTimer = 0;
-            }
-
-            // reset the exhaustion level so that it doesn't stack up while the player is starving
-            
-            foodExhaustionLevel = 0F;
-        }
-        else
-        {
-            foodTimer = 0;
-        }
-    }
-    
-    private boolean ShouldBurnFatBeforeHunger()
-    {
-    	// only burn fat when the corresponding hunger pip is completely depleted
-    	
-    	return foodSaturationLevel > (float)( ( foodLevel + 5 ) / 6 ) * 2F;    	
-    }
-    // END FCMOD    
 }
--- FurnaceRecipes.java	Wed Jul 17 17:41:23 2013
+++ FurnaceRecipes.java	Fri Apr 20 22:33:11 2018
@@ -45,15 +45,11 @@
     /**
      * Adds a smelting recipe.
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public void addSmelting(int par1, ItemStack par2ItemStack, float par3)
     {
         this.smeltingList.put(Integer.valueOf(par1), par2ItemStack);
         this.experienceList.put(Integer.valueOf(par2ItemStack.itemID), Float.valueOf(par3));
     }
-    */
-    // END FCMOD
 
     /**
      * Returns the smelting result of an item.
@@ -72,32 +68,4 @@
     {
         return this.experienceList.containsKey(Integer.valueOf(par1)) ? ((Float)this.experienceList.get(Integer.valueOf(par1))).floatValue() : 0.0F;
     }
-    
-    // FCMOD: Code added
-    private Map m_CookTimeBinaryShiftMap = new HashMap();
-    
-    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience )
-    {
-    	addSmelting( iInputItemID, outputStack, fExperience, 0 );
-    }
-    
-    public void addSmelting( int iInputItemID, ItemStack outputStack, float fExperience, int iCookTimeBinaryShift )
-    {
-        smeltingList.put( Integer.valueOf( iInputItemID ), outputStack );
-        
-        experienceList.put( Integer.valueOf( outputStack.itemID ), Float.valueOf( fExperience ) );
-        
-        m_CookTimeBinaryShiftMap.put( Integer.valueOf( iInputItemID ), Integer.valueOf( iCookTimeBinaryShift ) );
-    }
-    
-    public int GetCookTimeBinaryShift( int iItemID )
-    {
-    	if ( m_CookTimeBinaryShiftMap.containsKey( Integer.valueOf( iItemID ) ) )
-    	{
-    		return ((Integer)m_CookTimeBinaryShiftMap.get( Integer.valueOf( iItemID ) ) ).intValue();
-    	}
-    	
-    	return 0;
-    }
-    // END FCMOD
 }
--- IMerchant.java	Tue Oct  2 00:33:51 2018
+++ IMerchant.java	Fri Apr 20 22:33:12 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 10/02/2018
-
 package net.minecraft.src;
 
 public interface IMerchant
@@ -11,10 +9,4 @@
     MerchantRecipeList getRecipes(EntityPlayer var1);
 
     void useRecipe(MerchantRecipe var1);
-
-    // FCMOD: Added
-    public int GetCurrentTradeLevel(); 
-    public int GetCurrentTradeXP();
-    public int GetCurrentTradeMaxXP();
-    // END FCMOD
 }
--- InventoryMerchant.java	Sat Jun 28 15:01:52 2014
+++ InventoryMerchant.java	Fri Apr 20 22:33:12 2018
@@ -228,10 +228,6 @@
                 }
             }
         }
-        
-        // FCMOD: Code added
-        ResetRecipeAndSlotsModProcessing();
-        // END FCMOD
     }
 
     public MerchantRecipe getCurrentRecipe()
@@ -244,37 +240,4 @@
         this.currentRecipeIndex = par1;
         this.resetRecipeAndSlots();
     }
-    
-    // FCMOD: Code added
-    private void ResetRecipeAndSlotsModProcessing()
-    {
-    	ItemStack outputStack = theInventory[2];
-    	
-		if ( outputStack != null && outputStack.itemID == FCBetterThanWolves.fcItemAncientProphecy.itemID )
-		{
-			ItemStack manuscriptStack = theInventory[0];
-			
-			if ( manuscriptStack.itemID != Item.enchantedBook.itemID )
-			{
-				manuscriptStack = theInventory[1];
-			}
-			
-			int iEnchantmentID = -1;
-			
-			NBTTagList enchantmentTagList = Item.enchantedBook.func_92110_g( manuscriptStack );
-			
-			if ( enchantmentTagList != null && enchantmentTagList.tagCount() > 0 )
-			{
-                short iTempID = ((NBTTagCompound)enchantmentTagList.tagAt( 0 ) ).getShort("id");
-
-                if (Enchantment.enchantmentsList[iTempID] != null)
-                {
-                	iEnchantmentID = iTempID;                	
-                }
-			}
-			
-			((FCItemAncientProphecy)FCBetterThanWolves.fcItemAncientProphecy).InitializeProphecyDataFromEnchantmentID( outputStack, iEnchantmentID );
-		}
-    }
-    // END FCMOD
 }
--- InventoryPlayer.java	Sun Mar  4 12:37:36 2018
+++ InventoryPlayer.java	Fri Apr 20 22:33:12 2018
@@ -407,23 +407,13 @@
     /**
      * Gets the strength of the current item (tool) against the specified block, 1.0f if not holding anything.
      */
-    // FCMOD: Code change
-    /*
     public float getStrVsBlock(Block par1Block)
-    */
-    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
-    // END FCMOD
     {
         float var2 = 1.0F;
 
         if (this.mainInventory[this.currentItem] != null)
         {
-            // FCMOD: Code change
-            /*
             var2 *= this.mainInventory[this.currentItem].getStrVsBlock(par1Block);
-            */
-            var2 *= this.mainInventory[this.currentItem].getStrVsBlock( world, par1Block, i, j, k );
-        	// END FCMOD
         }
 
         return var2;
@@ -554,12 +544,7 @@
     /**
      * Returns whether the current item (tool) can harvest from the specified block (actually get a result).
      */
-    // FCMOD: Code change
-    /*
     public boolean canHarvestBlock(Block par1Block)
-    */
-    public boolean canHarvestBlock(World world, Block par1Block, int i, int j, int k)
-    // END FCMOD
     {
         if (par1Block.blockMaterial.isToolNotRequired())
         {
@@ -568,12 +553,7 @@
         else
         {
             ItemStack var2 = this.getStackInSlot(this.currentItem);
-            // FCMOD: Code change
-            /*
             return var2 != null ? var2.canHarvestBlock(par1Block) : false;
-            */
-            return var2 != null ? var2.canHarvestBlock(world, par1Block, i, j, k) : false;
-            // END FCMOD
         }
     }
 
--- IRecipe.java	Tue Nov 27 15:39:10 2018
+++ IRecipe.java	Fri Apr 20 22:33:12 2018
@@ -18,14 +18,4 @@
     int getRecipeSize();
 
     ItemStack getRecipeOutput();
-    
-    // FCMOD: Added
-    public abstract boolean matches( IRecipe recipe );
-    
-    // NOTE: That secondary output is manually flagged rather than maintaining an internal 
-    // list of outputs because of SlotCrafting having no idea what recipe is being produced when 
-    // the output is collected.  It would be a mess of base class edits to change this.
-    
-    public abstract boolean HasSecondaryOutput();
-    // END FCMOD
 }
--- ISaveHandler.java	Wed Oct 31 11:52:27 2018
+++ ISaveHandler.java	Fri Apr 20 22:33:12 2018
@@ -45,10 +45,4 @@
      * Returns the name of the directory where world information is saved.
      */
     String getWorldDirectoryName();
-
-    // FCMOD: Added
-    public void LoadModSpecificData( WorldServer world );
-    
-    public void SaveModSpecificData( WorldServer world );
-    // END FCMOD
 }
--- Item.java	Sun Dec  6 21:33:10 2020
+++ Item.java	Fri Apr 20 22:33:12 2018
@@ -11,18 +11,6 @@
 
     /** A 32000 elements Item array. */
     public static Item[] itemsList = new Item[32000];
-    
-    // FCMOD: Added
-    public static final int m_iFilterable_NoProperties = 0;
-    public static final int m_iFilterable_SolidBlock = 1;
-    public static final int m_iFilterable_Small = 2;
-    public static final int m_iFilterable_Narrow = 4;
-    public static final int m_iFilterable_Fine = 8;
-    public static final int m_iFilterable_Thin = 16;    
-    // END FCMOD
-    
-    // FCMOD: Changed
-    /*
     public static Item shovelIron = (new ItemSpade(0, EnumToolMaterial.IRON)).setUnlocalizedName("shovelIron");
     public static Item pickaxeIron = (new ItemPickaxe(1, EnumToolMaterial.IRON)).setUnlocalizedName("pickaxeIron");
     public static Item axeIron = (new ItemAxe(2, EnumToolMaterial.IRON)).setUnlocalizedName("hatchetIron");
@@ -32,21 +20,8 @@
     public static Item arrow = (new Item(6)).setUnlocalizedName("arrow").setCreativeTab(CreativeTabs.tabCombat);
     public static Item coal = (new ItemCoal(7)).setUnlocalizedName("coal");
     public static Item diamond = (new Item(8)).setUnlocalizedName("diamond").setCreativeTab(CreativeTabs.tabMaterials);
-    */
-    public static Item shovelIron = ( new FCItemShovel( 0, EnumToolMaterial.IRON ) ).setUnlocalizedName( "shovelIron" );
-    public static Item pickaxeIron = ( new FCItemPickaxe( 1, EnumToolMaterial.IRON ) ).setUnlocalizedName( "pickaxeIron" );
-    public static Item axeIron = ( new FCItemAxe( 2, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hatchetIron" );
-    public static Item flintAndSteel = ( new FCItemFlintAndSteel( 3 ) ).setUnlocalizedName( "flintAndSteel" );
-    public static Item appleRed = ( new ItemFood( 4, 1, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "apple" );
-    public static ItemBow bow = new FCItemBow( 5 );
-    public static Item arrow = new FCItemArrow( 6 );
-    public static Item coal = ( new ItemCoal( 7 ) ).SetIncineratedInCrucible().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.COAL ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "coal" );
-    public static Item diamond = ( new Item( 8 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "diamond" ).setCreativeTab( CreativeTabs.tabMaterials );
-    // END FCMOD
     public static Item ingotIron = (new Item(9)).setUnlocalizedName("ingotIron").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item ingotGold = (new Item(10)).setUnlocalizedName("ingotGold").setCreativeTab(CreativeTabs.tabMaterials);
-    // FCMOD: Changed
-    /*
     public static Item swordIron = (new ItemSword(11, EnumToolMaterial.IRON)).setUnlocalizedName("swordIron");
     public static Item swordWood = (new ItemSword(12, EnumToolMaterial.WOOD)).setUnlocalizedName("swordWood");
     public static Item shovelWood = (new ItemSpade(13, EnumToolMaterial.WOOD)).setUnlocalizedName("shovelWood");
@@ -67,30 +42,6 @@
     public static Item shovelGold = (new ItemSpade(28, EnumToolMaterial.GOLD)).setUnlocalizedName("shovelGold");
     public static Item pickaxeGold = (new ItemPickaxe(29, EnumToolMaterial.GOLD)).setUnlocalizedName("pickaxeGold");
     public static Item axeGold = (new ItemAxe(30, EnumToolMaterial.GOLD)).setUnlocalizedName("hatchetGold");
-    */
-    public static Item swordIron = ( new FCItemSword( 11, EnumToolMaterial.IRON ) ).setUnlocalizedName( "swordIron" );
-    public static Item swordWood = ( new FCItemSword( 12, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "swordWood" );
-    public static Item shovelWood = ( new FCItemShovel( 13, EnumToolMaterial.WOOD ) ).SetDamageVsEntity( 2 ).setUnlocalizedName( "shovelWood" );
-    public static Item pickaxeWood = ( new FCItemPickaxe( 14, EnumToolMaterial.WOOD, 1 ) ).setUnlocalizedName( "pickaxeWood" );
-    public static Item axeWood = ( new FCItemAxe( 15, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hatchetWood" );
-    public static Item swordStone = ( new FCItemSword( 16, EnumToolMaterial.STONE ) ).setUnlocalizedName( "swordStone" );	    
-    public static Item shovelStone = new FCItemShovelStone( 17 );
-    public static Item pickaxeStone = ( new FCItemPickaxe( 18, EnumToolMaterial.STONE ) ).setUnlocalizedName( "pickaxeStone" );
-    public static Item axeStone = ( new FCItemAxe( 19, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hatchetStone" );
-    public static Item swordDiamond = ( new FCItemSword( 20, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "swordDiamond" );	    
-    public static Item shovelDiamond = ( new FCItemShovel( 21, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "shovelDiamond" );
-    public static Item pickaxeDiamond = ( new FCItemPickaxe( 22, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "pickaxeDiamond" );	    
-    public static Item axeDiamond = ( new FCItemAxe( 23, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hatchetDiamond" );
-    public static Item stick = new FCItemShaft( 24 );    
-    public static Item bowlEmpty = ( new Item( 25 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "bowl" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item bowlSoup = ( new FCItemMushroomSoup( 26, 3 ) ).setUnlocalizedName( "mushroomStew" );
-    public static Item swordGold = ( new FCItemSword( 27, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "swordGold" );
-    public static Item shovelGold = ( new FCItemShovel( 28, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "shovelGold" );
-    public static Item pickaxeGold = ( new FCItemPickaxe( 29, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "pickaxeGold" );	    
-    public static Item axeGold = ( new FCItemAxe( 30, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hatchetGold" );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item silk = (new ItemReed(31, Block.tripWire)).setUnlocalizedName("string").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item feather = (new Item(32)).setUnlocalizedName("feather").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item gunpowder = (new Item(33)).setUnlocalizedName("sulphur").setPotionEffect(PotionHelper.gunpowderEffect).setCreativeTab(CreativeTabs.tabMaterials);
@@ -102,21 +53,6 @@
     public static Item seeds = (new ItemSeeds(39, Block.crops.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds");
     public static Item wheat = (new Item(40)).setUnlocalizedName("wheat").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item bread = (new ItemFood(41, 5, 0.6F, false)).setUnlocalizedName("bread");
-    */
-    public static Item silk = ( new Item( 31 ) ).SetBuoyant().SetBellowsBlowDistance( 2 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "string" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item feather = ( new Item( 32 ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "feather" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item gunpowder = ( new Item( 33 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sulphur" ).setPotionEffect( PotionHelper.gunpowderEffect ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item hoeWood = ( new FCItemHoe( 34, EnumToolMaterial.WOOD ) ).setUnlocalizedName( "hoeWood" );
-    public static Item hoeStone = ( new FCItemHoe( 35, EnumToolMaterial.STONE ) ).setUnlocalizedName( "hoeStone" );
-    public static Item hoeIron = ( new FCItemHoe( 36, EnumToolMaterial.IRON ) ).setUnlocalizedName( "hoeIron" );
-    public static Item hoeDiamond = ( new FCItemHoe( 37, EnumToolMaterial.EMERALD ) ).setUnlocalizedName( "hoeDiamond" );
-    public static Item hoeGold = ( new FCItemHoe( 38, EnumToolMaterial.GOLD ) ).setUnlocalizedName( "hoeGold" );
-    public static Item seeds = ( new FCItemSeeds( 39, Block.crops.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds" ).setCreativeTab( null );
-    public static Item wheat = new FCItemWheatLegacy( 40 );
-    public static Item bread = ( new ItemFood( 41, 3, 0.25F, false ) ).setUnlocalizedName( "bread" );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static ItemArmor helmetLeather = (ItemArmor)(new ItemArmor(42, EnumArmorMaterial.CLOTH, 0, 0)).setUnlocalizedName("helmetCloth");
     public static ItemArmor plateLeather = (ItemArmor)(new ItemArmor(43, EnumArmorMaterial.CLOTH, 0, 1)).setUnlocalizedName("chestplateCloth");
     public static ItemArmor legsLeather = (ItemArmor)(new ItemArmor(44, EnumArmorMaterial.CLOTH, 0, 2)).setUnlocalizedName("leggingsCloth");
@@ -137,30 +73,6 @@
     public static ItemArmor plateGold = (ItemArmor)(new ItemArmor(59, EnumArmorMaterial.GOLD, 4, 1)).setUnlocalizedName("chestplateGold");
     public static ItemArmor legsGold = (ItemArmor)(new ItemArmor(60, EnumArmorMaterial.GOLD, 4, 2)).setUnlocalizedName("leggingsGold");
     public static ItemArmor bootsGold = (ItemArmor)(new ItemArmor(61, EnumArmorMaterial.GOLD, 4, 3)).setUnlocalizedName("bootsGold");
-    */
-    public static ItemArmor helmetLeather = (ItemArmor)( new FCItemArmorLeather( 42, 0 ) ).setUnlocalizedName( "helmetCloth" );
-    public static ItemArmor plateLeather = (ItemArmor)( new FCItemArmorLeather( 43, 1 ) ).setUnlocalizedName( "chestplateCloth" );
-    public static ItemArmor legsLeather = (ItemArmor)( new FCItemArmorLeather( 44, 2 ) ).setUnlocalizedName( "leggingsCloth" );
-    public static ItemArmor bootsLeather = (ItemArmor)( new FCItemArmorLeather( 45, 3 ) ).setUnlocalizedName( "bootsCloth" );    
-    public static ItemArmor helmetChain = (ItemArmor)( new FCItemArmorChain( 46, 0, 3 ) ).setUnlocalizedName( "helmetChain" );
-    public static ItemArmor plateChain = (ItemArmor)( new FCItemArmorChain( 47, 1, 4 ) ).setUnlocalizedName( "chestplateChain" );
-    public static ItemArmor legsChain = (ItemArmor)( new FCItemArmorChain( 48, 2, 4 ) ).setUnlocalizedName( "leggingsChain" );
-    public static ItemArmor bootsChain = (ItemArmor)( new FCItemArmorChain( 49, 3, 2 ) ).setUnlocalizedName( "bootsChain" );
-    public static ItemArmor helmetIron = (ItemArmor)( new FCItemArmorIron( 50, 0, 5 ) ).setUnlocalizedName( "helmetIron" );
-    public static ItemArmor plateIron = (ItemArmor)( new FCItemArmorIron( 51, 1, 8 ) ).setUnlocalizedName( "chestplateIron" );
-    public static ItemArmor legsIron = (ItemArmor)( new FCItemArmorIron( 52, 2, 7 ) ).setUnlocalizedName( "leggingsIron" );
-    public static ItemArmor bootsIron = (ItemArmor)( new FCItemArmorIron( 53, 3, 4 ) ).setUnlocalizedName( "bootsIron" );
-    public static ItemArmor helmetDiamond = (ItemArmor)( new FCItemArmorDiamond( 54, 0, 5 ) ).setUnlocalizedName( "helmetDiamond" );
-    public static ItemArmor plateDiamond = (ItemArmor)( new FCItemArmorDiamond( 55, 1, 8 ) ).setUnlocalizedName( "chestplateDiamond" );
-    public static ItemArmor legsDiamond = (ItemArmor)( new FCItemArmorDiamond( 56, 2, 7 ) ).setUnlocalizedName( "leggingsDiamond" );
-    public static ItemArmor bootsDiamond = (ItemArmor)( new FCItemArmorDiamond( 57, 3, 4 ) ).setUnlocalizedName( "bootsDiamond" );
-    public static ItemArmor helmetGold = (ItemArmor)( new FCItemArmorGold( 58, 0, 5 ) ).setUnlocalizedName( "helmetGold" );
-    public static ItemArmor plateGold = (ItemArmor)( new FCItemArmorGold( 59, 1, 8 ) ).setUnlocalizedName( "chestplateGold" );
-    public static ItemArmor legsGold = (ItemArmor)( new FCItemArmorGold( 60, 2, 7 ) ).setUnlocalizedName( "leggingsGold" );
-    public static ItemArmor bootsGold = (ItemArmor)( new FCItemArmorGold( 61, 3, 4 ) ).setUnlocalizedName( "bootsGold" );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item flint = (new Item(62)).setUnlocalizedName("flint").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item porkRaw = (new ItemFood(63, 3, 0.3F, true)).setUnlocalizedName("porkchopRaw");
     public static Item porkCooked = (new ItemFood(64, 8, 0.8F, true)).setUnlocalizedName("porkchopCooked");
@@ -171,29 +83,9 @@
     public static Item bucketEmpty = (new ItemBucket(69, 0)).setUnlocalizedName("bucket").setMaxStackSize(16);
     public static Item bucketWater = (new ItemBucket(70, Block.waterMoving.blockID)).setUnlocalizedName("bucketWater").setContainerItem(bucketEmpty);
     public static Item bucketLava = (new ItemBucket(71, Block.lavaMoving.blockID)).setUnlocalizedName("bucketLava").setContainerItem(bucketEmpty);
-    */
-    public static Item flint = new FCItemFlint( 62 );
-    public static Item porkRaw = ( new FCItemFood( 63, FCItemFood.m_iPorkChopRawHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true, "porkchopRaw", true ) ).SetStandardFoodPoisoningEffect();    
-    public static Item porkCooked = ( new ItemFood( 64, FCItemFood.m_iPorkChopCookedHungerHealed, FCItemFood.m_fPorkChopSaturationModifier, true ) ).setUnlocalizedName( "porkchopCooked" );    
-    public static Item painting = ( new ItemHangingEntity( 65, EntityPainting.class ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "painting" );
-    public static Item appleGold = ( new ItemAppleGold( 66, 1, 0F, false ) ).setAlwaysEdible().setPotionEffect( Potion.regeneration.id, 5, 0, 1F ).SetNonBuoyant().SetNotIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "appleGold" );
-    public static Item sign = new FCItemSign( 67 );
-    public static Item doorWood = new FCItemDoorWood( 68 );	    
-    public static Item bucketEmpty = new FCItemBucketEmpty( 69 );
-    public static Item bucketWater = new FCItemBucketWater( 70 );
-    public static Item bucketLava = new FCItemBucketLava( 71 );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item minecartEmpty = (new ItemMinecart(72, 0)).setUnlocalizedName("minecart");
     public static Item saddle = (new ItemSaddle(73)).setUnlocalizedName("saddle");
-    */
-    public static Item minecartEmpty = ( new FCItemMinecart( 72, 0 ) ).setUnlocalizedName( "minecart" );
-    public static Item saddle = ( new ItemSaddle( 73 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "saddle" );
-    // END FCMOD
     public static Item doorIron = (new ItemDoor(74, Material.iron)).setUnlocalizedName("doorIron");
-    // FCMOD: Changed
-    /*
     public static Item redstone = (new ItemRedstone(75)).setUnlocalizedName("redstone").setPotionEffect(PotionHelper.redstoneEffect);
     public static Item snowball = (new ItemSnowball(76)).setUnlocalizedName("snowball");
     public static Item boat = (new ItemBoat(77)).setUnlocalizedName("boat");
@@ -205,39 +97,12 @@
     public static Item paper = (new Item(83)).setUnlocalizedName("paper").setCreativeTab(CreativeTabs.tabMisc);
     public static Item book = (new ItemBook(84)).setUnlocalizedName("book").setCreativeTab(CreativeTabs.tabMisc);
     public static Item slimeBall = (new Item(85)).setUnlocalizedName("slimeball").setCreativeTab(CreativeTabs.tabMisc);
-    */
-    public static Item redstone = new FCItemRedstone( 75 );
-    public static Item snowball = new FCItemSnowball( 76 );
-    public static Item boat = new FCItemBoat( 77 );
-    public static Item leather = ( new Item( 78 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Thin ).setUnlocalizedName( "leather" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item bucketMilk = new FCItemBucketMilk( 79 );    	
-    public static Item brick = new FCItemBrick( 80 );
-    public static Item clay = new FCItemClay( 81 );
-    public static Item reed = ( new ItemReed( 82, Block.reed ) ).SetBuoyant().SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "reeds" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item paper = ( new Item( 83 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.KINDLING ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small | m_iFilterable_Thin ).setUnlocalizedName( "paper" ).setCreativeTab( CreativeTabs.tabMisc );
-    public static Item book = new FCItemBook( 84 );
-    public static Item slimeBall = new FCItemSlimeball( 85 );    
-    // END FCMOD    
-    // FCMOD: Changed
-    /*
     public static Item minecartCrate = (new ItemMinecart(86, 1)).setUnlocalizedName("minecartChest");
     public static Item minecartPowered = (new ItemMinecart(87, 2)).setUnlocalizedName("minecartFurnace");
     public static Item egg = (new ItemEgg(88)).setUnlocalizedName("egg");
-    */
-    public static Item minecartCrate = ( new FCItemMinecart( 86, 1 ) ).setUnlocalizedName( "minecartChest" );
-    public static Item minecartPowered = ( new FCItemMinecart( 87, 2 ) ).setUnlocalizedName( "minecartFurnace" );
-    public static Item egg = new FCItemEgg( 88 );
-    // END FCMOD
     public static Item compass = (new Item(89)).setUnlocalizedName("compass").setCreativeTab(CreativeTabs.tabTools);
-    // FCMOD: Changed
-    /*
     public static ItemFishingRod fishingRod = (ItemFishingRod)(new ItemFishingRod(90)).setUnlocalizedName("fishingRod");
-    */
-    public static ItemFishingRod fishingRod = new FCItemFishingRod( 90 );
-    // END FCMOD
     public static Item pocketSundial = (new Item(91)).setUnlocalizedName("clock").setCreativeTab(CreativeTabs.tabTools);
-    // FCMOD: Changed
-    /*
     public static Item lightStoneDust = (new Item(92)).setUnlocalizedName("yellowDust").setPotionEffect(PotionHelper.glowstoneEffect).setCreativeTab(CreativeTabs.tabMaterials);
     public static Item fishRaw = (new ItemFood(93, 2, 0.3F, false)).setUnlocalizedName("fishRaw");
     public static Item fishCooked = (new ItemFood(94, 5, 0.6F, false)).setUnlocalizedName("fishCooked");
@@ -249,6 +114,10 @@
     public static Item redstoneRepeater = (new ItemReed(100, Block.redstoneRepeaterIdle)).setUnlocalizedName("diode").setCreativeTab(CreativeTabs.tabRedstone);
     public static Item cookie = (new ItemFood(101, 2, 0.1F, false)).setUnlocalizedName("cookie");
     public static ItemMap map = (ItemMap)(new ItemMap(102)).setUnlocalizedName("map");
+
+    /**
+     * Item introduced on 1.7 version, is a shear to cut leaves (you can keep the block) or get wool from sheeps.
+     */
     public static ItemShears shears = (ItemShears)(new ItemShears(103)).setUnlocalizedName("shears");
     public static Item melon = (new ItemFood(104, 2, 0.3F, false)).setUnlocalizedName("melon");
     public static Item pumpkinSeeds = (new ItemSeeds(105, Block.pumpkinStem.blockID, Block.tilledField.blockID)).setUnlocalizedName("seeds_pumpkin");
@@ -258,30 +127,6 @@
     public static Item chickenRaw = (new ItemFood(109, 2, 0.3F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.3F).setUnlocalizedName("chickenRaw");
     public static Item chickenCooked = (new ItemFood(110, 6, 0.6F, true)).setUnlocalizedName("chickenCooked");
     public static Item rottenFlesh = (new ItemFood(111, 4, 0.1F, true)).setPotionEffect(Potion.hunger.id, 30, 0, 0.8F).setUnlocalizedName("rottenFlesh");
-    */
-    public static Item lightStoneDust = ( new Item( 92 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "yellowDust" ).setCreativeTab( CreativeTabs.tabMaterials );    
-    public static Item fishRaw = ( new FCItemFood( 93, FCItemFood.m_iFishRawHungerHealed, FCItemFood.m_fFishSaturationModifier, false, "fishRaw" ) ).SetStandardFoodPoisoningEffect();
-    public static Item fishCooked = ( new ItemFood( 94, FCItemFood.m_iFishCookedHungerHealed, FCItemFood.m_fFishSaturationModifier, false ) ).setUnlocalizedName( "fishCooked" );
-    public static Item dyePowder = new FCItemDye( 95 );
-    public static Item bone = new FCItemBone( 96 );
-    public static Item sugar = ( new Item( 97 ) ).SetBuoyant().SetBellowsBlowDistance( 3 ).SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "sugar" ).setCreativeTab( CreativeTabs.tabMaterials );	    
-    public static Item cake = ( new ItemReed( 98, Block.cake ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "cake" ).setCreativeTab( CreativeTabs.tabFood );
-    public static Item bed = ( new ItemBed( 99 ) ).SetBuoyant().SetIncineratedInCrucible().setMaxStackSize( 1 ).setUnlocalizedName( "bed" );
-    public static Item redstoneRepeater = new FCItemRedstoneRepeater( 100 );
-    public static Item cookie = ( new ItemFood( 101, 1, 1F, false ) ).setAlwaysEdible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "cookie" );
-    public static ItemMap map = new FCItemMap( 102 );
-    public static ItemShears shears = (ItemShears)( new FCItemShears( 103 ) ).setUnlocalizedName( "shears" );
-    public static Item melon = new FCItemFoodHighRes( 104, 2, 0F, false, "melon" );
-    public static Item pumpkinSeeds = ( new FCItemSeedFood( 105, 1, 0F, Block.pumpkinStem.blockID ) ).SetAsBasicChickenFood().SetBellowsBlowDistance( 2 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "seeds_pumpkin" );
-    public static Item melonSeeds = ( new FCItemSeeds( 106, Block.melonStem.blockID ) ).SetAsBasicChickenFood().setUnlocalizedName( "seeds_melon" );
-    public static Item beefRaw = ( new FCItemFood( 107, FCItemFood.m_iBeefRawHungerHealed, FCItemFood.m_fBeefSaturationModifier, true, "beefRaw", true ) ).SetStandardFoodPoisoningEffect();    
-    public static Item beefCooked = ( new ItemFood( 108, FCItemFood.m_iBeefCookedHungerHealed, FCItemFood.m_fBeefSaturationModifier, true ) ).setUnlocalizedName("beefCooked");
-    public static Item chickenRaw = ( new FCItemFood( 109, FCItemFood.m_iChickenRawHungerHealed, FCItemFood.m_fChickenSaturationModifier, true, "chickenRaw" ) ).SetStandardFoodPoisoningEffect();    
-    public static Item chickenCooked = (new ItemFood( 110, FCItemFood.m_iChickenCookedHungerHealed, FCItemFood.m_fChickenSaturationModifier, true ) ).setUnlocalizedName( "chickenCooked" );    
-    public static Item rottenFlesh = new FCItemRottenFlesh( 111 );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item enderPearl = (new ItemEnderPearl(112)).setUnlocalizedName("enderPearl");
     public static Item blazeRod = (new Item(113)).setUnlocalizedName("blazeRod").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item ghastTear = (new Item(114)).setUnlocalizedName("ghastTear").setPotionEffect(PotionHelper.ghastTearEffect).setCreativeTab(CreativeTabs.tabBrewing);
@@ -293,29 +138,10 @@
     public static Item fermentedSpiderEye = (new Item(120)).setUnlocalizedName("fermentedSpiderEye").setPotionEffect(PotionHelper.fermentedSpiderEyeEffect).setCreativeTab(CreativeTabs.tabBrewing);
     public static Item blazePowder = (new Item(121)).setUnlocalizedName("blazePowder").setPotionEffect(PotionHelper.blazePowderEffect).setCreativeTab(CreativeTabs.tabBrewing);
     public static Item magmaCream = (new Item(122)).setUnlocalizedName("magmaCream").setPotionEffect(PotionHelper.magmaCreamEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    */
-    public static Item enderPearl = ( new ItemEnderPearl( 112 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "enderPearl" );
-    public static Item blazeRod = ( new Item( 113 ) ).SetFurnaceBurnTime( FCEnumFurnaceBurnTime.BLAZE_ROD ).SetFilterableProperties( m_iFilterable_Narrow ).setUnlocalizedName( "blazeRod" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item ghastTear = ( new Item( 114 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "ghastTear" ).setPotionEffect( PotionHelper.ghastTearEffect ).setCreativeTab( CreativeTabs.tabBrewing );
-    public static Item goldNugget = ( new Item( 115 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "goldNugget" ).setCreativeTab( CreativeTabs.tabMaterials );
-    public static Item netherStalkSeeds = ( new FCItemSeeds( 116, Block.netherStalk.blockID ) ).SetBellowsBlowDistance( 1 ).setUnlocalizedName( "netherStalkSeeds" ).setPotionEffect( "+4" );
-    public static ItemPotion potion = new FCItemPotion( 117 );
-    public static Item glassBottle = ( new FCItemGlassBottle( 118 ) ).SetBuoyant().setUnlocalizedName( "glassBottle" );
-    public static Item spiderEye = ( (new ItemFood( 119, 2, 0.8F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 1F ) ).SetNeutralBuoyant().SetFilterableProperties( m_iFilterable_Small ).setPotionEffect( PotionHelper.goldenCarrotEffect ).setUnlocalizedName( "spiderEye" );
-    public static Item fermentedSpiderEye = ( new Item( 120 ) ).SetNeutralBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "fermentedSpiderEye" ).setPotionEffect( PotionHelper.fermentedSpiderEyeEffect ).setCreativeTab( CreativeTabs.tabBrewing );
-    public static Item blazePowder = ( new Item( 121 ) ).SetBellowsBlowDistance( 3 ).SetFilterableProperties( m_iFilterable_Fine ).setUnlocalizedName( "blazePowder" ).setPotionEffect( PotionHelper.blazePowderEffect ).setCreativeTab( CreativeTabs.tabBrewing );
-    public static Item magmaCream = ( new Item( 122 ) ).SetNeutralBuoyant().setUnlocalizedName( "magmaCream" ).setPotionEffect( PotionHelper.magmaCreamEffect ).setCreativeTab( CreativeTabs.tabBrewing );
-    // END FCMOD
     public static Item brewingStand = (new ItemReed(123, Block.brewingStand)).setUnlocalizedName("brewingStand").setCreativeTab(CreativeTabs.tabBrewing);
     public static Item cauldron = (new ItemReed(124, Block.cauldron)).setUnlocalizedName("cauldron").setCreativeTab(CreativeTabs.tabBrewing);
-    // FCMOD: Changed
-    /*
     public static Item eyeOfEnder = (new ItemEnderEye(125)).setUnlocalizedName("eyeOfEnder");
     public static Item speckledMelon = (new Item(126)).setUnlocalizedName("speckledMelon").setPotionEffect(PotionHelper.speckledMelonEffect).setCreativeTab(CreativeTabs.tabBrewing);
-    */
-    public static Item eyeOfEnder = ( new ItemEnderEye( 125 ) ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "eyeOfEnder" );
-    public static Item speckledMelon = ( new Item( 126 ) ).setUnlocalizedName( "speckledMelon" ).setCreativeTab( CreativeTabs.tabFood );
-    // END FCMOD
     public static Item monsterPlacer = (new ItemMonsterPlacer(127)).setUnlocalizedName("monsterPlacer");
 
     /**
@@ -323,19 +149,13 @@
      */
     public static Item expBottle = (new ItemExpBottle(128)).setUnlocalizedName("expBottle");
 
-    // FCMOD: Changed
-    /*
+    /**
+     * Fire Charge. When used in a dispenser it fires a fireball similiar to a Ghast's.
+     */
     public static Item fireballCharge = (new ItemFireball(129)).setUnlocalizedName("fireball");
     public static Item writableBook = (new ItemWritableBook(130)).setUnlocalizedName("writingBook").setCreativeTab(CreativeTabs.tabMisc);
     public static Item writtenBook = (new ItemEditableBook(131)).setUnlocalizedName("writtenBook");
-    */
-    public static Item fireballCharge = new FCItemFireCharge( 129 );
-    public static Item writableBook = ( new ItemWritableBook( 130 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writingBook" ).setCreativeTab( CreativeTabs.tabMisc );
-    public static Item writtenBook = ( new ItemEditableBook( 131 ) ).SetBuoyant().SetIncineratedInCrucible().setUnlocalizedName( "writtenBook" );
-    // END FCMOD
     public static Item emerald = (new Item(132)).setUnlocalizedName("emerald").setCreativeTab(CreativeTabs.tabMaterials);
-    // FCMOD: Changed
-    /*
     public static Item itemFrame = (new ItemHangingEntity(133, EntityItemFrame.class)).setUnlocalizedName("frame");
     public static Item flowerPot = (new ItemReed(134, Block.flowerPot)).setUnlocalizedName("flowerPot").setCreativeTab(CreativeTabs.tabDecorations);
     public static Item carrot = (new ItemSeedFood(135, 4, 0.6F, Block.carrot.blockID, Block.tilledField.blockID)).setUnlocalizedName("carrots");
@@ -348,54 +168,14 @@
     public static Item carrotOnAStick = (new ItemCarrotOnAStick(142)).setUnlocalizedName("carrotOnAStick");
     public static Item netherStar = (new ItemSimpleFoiled(143)).setUnlocalizedName("netherStar").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item pumpkinPie = (new ItemFood(144, 8, 0.3F, false)).setUnlocalizedName("pumpkinPie").setCreativeTab(CreativeTabs.tabFood);
-    */
-    public static Item itemFrame = ( new ItemHangingEntity( 133, EntityItemFrame.class ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "frame" );
-    public static Item flowerPot = ( new ItemReed( 134, Block.flowerPot ) ).SetBuoyant().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "flowerPot" ).setCreativeTab( CreativeTabs.tabDecorations );
-    public static Item carrot = ( new FCItemSeedFood( 135, 3, 0F, Block.carrot.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "carrots" );
-    public static Item potato = ( new FCItemSeedFood( 136, 3, 0F, Block.potato.blockID ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potato" );
-    public static Item bakedPotato = ( new ItemFood( 137, 2, 0F, false ) ).SetFilterableProperties( m_iFilterable_Small ).SetAsBasicPigFood().setUnlocalizedName( "potatoBaked" );	    
-    public static Item poisonousPotato = ( new ItemFood( 138, 1, 0F, false ) ).setPotionEffect( Potion.poison.id, 5, 0, 0.6F ).SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "potatoPoisonous" );
-    public static ItemEmptyMap emptyMap = new FCItemEmptyMap( 139 );
-    public static Item goldenCarrot = ( new ItemFood( 140, 1, 0F, false ) ).SetNonBuoyant().SetFilterableProperties( m_iFilterable_Small ).setUnlocalizedName( "carrotGolden" );
-    public static Item skull = ( new ItemSkull( 141 ) ).SetBuoyant().SetIncineratedInCrucible().SetFilterableProperties( m_iFilterable_SolidBlock ).setUnlocalizedName( "skull" );
-    public static Item carrotOnAStick = new FCItemCarrotOnAStick( 142 );
-    public static Item netherStar = new FCItemNetherStar( 143 );
-    public static Item pumpkinPie = ( new ItemFood( 144, 2, 2.5F, false ) ).setAlwaysEdible().setUnlocalizedName( "pumpkinPie" ).setCreativeTab( CreativeTabs.tabFood );	    
-    // END FCMOD
     public static Item firework = (new ItemFirework(145)).setUnlocalizedName("fireworks");
     public static Item fireworkCharge = (new ItemFireworkCharge(146)).setUnlocalizedName("fireworksCharge").setCreativeTab(CreativeTabs.tabMisc);
-    // FCMOD: Changed
-    /*
     public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)(new ItemEnchantedBook(147)).setMaxStackSize(1).setUnlocalizedName("enchantedBook");
     public static Item comparator = (new ItemReed(148, Block.redstoneComparatorIdle)).setUnlocalizedName("comparator").setCreativeTab(CreativeTabs.tabRedstone);
     public static Item netherrackBrick = (new Item(149)).setUnlocalizedName("netherbrick").setCreativeTab(CreativeTabs.tabMaterials);
     public static Item netherQuartz = (new Item(150)).setUnlocalizedName("netherquartz").setCreativeTab(CreativeTabs.tabMaterials);
-    */
-    public static ItemEnchantedBook enchantedBook = (ItemEnchantedBook)( new FCItemEnchantedBook( 147 ) ).setMaxStackSize( 1 ).setUnlocalizedName( "enchantedBook" );
-    public static Item comparator = ( new FCItemStub( 148 ) ).setUnlocalizedName( "comparator" );
-    public static Item netherrackBrick = ( new Item(149 ) ).setUnlocalizedName( "netherbrick" );
-    public static Item netherQuartz = ( new FCItemNetherQuartz( 150 ) ).setUnlocalizedName( "netherquartz" ).setCreativeTab( CreativeTabs.tabMaterials );
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item tntMinecart = (new ItemMinecart(151, 3)).setUnlocalizedName("minecartTnt");
     public static Item hopperMinecart = (new ItemMinecart(152, 5)).setUnlocalizedName("minecartHopper");
-    */
-    // client
-    //public static Item minecartTnt = ( new FCItemStub( 151 ) ).setUnlocalizedName( "minecartTnt" );
-    //public static Item minecartHopper = ( new FCItemStub( 152 ) ).setUnlocalizedName( "minecartHopper" );
-    // Added aliases to avoid annoying naming differences between client and server
-    //public static Item tntMinecart = minecartTnt;
-    //public static Item hopperMinecart = minecartHopper;
-    // server
-    public static Item tntMinecart = ( new FCItemStub( 151 ) ).setUnlocalizedName( "minecartTnt" );
-    public static Item hopperMinecart = ( new FCItemStub( 152 ) ).setUnlocalizedName( "minecartHopper" );
-    // Added aliases to avoid annoying naming differences between client and server
-    public static Item minecartTnt = tntMinecart;
-    public static Item minecartHopper = hopperMinecart;
-    // END FCMOD
-    // FCMOD: Changed
-    /*
     public static Item record13 = (new ItemRecord(2000, "13")).setUnlocalizedName("record");
     public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record");
     public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record");
@@ -408,20 +188,6 @@
     public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record");
     public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record");
     public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record");
-    */
-    public static Item record13 = (new ItemRecord(2000, "13")).setUnlocalizedName("record");
-    public static Item recordCat = (new ItemRecord(2001, "cat")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordBlocks = (new ItemRecord(2002, "blocks")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordChirp = (new ItemRecord(2003, "chirp")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordFar = (new ItemRecord(2004, "far")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordMall = (new ItemRecord(2005, "mall")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordMellohi = (new ItemRecord(2006, "mellohi")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordStal = (new ItemRecord(2007, "stal")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordStrad = (new ItemRecord(2008, "strad")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordWard = (new ItemRecord(2009, "ward")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item record11 = (new ItemRecord(2010, "11")).setUnlocalizedName("record").setCreativeTab( null );
-    public static Item recordWait = (new ItemRecord(2011, "wait")).setUnlocalizedName("record").setCreativeTab( null );
-    // END FCMOD
 
     /** The ID of this item. */
     public final int itemID;
@@ -453,9 +219,6 @@
     {
         this.itemID = 256 + par1;
 
-        // FCMOD: Code added
-        if ( !m_bSuppressConflictWarnings )
-    	// END FCMOD
         if (itemsList[256 + par1] != null)
         {
             System.out.println("CONFLICT @ " + par1);
@@ -483,14 +246,10 @@
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
-    // FCMOD: Removed and replaced later
-    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return 1.0F;
     }
-    */
-    // END FCMOD
 
     /**
      * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer
@@ -579,14 +338,10 @@
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
-    // FCMOD: Removed and replaced
-    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return false;
     }
-    */
-    // END FCMOD
 
     /**
      * Called when a player right clicks an entity with an item.
@@ -690,10 +445,7 @@
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    // FCMOD: Changed
-    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
-    public void onUpdate( ItemStack stack, World world, EntityPlayer entity, int iInventorySlot, boolean bIsHandHeldItem ) {}
-    // END FCMOD
+    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5) {}
 
     /**
      * Called when item is crafted/smelted. Used only by maps so far.
@@ -821,411 +573,4 @@
     {
         StatList.initStats();
     }
-
-	// FCMOD: Added New
-    public static boolean m_bSuppressConflictWarnings = false;
-    
-    /**
-     * Method which replaces canPlaceItemBlockOnSide() in ItemBlock. Allows the client to prevent item usage before it is relayed
-     * to the server by returning false.  Only called on client.
-     */    
-    public boolean CanItemBeUsedByPlayer( World world, int i, int j, int k, int iFacing, EntityPlayer player, ItemStack stack )
-    {
-    	return true;    	
-    }
-    
-    public boolean DoZombiesConsume()
-    {
-    	return false;
-    }
-    
-    public boolean IsEfficientVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
-    {
-        return false;
-    }
-    
-    public boolean canHarvestBlock( ItemStack stack, World world, Block block, int i, int j, int k )
-    {
-        return false;
-    }
-    
-    public float getStrVsBlock( ItemStack stack, World world, Block block, int i, int j, int k )
-    {
-        return 1F;
-    }
-    
-    public boolean IsMultiUsePerClick()
-    {
-    	return true;
-    }
-    
-    public float GetExhaustionOnUsedToHarvestBlock( int iBlockID, World world, int i, int j, int k, int iBlockMetadata )
-    {
-    	return 0.025F; // standard default exhaustion amount
-    }
-    
-    public void InitializeStackOnGiveCommand( Random rand, ItemStack stack )
-    {
-    }
-    
-    public void UpdateUsingItem( ItemStack stack, World world, EntityPlayer player )
-    {
-    }
-    
-    public int GetItemUseWarmupDuration()
-    {
-    	return 7;
-    }
-    
-    public boolean IgnoreDamageWhenComparingDuringUse()
-    {
-    	return false;
-    }
-    
-    //----------- Animal Food related functionality -----------//
-    
-    public static final int m_iBaseHerbivoreItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
-    public static final int m_iBasePigItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 4 );
-    public static final int m_iBaseChickenItemFoodValue = ( EntityAnimal.m_iBaseGrazeFoodValue * 8 );
-
-    private int m_iHerbivoreFoodValue = 0;
-    private int m_iBirdFoodValue = 0;
-    private int m_iPigFoodValue = 0;
-    
-    public int GetHerbivoreFoodValue( int iItemDamage )
-    {
-    	return m_iHerbivoreFoodValue;
-    }
-    
-    public Item SetHerbivoreFoodValue( int iFoodValue )
-    {
-    	m_iHerbivoreFoodValue = iFoodValue;
-    	
-    	return this;
-    }
-    
-    public Item SetAsBasicHerbivoreFood()
-    {
-    	return SetHerbivoreFoodValue( m_iBaseHerbivoreItemFoodValue );
-    }
-    
-    public int GetChickenFoodValue( int iItemDamage )
-    {
-    	return m_iBirdFoodValue;
-    }
-    
-    public Item SetChickenFoodValue( int iFoodValue )
-    {
-    	m_iBirdFoodValue = iFoodValue;
-    	
-    	return this;
-    }
-    
-    public Item SetAsBasicChickenFood()
-    {
-    	return SetChickenFoodValue( m_iBaseChickenItemFoodValue );
-    }
-    
-    public int GetPigFoodValue( int iItemDamage )
-    {
-    	return m_iPigFoodValue;
-    }
-    
-    public Item SetPigFoodValue( int iFoodValue )
-    {
-    	m_iPigFoodValue = iFoodValue;
-    	
-    	return this;
-    }
-    
-    public Item SetAsBasicPigFood()
-    {
-    	return SetPigFoodValue( m_iBasePigItemFoodValue );
-    }
-    
-    public boolean IsWolfFood()
-    {
-    	return false;
-    }
-    
-    public int GetWolfHealAmount()
-    {
-    	return 0;
-    }
-    
-    //------------- Buoyancy related functionality ------------//
-    
-	private float m_fBuoyancy = -1.0F;
-	
-    public Item SetBuoyancy( float fBuoyancy )
-    {
-    	m_fBuoyancy = fBuoyancy;
-    	
-    	return this;
-    }
-    
-    public Item SetBuoyant() { return SetBuoyancy( 1F ); }
-    public Item SetNonBuoyant() { return SetBuoyancy( -1F ); }
-    public Item SetNeutralBuoyant() { return SetBuoyancy( 0F ); }
-    
-    public float GetBuoyancy( int iItemDamage )
-    {
-    	return m_fBuoyancy;
-    }
-    
-    public int GetWeightWhenWorn()
-    {
-    	return 0;
-    }
-    
-    //------------- Bellows related functionality ------------//
-    
-	private int m_iBellowsBlowDistance = 0;
-	
-	/**
-	 * 3 = light powders or light large surface objects like paper or bat wings
-	 * 2 = seeds, dyes, fibers, chunkier powders like ground netherrack or sand, 
-	 * 	   heavier sheets like bark or wicker
-	 * 1 = fabric or wool, small leather like straps, arrows, heavier small mobsdrops like creeper 
-	 * 	   oysters, and witch wart, dirt and gravel, heavy seeds like cocoa beans and netherwart
-	 * 0 = everything else
-	 */
-    public Item SetBellowsBlowDistance( int iDistance )
-    {
-    	m_iBellowsBlowDistance = iDistance;
-    	
-    	return this;
-    }
-    
-    public int GetBellowsBlowDistance( int iItemDamage )
-    {
-    	return m_iBellowsBlowDistance;
-    }
-    
-    //------------- Enchanting related functionality ------------//
-    
-	private int m_iInfernalMaxNumEnchants = 0;
-	private int m_iInfernalMaxEnchantmentCost = 0;
-	
-    public Item SetInfernalMaxNumEnchants( int iMaxNumEnchants )
-    {
-    	m_iInfernalMaxNumEnchants = iMaxNumEnchants;
-    	
-    	return this;
-    }
-    
-    public int GetInfernalMaxNumEnchants()
-    {
-    	return m_iInfernalMaxNumEnchants;
-    }    
-    
-    public Item SetInfernalMaxEnchantmentCost( int iMaxEnchantmentCost )
-    {
-    	m_iInfernalMaxEnchantmentCost = iMaxEnchantmentCost;
-    	
-    	return this;
-    }
-    
-    public int GetInfernalMaxEnchantmentCost()
-    {
-    	return m_iInfernalMaxEnchantmentCost;
-    }    
-    
-    public boolean IsEnchantmentApplicable( Enchantment enchantment )
-    {
-    	return enchantment.type == EnumEnchantmentType.all;
-    }
-    
-    //------------- Crafting related functionality ------------//
-    
-    protected int m_iDefaultFurnaceBurnTime = 0;
-    protected boolean m_bIsInceratedInCrucible = false;
-    
-    public boolean IsConsumedInCrafting()
-    {
-    	return true;
-    }
-    
-    public boolean IsDamagedInCrafting()
-    {
-    	return false;
-    }    
-    
-    public void OnUsedInCrafting( int iItemDamage, EntityPlayer player, ItemStack outputStack )
-    {
-    	OnUsedInCrafting( player, outputStack );
-    }
-    
-    public void OnUsedInCrafting( EntityPlayer player, ItemStack outputStack )
-    {
-    }
-    
-    public void OnDamagedInCrafting( EntityPlayer player )
-    {
-    }
-    
-    public void OnBrokenInCrafting( EntityPlayer player )
-    {
-    }
-    
-    public int GetFurnaceBurnTime( int iItemDamage )
-    {
-    	return m_iDefaultFurnaceBurnTime;
-    }
-    
-    public Item SetFurnaceBurnTime( int iBurnTime )
-    {
-    	m_iDefaultFurnaceBurnTime = iBurnTime;
-    	
-    	return this;
-    }
-    
-    public Item SetFurnaceBurnTime( FCEnumFurnaceBurnTime burnTime )
-    {
-    	SetFurnaceBurnTime( burnTime.m_iBurnTime );
-    	
-    	return this;
-    }
-    
-    public int GetCampfireBurnTime( int iItemDamage )
-    {
-    	return GetFurnaceBurnTime( iItemDamage );
-    }
-    
-    /**
-     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
-     */
-    public boolean GetCanItemStartFireOnUse( int iItemDamage )
-    {
-    	return false;
-    }    
-    
-    /**
-     * Used to override default activation behavior on certain blocks like accessing inventory on furnace and campfires 
-     */
-    public boolean GetCanItemBeSetOnFireOnUse( int iItemDamage )
-    {
-    	return false;
-    }
-    
-    public boolean GetCanBeFedDirectlyIntoCampfire( int iItemDamage )
-    {
-		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
-			GetCampfireBurnTime( iItemDamage ) > 0;
-    }
-    
-    public boolean GetCanBeFedDirectlyIntoBrickOven( int iItemDamage )
-    {
-		return !GetCanItemBeSetOnFireOnUse( iItemDamage ) && !GetCanItemStartFireOnUse( iItemDamage ) &&
-			GetFurnaceBurnTime( iItemDamage ) > 0;
-    }
-    
-    public boolean IsIncineratedInCrucible()
-    {
-    	return m_bIsInceratedInCrucible;
-    }
-    
-    public Item SetIncineratedInCrucible()
-    {
-    	m_bIsInceratedInCrucible = true;
-    	
-    	return this;
-    }
-    
-    public Item SetNotIncineratedInCrucible()
-    {
-    	m_bIsInceratedInCrucible = false;
-    	
-    	return this;
-    }
-    
-    public boolean DoesConsumeContainerItemWhenCrafted( Item containerItem )
-    {
-    	return false;
-    }
-    
-    //------------- Piston Packing related functionality ------------//
-    
-    public boolean IsPistonPackable( ItemStack stack )
-    {
-    	return false;
-    }
-    
-    public int GetRequiredItemCountToPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
-    {
-    	return 0;
-    }
-    
-    //------------- Hopper Filtering Functionality -----------//
-    
-    protected int m_iFilterablePropertiesBitfield = 0;
-    
-    public boolean CanItemPassIfFilter( ItemStack filteredItem )
-    {
-    	return true;
-    }
-    
-    public int GetFilterableProperties( ItemStack stack )
-    {
-    	return m_iFilterablePropertiesBitfield;
-    }
-    
-    public Item SetFilterableProperties( int iProperties )
-    {
-    	m_iFilterablePropertiesBitfield = iProperties;
-    	
-    	return this;
-    }
-    
-    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
-    {
-    	return false;
-    }
-    
-    //------------- Deprecated tool functionality ------------//
-    
-    public static void SetAllPicksToBeEffectiveVsBlock( Block block )
-    {
-    	block.SetPicksEffectiveOn( true );
-    }
-    
-    public static void SetAllAxesToBeEffectiveVsBlock( Block block )
-    {
-    	block.SetAxesEffectiveOn( true );
-    }
-    
-    public static void SetAllShovelsToBeEffectiveVsBlock( Block block )
-    {
-    	block.SetShovelsEffectiveOn( true );
-    }
-    
-    //----- Block Dispenser Related Functionality -----//
-    
-	/**
-	 * This method should return true if the item is successfully placed (in which case the BD will 
-	 * consume the corresponding item in its inventory), false otherwise.  Co-ordinates specify
-	 * the BD position.
-	 */
-	public boolean OnItemUsedByBlockDispenser( ItemStack stack, World world, 
-		int i, int j, int k, int iFacing )
-	{
-		FCBetterThanWolves.fcBlockDispenser.SpitOutItem( world, i, j, k, stack );
-		
-        world.playAuxSFX( 1000, i, j, k, 0 ); // normal pitch click							        
-        
-		return true;
-	}
-	
-	//----------- Client Side Functionality -----------//
-    // END FCMOD    
 }
--- ItemArmor.java	Fri Mar  8 13:23:43 2019
+++ ItemArmor.java	Fri Apr 20 22:33:12 2018
@@ -14,12 +14,7 @@
     public final int armorType;
 
     /** Holds the amount of damage that the armor reduces at full durability. */
-    // FCMOD: Changed to remove final
-    /*
     public final int damageReduceAmount;
-    */
-    public int damageReduceAmount;
-    // END FCMOD
 
     /**
      * Used on RenderPlayer to select the correspondent armor to be rendered on the player: 0 is cloth, 1 is chain, 2 is
@@ -40,11 +35,7 @@
         this.setMaxDamage(par2EnumArmorMaterial.getDurability(par4));
         this.maxStackSize = 1;
         this.setCreativeTab(CreativeTabs.tabCombat);
-        // FCMOD: Code removed
-        /*
         BlockDispenser.dispenseBehaviorRegistry.putObject(this, field_96605_cw);
-        */
-        // END FCMOD
     }
 
     /**
@@ -177,33 +168,4 @@
     {
         return maxDamageArray;
     }
-    
-    // FCMOD: Added New
-    @Override
-    public boolean IsEnchantmentApplicable( Enchantment enchantment )
-    {
-    	if ( enchantment.type == EnumEnchantmentType.armor )
-    	{
-    		return true;
-    	}
-    	else if ( enchantment.type == EnumEnchantmentType.armor_head )
-    	{		
-    		return armorType == 0;
-    	}		
-    	else if ( enchantment.type == EnumEnchantmentType.armor_torso )
-    	{		
-    		return armorType == 1;
-    	}		
-    	else if ( enchantment.type == EnumEnchantmentType.armor_legs )
-    	{		
-    		return armorType == 2;
-    	}		
-    	else if ( enchantment.type == EnumEnchantmentType.armor_feet )
-    	{		
-    		return armorType == 3;
-    	}
-    	
-    	return super.IsEnchantmentApplicable( enchantment );
-    }
-    // END FCMOD
 }
--- ItemAxe.java	Wed Mar 28 14:30:57 2018
+++ ItemAxe.java	Fri Apr 20 22:33:12 2018
@@ -7,7 +7,7 @@
 
     protected ItemAxe(int par1, EnumToolMaterial par2EnumToolMaterial)
     {
-        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);        
+        super(par1, 3, par2EnumToolMaterial, blocksEffectiveAgainst);
     }
 
     /**
@@ -17,5 +17,5 @@
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block != null && (par2Block.blockMaterial == Material.wood || par2Block.blockMaterial == Material.plants || par2Block.blockMaterial == Material.vine) ? this.efficiencyOnProperMaterial : super.getStrVsBlock(par1ItemStack, par2Block);
-    }    
+    }
 }
--- ItemBlock.java	Sat Jan 26 22:49:05 2019
+++ ItemBlock.java	Fri Apr 20 22:33:12 2018
@@ -1,9 +1,6 @@
 package net.minecraft.src;
 
-//FCMOD: Changed
-//public class ItemBlock extends Item
-public class ItemBlock extends FCItemPlacesAsBlock
-//END FCMOD
+public class ItemBlock extends Item
 {
     /** The block ID of the Block associated with this ItemBlock */
     private int blockID;
@@ -26,8 +23,6 @@
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
-    // FCMOD: Removed and replaced in parent class
-    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -106,8 +101,6 @@
             return false;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns the unlocalized name of this item. This version accepts an ItemStack so different stacks can have
@@ -125,138 +118,4 @@
     {
         return Block.blocksList[this.blockID].getUnlocalizedName();
     }
-    
-    // FCMOD: Added New
-    private boolean m_bHasOldNamePrefix = false;
-    
-    @Override
-    public float GetBuoyancy( int iItemDamage )
-    {
-    	return Block.blocksList[blockID].GetBuoyancy( iItemDamage );
-    }
-    
-    @Override
-    public Item SetBuoyancy( float fBuoyancy )
-    {
-    	Block.blocksList[blockID].SetBuoyancy( fBuoyancy );
-    	
-    	return super.SetBuoyancy( fBuoyancy );
-    }
-    
-    @Override
-    public boolean IsPistonPackable( ItemStack stack )
-    {
-    	return Block.blocksList[blockID].IsPistonPackable( stack );
-    }
-    
-    @Override
-    public int GetRequiredItemCountToPistonPack( ItemStack stack )
-    {
-    	return Block.blocksList[blockID].GetRequiredItemCountToPistonPack( stack );
-    }
-    
-    @Override
-    public int GetResultingBlockIDOnPistonPack( ItemStack stack )
-    {
-    	return Block.blocksList[blockID].GetResultingBlockIDOnPistonPack( stack );
-    }
-    
-    @Override
-    public int GetResultingBlockMetadataOnPistonPack( ItemStack stack )
-    {
-    	return Block.blocksList[blockID].GetResultingBlockMetadataOnPistonPack( stack );
-    }
-
-    @Override
-    public int GetFurnaceBurnTime( int iItemDamage )
-    {
-    	return Block.blocksList[blockID].GetFurnaceBurnTime( iItemDamage );
-    }
-    
-    @Override
-    public Item SetFurnaceBurnTime( int iBurnTime )
-    {
-    	Block.blocksList[blockID].SetFurnaceBurnTime( iBurnTime );
-    	
-    	return super.SetFurnaceBurnTime( iBurnTime );
-    }
-    
-    @Override
-    public int GetHerbivoreFoodValue( int iItemDamage )
-    {
-    	return Block.blocksList[blockID].GetHerbivoreItemFoodValue( iItemDamage );
-    }
-    
-    @Override
-    public Item SetHerbivoreFoodValue( int iFoodValue )
-    {
-    	Block.blocksList[blockID].SetHerbivoreItemFoodValue( iFoodValue );
-    	
-    	return super.SetHerbivoreFoodValue( iFoodValue );
-    }
-    
-    @Override
-    public int GetChickenFoodValue( int iItemDamage )
-    {
-    	return Block.blocksList[blockID].GetChickenItemFoodValue( iItemDamage );
-    }
-    
-    @Override
-    public Item SetChickenFoodValue( int iFoodValue )
-    {
-    	Block.blocksList[blockID].SetChickenItemFoodValue( iFoodValue );
-    	
-    	return super.SetChickenFoodValue( iFoodValue );
-    }
-    
-    @Override
-    public int GetPigFoodValue( int iItemDamage )
-    {
-    	return Block.blocksList[blockID].GetPigItemFoodValue( iItemDamage );
-    }
-    
-    @Override
-    public Item SetPigFoodValue( int iFoodValue )
-    {
-    	Block.blocksList[blockID].SetPigItemFoodValue( iFoodValue );
-    	
-    	return super.SetPigFoodValue( iFoodValue );
-    }
-    
-    @Override
-    public boolean IsIncineratedInCrucible()
-    {
-    	return Block.blocksList[blockID].IsIncineratedInCrucible();
-    }
-    
-    @Override
-    public FCItemPlacesAsBlock SetAssociatedBlockID( int iBlockID )
-    {
-    	blockID = iBlockID;
-    	
-    	return super.SetAssociatedBlockID( iBlockID );
-    }
-    
-    @Override
-    public boolean CanItemPassIfFilter( ItemStack filteredItem )
-    {
-    	return Block.blocksList[blockID].CanItemPassIfFilter( filteredItem );
-    }
-    
-    @Override
-    public int GetFilterableProperties( ItemStack stack )
-    {
-    	return Block.blocksList[blockID].GetFilterableProperties( stack );
-    }
-    
-    @Override
-    public boolean CanTransformItemIfFilter( ItemStack filteredItem )
-    {
-    	return Block.blocksList[blockID].CanTransformItemIfFilter( filteredItem );
-    }
-    
-    //------------- Class Specific Methods ------------//
-    
-	//----------- Client Side Functionality -----------//
-    // END FCMOD
 }
--- ItemBucket.java	Sat Sep  1 13:08:06 2018
+++ ItemBucket.java	Fri Apr 20 22:33:12 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 09/01/2018
-
 package net.minecraft.src;
 
 public class ItemBucket extends Item
--- ItemFood.java	Mon Dec 14 15:10:42 2020
+++ ItemFood.java	Fri Apr 20 22:33:13 2018
@@ -39,11 +39,6 @@
         this.isWolfsFavoriteMeat = par4;
         this.saturationModifier = par3;
         this.setCreativeTab(CreativeTabs.tabFood);
-        // FCMOD: Added
-        maxStackSize = 16;
-        SetBuoyant();     
-        SetIncineratedInCrucible();
-        // END FCMOD
     }
 
     public ItemFood(int par1, int par2, boolean par3)
@@ -93,12 +88,6 @@
         {
             par3EntityPlayer.setItemInUse(par1ItemStack, this.getMaxItemUseDuration(par1ItemStack));
         }
-        // FCMOD: Added
-    	else
-    	{
-    		par3EntityPlayer.OnCantConsume();
-    	}
-        // END FCMOD
 
         return par1ItemStack;
     }
@@ -145,46 +134,4 @@
         this.alwaysEdible = true;
         return this;
     }
-    
-    // FCMOD: Added New    
-    private boolean m_bDoZombiesConsume = false;
-    
-    public ItemFood( int iItemID, int iHealAmount, float fSaturationModifier, boolean bWolfsFavoriteMeat, boolean bZombiesConsume )
-    {
-    	this( iItemID, iHealAmount, fSaturationModifier, bWolfsFavoriteMeat );
-    	
-    	m_bDoZombiesConsume = bZombiesConsume;
-    }
-    
-    @Override
-    public boolean DoZombiesConsume()
-    {
-    	return m_bDoZombiesConsume;
-    }
-    
-    @Override
-    public boolean IsMultiUsePerClick()
-    {
-    	return false;
-    }
-
-    @Override
-    public boolean IsWolfFood()
-    {
-    	return isWolfsFavoriteMeat();
-    }
-    
-    @Override
-    public int GetWolfHealAmount()
-    {
-    	return getHealAmount();
-    }
-    
-    public int GetHungerRestored()
-    {
-    	// multiply original values by 3 to take into account increased hunger resolution 
-    	
-    	return healAmount * 3;
-    }
-    // END FCMOD
 }
--- ItemInWorldManager.java	Wed Jul 25 13:34:34 2018
+++ ItemInWorldManager.java	Fri Apr 20 22:33:13 2018
@@ -27,9 +27,6 @@
     private int posZ;
     private int field_73093_n;
     private int durabilityRemainingOnBlock;
-    // FCMOD: Added
-    private int m_iHarvestingFromFacing;
-    // END FCMOD
 
     public ItemInWorldManager(World par1World)
     {
@@ -102,10 +99,7 @@
                 if (var4 >= 1.0F)
                 {
                     this.receivedFinishDiggingPacket = false;
-                    // FCMOD: Changed
-                    //this.tryHarvestBlock(this.posX, this.posY, this.posZ);
-                    this.tryHarvestBlock(this.posX, this.posY, this.posZ, this.m_iHarvestingFromFacing);
-                    // END FCMOD
+                    this.tryHarvestBlock(this.posX, this.posY, this.posZ);
                 }
             }
         }
@@ -147,17 +141,12 @@
             {
                 if (!this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4))
                 {
-                	// FCMOD: Changed
-                    //this.tryHarvestBlock(par1, par2, par3);
-                    this.tryHarvestBlock(par1, par2, par3, par4);
-                    // END FCMOD
+                    this.tryHarvestBlock(par1, par2, par3);
                 }
             }
             else
             {
-            	// FCMOD: Removed
-                //this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
-            	// END FCMOD
+                this.theWorld.extinguishFire((EntityPlayer)null, par1, par2, par3, par4);
                 this.initialDamage = this.curblockDamage;
                 float var5 = 1.0F;
                 int var6 = this.theWorld.getBlockId(par1, par2, par3);
@@ -170,10 +159,7 @@
 
                 if (var6 > 0 && var5 >= 1.0F)
                 {
-                	// FCMOD: Changed
-                    //this.tryHarvestBlock(par1, par2, par3);
-                    this.tryHarvestBlock(par1, par2, par3, par4);
-                    // END FCMOD
+                    this.tryHarvestBlock(par1, par2, par3);
                 }
                 else
                 {
@@ -189,11 +175,7 @@
         }
     }
 
-	// FCMOD: Changed (function name differs between client and server ), "overloaded" function required for DemoWorldManager
-    //public void blockRemoving(int par1, int par2, int par3)    
-    public void blockRemoving(int par1, int par2, int par3 ) { blockRemoving( par1, par2, par3, 1 ); }
-    public void blockRemoving(int par1, int par2, int par3, int iFromFacing)
-    // END FCMOD
+    public void blockRemoving(int par1, int par2, int par3)
     {
         if (par1 == this.curBlockX && par2 == this.curBlockY && par3 == this.curBlockZ)
         {
@@ -209,10 +191,7 @@
                 {
                     this.isDestroyingBlock = false;
                     this.theWorld.destroyBlockInWorldPartially(this.thisPlayerMP.entityId, par1, par2, par3, -1);
-                    // FCMOD: Changed
-                    //this.tryHarvestBlock(par1, par2, par3);
-                    this.tryHarvestBlock(par1, par2, par3, iFromFacing);
-                    // END FCMOD
+                    this.tryHarvestBlock(par1, par2, par3);
                 }
                 else if (!this.receivedFinishDiggingPacket)
                 {
@@ -222,9 +201,6 @@
                     this.posY = par2;
                     this.posZ = par3;
                     this.field_73093_n = this.initialDamage;
-                    // FCMOD: Added
-                    m_iHarvestingFromFacing = iFromFacing;
-                    // END FCMOD
                 }
             }
         }
@@ -257,10 +233,6 @@
         if (var4 != null && var6)
         {
             var4.onBlockDestroyedByPlayer(this.theWorld, par1, par2, par3, var5);
-            
-            // FCMOD: Panick animals when blocks are destroyed near them
-            theWorld.NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( thisPlayerMP, var4, par1, par2, par3 );            
-            // END FCMOD
         }
 
         return var6;
@@ -269,8 +241,6 @@
     /**
      * Attempts to harvest a block at the given coordinate
      */
-    // FCMOD: Removed and replaced later
-    /*
     public boolean tryHarvestBlock(int par1, int par2, int par3)
     {
         if (this.gameType.isAdventure() && !this.thisPlayerMP.canCurrentToolHarvestBlock(par1, par2, par3))
@@ -312,8 +282,6 @@
             return var6;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Attempts to right-click use an item by the given EntityPlayer in the given World
@@ -399,96 +367,5 @@
     public void setWorld(WorldServer par1WorldServer)
     {
         this.theWorld = par1WorldServer;
-    }   
-    
-    // FCMOD: Added
-    
-	// "overloaded" function required for DemoWorldManager
-    public boolean tryHarvestBlock( int i, int j, int k ) { return tryHarvestBlock( i, j, k, 1 ); }
-    public boolean tryHarvestBlock( int i, int j, int k, int iFromSide )
-    {
-        if ( gameType.isAdventure() && !thisPlayerMP.canCurrentToolHarvestBlock( i, j, k ) )
-        {
-            return false;
-        }
-        else if ( isCreative() )
-        {
-            int iBlockID = theWorld.getBlockId( i, j, k );
-            int iBlockMetadata = theWorld.getBlockMetadata( i, j, k );
-            
-            theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( theWorld.getBlockMetadata( i, j, k ) << 12 ) );
-            
-            boolean bBlockRemoved = removeBlock( i, j, k );
-
-            FCUtilsWorld.SendPacketToPlayer( thisPlayerMP.playerNetServerHandler, new Packet53BlockChange(i, j, k, this.theWorld) );
-
-            return bBlockRemoved;
-        }
-        else
-        {
-    		return SurvivalTryHarvestBlock( i, j, k, iFromSide );
-        }
-    }
-    
-    public boolean SurvivalTryHarvestBlock( int i, int j, int k, int iFromSide )
-    {
-        int iBlockID = theWorld.getBlockId(i, j, k);
-    	Block block = Block.blocksList[iBlockID];
-    	
-    	if ( block == null )
-    	{
-    		return false;
-    	}
-    	
-        int iMetadata = theWorld.getBlockMetadata(i, j, k);
-        
-        theWorld.playAuxSFXAtEntity( thisPlayerMP, 2001, i, j, k, iBlockID + ( iMetadata << 12 ) );
-        
-        ItemStack currentStack = thisPlayerMP.getCurrentEquippedItem();
-        
-        boolean bRemovingBlock = true;
-        boolean bConvertingBlock = false;
-        
-        boolean bHarvestingBlock = thisPlayerMP.canHarvestBlock( Block.blocksList[iBlockID], i, j, k );
-        
-        if ( !bHarvestingBlock )
-        {
-        	bConvertingBlock = block.CanConvertBlock( currentStack, theWorld, i, j, k );
-        	
-        	if ( bConvertingBlock )
-        	{
-                bRemovingBlock = !( block.ConvertBlock( currentStack, theWorld, i, j, k, iFromSide ) );
-        	}
-        }
-
-        if ( bRemovingBlock )
-        {
-        	bRemovingBlock = removeBlock( i, j, k );
-
-            if ( bRemovingBlock && !bConvertingBlock )
-            {
-    	        if ( bHarvestingBlock )
-    	        {
-    	            Block.blocksList[iBlockID].harvestBlock( theWorld, thisPlayerMP, i, j, k, iMetadata );
-    	        }
-    	        else 
-    	        {
-    	        	Block.blocksList[iBlockID].OnBlockDestroyedWithImproperTool( theWorld, thisPlayerMP, i, j, k, iMetadata );
-    	        }
-            }
-        }
-
-        if ( currentStack != null )
-        {
-            currentStack.onBlockDestroyed( theWorld, iBlockID, i, j, k, thisPlayerMP );
-
-            if ( currentStack.stackSize == 0 )
-            {
-                thisPlayerMP.destroyCurrentEquippedItem();
-            }
-        }
-
-        return bRemovingBlock;
     }
-    // END FCMOD
 }
--- ItemMap.java	Wed Apr  4 13:14:43 2018
+++ ItemMap.java	Fri Apr 20 22:33:13 2018
@@ -68,10 +68,7 @@
                             boolean var21 = var19 * var19 + var20 * var20 > (var11 - 2) * (var11 - 2);
                             int var22 = (var7 / var6 + var13 - var4 / 2) * var6;
                             int var23 = (var8 / var6 + var18 - var5 / 2) * var6;
-                            // FCMOD: Change
-                            //int[] var24 = new int[256];
-                            int[] var24 = new int[4096];
-                            // END FCMOD
+                            int[] var24 = new int[256];
                             Chunk var25 = par1World.getChunkFromBlockCoords(var22, var23);
 
                             if (!var25.isEmpty())
@@ -167,10 +164,7 @@
                                 var31 = 0;
                                 var32 = 0;
 
-                                // FCMOD: Change
-                                //for (var33 = 0; var33 < 256; ++var33)
-                                for (var33 = 0; var33 < 4096; ++var33)
-                                // END FCMOD
+                                for (var33 = 0; var33 < 256; ++var33)
                                 {
                                     if (var24[var33] > var31)
                                     {
@@ -256,11 +250,7 @@
      * Called each tick as long the item is on a player inventory. Uses by maps to check if is on a player hand and
      * update it's contents.
      */
-    // FCMOD: Changed
-    //public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
-    @Override
-    public void onUpdate(ItemStack par1ItemStack, World par2World, EntityPlayer par3Entity, int par4, boolean par5)
-    // END FCMOD
+    public void onUpdate(ItemStack par1ItemStack, World par2World, Entity par3Entity, int par4, boolean par5)
     {
         if (!par2World.isRemote)
         {
--- ItemReed.java	Tue Jan 22 14:22:42 2019
+++ ItemReed.java	Fri Apr 20 22:33:13 2018
@@ -1,39 +1,20 @@
 package net.minecraft.src;
 
-// FCMOD: Changed to consolidate functionality in parent class
-//public class ItemReed extends Item
-public class ItemReed extends FCItemPlacesAsBlock
-// END FCMOD
+public class ItemReed extends Item
 {
     /** The ID of the block the reed will spawn when used from inventory bar. */
-	// FCMOD: Removed
-    //private int spawnID;
-	// END FCMOD
+    private int spawnID;
 
     public ItemReed(int par1, Block par2Block)
     {
-    	// FCMOD: Changed
-    	/*
         super(par1);
         this.spawnID = par2Block.blockID;
-        */
-    	super( par1, par2Block.blockID );
-    	// END FCMOD
     }
 
-    // FCMOD: Added
-    public ItemReed( int iItemID, int iBlockID )
-    {
-    	super( iItemID, iBlockID );
-    }
-    // END FCMOD
-
     /**
      * Callback for item usage. If the item does something special on right clicking, he will have one of those. Return
      * True if something happen and false if it don't. This is for ITEMS, not BLOCKS
      */
-	// FCMOD: Removed
-    /*
     public boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)
     {
         int var11 = par3World.getBlockId(par4, par5, par6);
@@ -106,6 +87,4 @@
             return true;
         }
     }
-    */
-    // END FCMOD
 }
--- ItemSeeds.java	Wed Feb  6 12:33:21 2019
+++ ItemSeeds.java	Fri Apr 20 22:33:13 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 02/06/2019
-
 package net.minecraft.src;
 
 public class ItemSeeds extends Item
--- ItemShears.java	Mon Apr  9 18:07:08 2018
+++ ItemShears.java	Fri Apr 20 22:33:13 2018
@@ -10,8 +10,6 @@
         this.setCreativeTab(CreativeTabs.tabTools);
     }
 
-    // FCMOD: Removed and replaced in child class
-    /*
     public boolean onBlockDestroyed(ItemStack par1ItemStack, World par2World, int par3, int par4, int par5, int par6, EntityLiving par7EntityLiving)
     {
         if (par3 != Block.leaves.blockID && par3 != Block.web.blockID && par3 != Block.tallGrass.blockID && par3 != Block.vine.blockID && par3 != Block.tripWire.blockID)
@@ -24,31 +22,21 @@
             return true;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Returns if the item (tool) can harvest results from the block type.
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return par1Block.blockID == Block.web.blockID || par1Block.blockID == Block.redstoneWire.blockID || par1Block.blockID == Block.tripWire.blockID;
     }
-    */
-    // END FCMOD
 
     /**
      * Returns the strength of the stack against a given block. 1.0F base, (Quality+1)*2 if correct blocktype, 1.5F if
      * sword
      */
-    // FCMOD: Removed and replaced in child class
-    /*
     public float getStrVsBlock(ItemStack par1ItemStack, Block par2Block)
     {
         return par2Block.blockID != Block.web.blockID && par2Block.blockID != Block.leaves.blockID ? (par2Block.blockID == Block.cloth.blockID ? 5.0F : super.getStrVsBlock(par1ItemStack, par2Block)) : 15.0F;
     }
-    */
-    // END FCMOD
 }
--- ItemSkull.java	Sun Dec  6 20:02:02 2020
+++ ItemSkull.java	Fri Apr 20 22:33:13 2018
@@ -2,14 +2,8 @@
 
 public class ItemSkull extends Item
 {
-	// FCMOD: Changed to add Infused Skull
-	/*
     private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper"};
     public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper"};
-    */
-    private static final String[] skullTypes = new String[] {"skeleton", "wither", "zombie", "char", "creeper", "infused"};
-    public static final String[] field_94587_a = new String[] {"skull_skeleton", "skull_wither", "skull_zombie", "skull_char", "skull_creeper", "fcItemSkullInfused"};
-	// END FCMOD
 
     public ItemSkull(int par1)
     {
@@ -29,11 +23,7 @@
         {
             return false;
         }
-        // FCMOD: Change
-        //else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
-        else if ( !par3World.getBlockMaterial( par4, par5, par6 ).isSolid() && 
-        	!( par7 == 1 && FCUtilsWorld.DoesBlockHaveSmallCenterHardpointToFacing( par3World, par4, par5, par6, 1 ) ) )
-    	// END FCMOD
+        else if (!par3World.getBlockMaterial(par4, par5, par6).isSolid())
         {
             return false;
         }
@@ -74,10 +64,7 @@
             }
             else
             {
-            	// FCMOD: Changed to notify neighbors
-                //par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
-                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 3);
-                // END FCMOD
+                par3World.setBlock(par4, par5, par6, Block.skull.blockID, par7, 2);
                 int var11 = 0;
 
                 if (par7 == 1)
--- ItemStack.java	Sat Jul 21 13:02:06 2018
+++ ItemStack.java	Fri Apr 20 22:33:13 2018
@@ -122,14 +122,10 @@
     /**
      * Returns the strength of the stack against a given block.
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public float getStrVsBlock(Block par1Block)
     {
         return this.getItem().getStrVsBlock(this, par1Block);
     }
-    */
-    // END FCMOD
 
     /**
      * Called whenever this item stack is equipped and right clicked. Returns the new item stack to put in the position
@@ -171,15 +167,6 @@
         this.stackSize = par1NBTTagCompound.getByte("Count");
         this.itemDamage = par1NBTTagCompound.getShort("Damage");
 
-        // FCMOD: Added
-        if ( par1NBTTagCompound.hasKey( "fcDamEx" ) )
-        {
-        	// legacy support for one release where I had exended damage on wool knit representing color
-        	
-        	itemDamage = FCItemWool.GetClosestColorIndex( par1NBTTagCompound.getInteger( "fcDamEx" ) );
-        }
-        // END FCMOD
-        
         if (this.itemDamage < 0)
         {
             this.itemDamage = 0;
@@ -295,12 +282,7 @@
             }
 
             this.itemDamage += par1;
-            // FCMOD: Code change so that items break at 0 damage, not -1
-            /*
             return this.itemDamage > this.getMaxDamage();
-            */
-            return this.itemDamage >= this.getMaxDamage();
-            // END FCMOD
         }
     }
 
@@ -369,14 +351,10 @@
     /**
      * Checks if the itemStack object can harvest a specified block
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public boolean canHarvestBlock(Block par1Block)
     {
         return Item.itemsList[this.itemID].canHarvestBlock(par1Block);
     }
-    */
-    // END FCMOD
 
     public boolean interactWith(EntityLiving par1EntityLiving)
     {
@@ -450,10 +428,7 @@
      * Called each tick as long the ItemStack in on player inventory. Used to progress the pickup animation and update
      * maps.
      */
-    // FCMOD: Changed
-    //public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
-    public void updateAnimation(World par1World, EntityPlayer par2Entity, int par3, boolean par4)
-    // END FCMOD
+    public void updateAnimation(World par1World, Entity par2Entity, int par3, boolean par4)
     {
         if (this.animationsToGo > 0)
         {
@@ -659,56 +634,4 @@
 
         this.stackTagCompound.setInteger("RepairCost", par1);
     }
-    
-    // FCMOD: Added
-    public boolean canHarvestBlock( World world, Block block, int i, int j, int k )
-    {
-        return Item.itemsList[this.itemID].canHarvestBlock( this, world, block, i, j, k );
-    }
-    
-    public float getStrVsBlock( World world, Block par1Block, int i, int j, int k )
-    {
-        return getItem().getStrVsBlock( this, world, par1Block, i, j, k );
-    }
-    
-    public long GetTimeOfLastUse()
-    {
-    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcLastUse" ) ) 
-    	{
-    		return stackTagCompound.getLong( "fcLastUse" );
-    	}
-    	
-        return -1;
-    }
-    
-    public void SetTimeOfLastUse( long lTime )
-    {
-        if ( !hasTagCompound() )
-        {
-            stackTagCompound = new NBTTagCompound( "tag" );
-        }
-
-        stackTagCompound.setLong( "fcLastUse", lTime );
-    }
-    
-    public float GetAccumulatedChance( float fDefault )
-    {
-    	if ( hasTagCompound() && this.stackTagCompound.hasKey( "fcChance" ) ) 
-    	{
-    		return stackTagCompound.getFloat( "fcChance" );
-    	}
-    	
-        return fDefault;
-    }
-    
-    public void SetAccumulatedChance( float fChance )
-    {
-        if ( !hasTagCompound() )
-        {
-            stackTagCompound = new NBTTagCompound( "tag" );
-        }
-
-        stackTagCompound.setFloat( "fcChance", fChance );
-    }
-    // END FCMOD
 }
--- ItemSword.java	Thu Jul  5 11:26:04 2018
+++ ItemSword.java	Fri Apr 20 22:33:13 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 07/05/2018
-
 package net.minecraft.src;
 
 public class ItemSword extends Item
--- ItemTool.java	Mon Mar  5 14:41:55 2018
+++ ItemTool.java	Fri Apr 20 22:33:13 2018
@@ -92,4 +92,4 @@
     {
         return this.toolMaterial.getToolCraftingMaterial() == par2ItemStack.itemID ? true : super.getIsRepairable(par1ItemStack, par2ItemStack);
     }
-}
\ No newline at end of file
+}
--- LongHashMap.java	Tue Oct 23 17:25:24 2018
+++ LongHashMap.java	Fri Apr 20 22:33:14 2018
@@ -3,17 +3,7 @@
 public class LongHashMap
 {
     /** the array of all elements in the hash */
-	// FCMOD: Changed so that it's most common use (loaded chunks) doesn't constantly resize 
-    //private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
-
-	// 882 chunks will typical be loaded SP / 0.75, for 1176, with extra wiggle room
-	// there's only a few of these instantiated in the entire game, at 8K a piece for 2000 elements
-	// so really no need to be stingy.
-	private final int m_iDefaultSize = 2000; 
-    private final float percentUseable = 0.75F;
-	
-    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[m_iDefaultSize];	
-	// END FCMOD
+    private transient LongHashMapEntry[] hashArray = new LongHashMapEntry[16];
 
     /** the number of elements in the hash array */
     private transient int numHashElements;
@@ -21,17 +11,12 @@
     /**
      * the maximum amount of elements in the hash (probably 3/4 the size due to meh hashing function)
      */
-    // FCMOD: Changed
-    //private int capacity = 12;
-    private int capacity = (int)( (float)m_iDefaultSize * percentUseable );
-    // END FCMOD
+    private int capacity = 12;
 
     /**
      * percent of the hasharray that can be used without hash colliding probably
      */
-    // FCMOD: Removed and replaced above due to declaration order    
-    //private final float percentUseable = 0.75F;
-    // END FCMOD
+    private final float percentUseable = 0.75F;
 
     /** count of times elements have been added/removed */
     private transient volatile int modCount;
@@ -41,13 +26,8 @@
      */
     private static int getHashedKey(long par0)
     {
-    	// FCMOD: Changed to avoid excessive collisions between what is just
-    	// XORing the X and Z values that comprise the key for chunk coords
-    	// discussion of this can be found here: https://bugs.mojang.com/browse/MC-12964
-        //return hash((int)(par0 ^ par0 >>> 32));
-        return hash( (int)( par0 ^ ( ( par0 >>> 32 ) * 31 ) ) );
-        // END FCMOD
-}
+        return hash((int)(par0 ^ par0 >>> 32));
+    }
 
     /**
      * the hash function
--- MapData.java	Fri Jun 14 13:59:12 2013
+++ MapData.java	Fri Apr 20 22:33:14 2018
@@ -105,29 +105,6 @@
      */
     public void updateVisiblePlayers(EntityPlayer par1EntityPlayer, ItemStack par2ItemStack)
     {
-    	// FCMOD: Added to handle maps in frames entirely independent of player held
-    	
-    	// clear the visible players every update to prevent players from receiving data about others
-    	
-        playersVisibleOnMap.clear();
-        
-        if ( par2ItemStack.isOnItemFrame() )
-        {
-        	if ( IsEntityLocationVisibleOnMap( par2ItemStack.getItemFrame() ) )
-        	{
-        		// the following code adds the "you are here" marker
-        		
-                func_82567_a( 1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, 
-                	(double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, 
-                	(double)(par2ItemStack.getItemFrame().hangingDirection * 90 + 180 ));
-                
-        		return;
-        	}
-            
-            return;
-        }
-    	// END FCMOD
-    	
         if (!this.playersHashMap.containsKey(par1EntityPlayer))
         {
             MapInfo var3 = new MapInfo(this, par1EntityPlayer);
@@ -135,16 +112,6 @@
             this.playersArrayList.add(var3);
         }
 
-        // FCMOD: Code added for custom handling of players on map, only processing the player holding it
-        if ( !par1EntityPlayer.isDead && par1EntityPlayer.inventory.hasItemStack(par2ItemStack) && IsEntityLocationVisibleOnMap( par1EntityPlayer ) &&
-        	par1EntityPlayer.dimension == dimension )
-        {
-            func_82567_a( 0, par1EntityPlayer.worldObj, par1EntityPlayer.getCommandSenderName(), par1EntityPlayer.posX, par1EntityPlayer.posZ, par1EntityPlayer.rotationYaw);
-        }
-    	// END FCMOD
-        
-        // FCMOD: Code removed
-        /*
         if (!par1EntityPlayer.inventory.hasItemStack(par2ItemStack))
         {
             this.playersVisibleOnMap.remove(par1EntityPlayer.getCommandSenderName());
@@ -172,8 +139,6 @@
         {
             this.func_82567_a(1, par1EntityPlayer.worldObj, "frame-" + par2ItemStack.getItemFrame().entityId, (double)par2ItemStack.getItemFrame().xPosition, (double)par2ItemStack.getItemFrame().zPosition, (double)(par2ItemStack.getItemFrame().hangingDirection * 90));
         }
-        */
-        // END FCMOD
     }
 
     private void func_82567_a(int par1, World par2World, String par3Str, double par4, double par6, double par8)
@@ -278,50 +243,4 @@
 
         return var2;
     }
-    
-    // FCMOD: Code added
-    public boolean IsEntityLocationVisibleOnMap( Entity entity )
-    {
-        int i = MathHelper.floor_double( entity.posX );
-        int j = MathHelper.floor_double( entity.posY ) + 2;
-        int k = MathHelper.floor_double( entity.posZ );
-        
-        if ( entity.dimension == dimension )
-        {
-        	return IsLocationVisibleOnMap( entity.worldObj, i, j, k );
-        }
-        
-        return false;        
-    }
-    
-    public boolean IsLocationVisibleOnMap( World world, int i, int j, int k )    
-    {
-    	// check if location is within map bounds
-    	
-        int iMapScale = 1 << this.scale;
-        float fRelativeI = (float)((double)i - (double)this.xCenter) / (float)iMapScale;
-        float fRelativeK = (float)((double)k - (double)this.zCenter) / (float)iMapScale;
-        
-        if ( Math.abs( fRelativeI ) > 64F || Math.abs( fRelativeK ) > 64F )
-        {
-        	return false;
-        }
-        
-        // check if location is above ground
-        
-    	if ( !world.canBlockSeeTheSky( i, j, k ) && !( world.getTopSolidOrLiquidBlock( i, k ) <= j )  )
-        {
-        	return false;
-        }
-        
-        Material material = world.getBlockMaterial( i, j, k );
-        
-        if ( material != null && material.isLiquid() )
-        {
-        	return false;
-        }
-        
-    	return true;
-    }
-    // END FCMOD
 }
--- MapGenNetherBridge.java	Mon Oct  1 13:26:31 2018
+++ MapGenNetherBridge.java	Fri Apr 20 22:33:14 2018
@@ -1,5 +1,3 @@
-// FCMOD: Class changes deprecated 10/01/2018
-
 package net.minecraft.src;
 
 import java.util.ArrayList;
--- MapGenScatteredFeature.java	Mon Aug 26 12:46:57 2013
+++ MapGenScatteredFeature.java	Fri Apr 20 22:33:14 2018
@@ -26,11 +26,7 @@
         this.scatteredFeatureSpawnList = new ArrayList();
         this.maxDistanceBetweenScatteredFeatures = 32;
         this.minDistanceBetweenScatteredFeatures = 8;
-        // FCMOD: Code removed
-        /*
         this.scatteredFeatureSpawnList.add(new SpawnListEntry(EntityWitch.class, 1, 1, 1));
-        */
-        // END FCMOD
     }
 
     public MapGenScatteredFeature(Map par1Map)
--- Material.java	Wed Dec 19 14:19:44 2018
+++ Material.java	Fri Apr 20 22:33:14 2018
@@ -5,68 +5,36 @@
     public static final Material air = new MaterialTransparent(MapColor.airColor);
 
     /** The material used by BlockGrass. */
-    // FCMOD: Changed
-    //public static final Material grass = new Material(MapColor.grassColor);
-    //public static final Material ground = new Material(MapColor.dirtColor);
-    //public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
-    public static final Material grass = (new Material(MapColor.grassColor)).setRequiresTool();
-    public static final Material ground = (new Material(MapColor.dirtColor)).setRequiresTool();
-    public static final Material wood = (new Material(MapColor.woodColor)).setBurning().SetMobsCantSpawnOn().SetAxesEfficientOn();
-    // END FCMOD
+    public static final Material grass = new Material(MapColor.grassColor);
+    public static final Material ground = new Material(MapColor.dirtColor);
+    public static final Material wood = (new Material(MapColor.woodColor)).setBurning();
     public static final Material rock = (new Material(MapColor.stoneColor)).setRequiresTool();
-    // FCMOD: Changed
-    //public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
-    //public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
     public static final Material iron = (new Material(MapColor.ironColor)).setRequiresTool();
     public static final Material anvil = (new Material(MapColor.ironColor)).setRequiresTool().setImmovableMobility();
-    // END FCMOD
     public static final Material water = (new MaterialLiquid(MapColor.waterColor)).setNoPushMobility();
     public static final Material lava = (new MaterialLiquid(MapColor.tntColor)).setNoPushMobility();
-    // FCMOD: Changed
-    //public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
-    //public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
-    //public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
-    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
-    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn().SetAxesTreatAsVegetation();
-    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable().SetAxesEfficientOn().SetAxesTreatAsVegetation();
-    // END FCMOD
+    public static final Material leaves = (new Material(MapColor.foliageColor)).setBurning().setTranslucent().setNoPushMobility();
+    public static final Material plants = (new MaterialLogic(MapColor.foliageColor)).setNoPushMobility();
+    public static final Material vine = (new MaterialLogic(MapColor.foliageColor)).setBurning().setNoPushMobility().setReplaceable();
     public static final Material sponge = new Material(MapColor.clothColor);
-    // FCMOD: Changed
-    //public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
-    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning().SetAxesEfficientOn();
-    // END FCMOD
+    public static final Material cloth = (new Material(MapColor.clothColor)).setBurning();
     public static final Material fire = (new MaterialTransparent(MapColor.airColor)).setNoPushMobility();
-    // FCMOD: Changed
-    //public static final Material sand = new Material(MapColor.sandColor);
-    public static final Material sand = (new Material(MapColor.sandColor)).setRequiresTool();
-    // END FCMOD
+    public static final Material sand = new Material(MapColor.sandColor);
     public static final Material circuits = (new MaterialLogic(MapColor.airColor)).setNoPushMobility();
-    // FCMOD: Changed
-    //public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
     public static final Material glass = (new Material(MapColor.airColor)).setTranslucent().setAlwaysHarvested();
-    // END FCMOD
     public static final Material redstoneLight = (new Material(MapColor.airColor)).setAlwaysHarvested();
-    // FCMOD: Changed
-    //public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
     public static final Material tnt = (new Material(MapColor.tntColor)).setBurning().setTranslucent();
-    // END FCMOD
     public static final Material coral = (new Material(MapColor.foliageColor)).setNoPushMobility();
     public static final Material ice = (new Material(MapColor.iceColor)).setTranslucent().setAlwaysHarvested();
     public static final Material snow = (new MaterialLogic(MapColor.snowColor)).setReplaceable().setTranslucent().setRequiresTool().setNoPushMobility();
 
     /** The material for crafted snow. */
     public static final Material craftedSnow = (new Material(MapColor.snowColor)).setRequiresTool();
-    // FCMOD: Changed
-    //public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
-    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility().SetMobsCantSpawnOn();    
-    // END FCMOD
+    public static final Material cactus = (new Material(MapColor.foliageColor)).setTranslucent().setNoPushMobility();
     public static final Material clay = new Material(MapColor.clayColor);
 
     /** pumpkin */
-    // FCMOD: Changed
-    //public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
-    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility().SetAxesEfficientOn();
-    // END FCMOD
+    public static final Material pumpkin = (new Material(MapColor.foliageColor)).setNoPushMobility();
     public static final Material dragonEgg = (new Material(MapColor.foliageColor)).setNoPushMobility();
 
     /** Material used for portals */
@@ -145,10 +113,7 @@
     /**
      * Marks the material as translucent
      */
-    // FCMOD: Changed
-    //private Material setTranslucent()
-    protected Material setTranslucent()
-    // END FCMOD
+    private Material setTranslucent()
     {
         this.isTranslucent = true;
         return this;
@@ -256,63 +221,4 @@
     {
         return this.field_85159_M;
     }
-    
-    // FCMOD: Added New
-    private boolean m_bMobsCanSpawnOn = true;
-    private boolean m_bNetherMobsCanSpawnOn = false;
-    private boolean m_bAxesEfficientOn = false;
-    private boolean m_bAxesTreatAsVegetation = false;
-    
-    public boolean GetMobsCanSpawnOn( int iDimension )
-    {
-    	if ( iDimension == -1 )
-    	{
-    		return m_bNetherMobsCanSpawnOn;
-    	}
-    	
-    	return m_bMobsCanSpawnOn;
-    }
-    
-    public Material SetMobsCantSpawnOn()
-    {
-    	m_bMobsCanSpawnOn = false;
-    	
-    	return this;
-    }
-    
-    public Material SetNetherMobsCanSpawnOn()
-    {
-    	m_bNetherMobsCanSpawnOn = true;
-    	
-    	return this;
-    }
-    
-    public boolean GetAxesEfficientOn()
-    {
-    	return m_bAxesEfficientOn;
-    }
-    
-    public Material SetAxesEfficientOn()
-    {
-    	m_bAxesEfficientOn = true;
-    	
-    	return this;
-    }
-    
-    /**
-     * If true, this material doesn't damage axes or consume hunger if the 
-     * harvesting axe is of sufficient quality 
-     */
-    public boolean GetAxesTreatAsVegetation()
-    {
-    	return m_bAxesTreatAsVegetation;    	
-    }
-    
-    public Material SetAxesTreatAsVegetation()
-    {
-    	m_bAxesTreatAsVegetation = true;
-    	
-    	return this;
-    }
-    // END FCMOD
 }
--- MerchantRecipe.java	Thu May  8 16:46:43 2014
+++ MerchantRecipe.java	Fri Apr 20 22:33:14 2018
@@ -30,15 +30,6 @@
         this.secondItemToBuy = par2ItemStack;
         this.itemToSell = par3ItemStack;
         this.maxTradeUses = 7;
-        // FCMOD: Change
-        /*
-        this.maxTradeUses = 7;
-        */
-        maxTradeUses = 1;
-        // END FCMOD
-        
-        // FCMOD: Added
-        // END FCMOD
     }
 
     public MerchantRecipe(ItemStack par1ItemStack, ItemStack par2ItemStack)
@@ -137,24 +128,8 @@
         }
         else
         {
-            // FCMOD: Change
-            /*
             this.maxTradeUses = 7;
-            */
-        	maxTradeUses = 1;
-        	// END FCMOD
         }
-        
-        // FCMOD: Added
-        if ( par1NBTTagCompound.hasKey( "fcTradeLevel" ) )
-        {
-            m_iTradeLevel = par1NBTTagCompound.getInteger("fcTradeLevel");
-        }
-        else
-        {
-        	m_iTradeLevel = 1;
-        }
-        // END FCMOD
     }
 
     public NBTTagCompound writeToTags()
@@ -170,32 +145,6 @@
 
         var1.setInteger("uses", this.toolUses);
         var1.setInteger("maxUses", this.maxTradeUses);
-        
-        // FCMOD: Added
-        var1.setInteger( "fcTradeLevel", m_iTradeLevel );
-        // END FCMOD
-        
         return var1;
     }
-    
-    // FCMOD: Added
-    public int m_iTradeLevel;    
-    
-    public MerchantRecipe( ItemStack inputStack1, ItemStack inputStack2, ItemStack outputStack, int iTradeLevel )
-    {
-        this( inputStack1, inputStack2, outputStack );
-        
-        m_iTradeLevel = iTradeLevel;
-    }
-    
-    public MerchantRecipe( ItemStack inputStack, ItemStack outputStack, int iTradeLevel )
-    {
-        this( inputStack, (ItemStack)null, outputStack, iTradeLevel );
-    }
-
-    public MerchantRecipe( ItemStack inputStack, Item outputItem, int iTradeLevel )
-    {
-        this( inputStack, new ItemStack( outputItem ), iTradeLevel );
-    }
-    // END FCMOD
 }
--- MerchantRecipeList.java	Mon Jan  8 14:37:42 2018
+++ MerchantRecipeList.java	Fri Apr 20 22:33:14 2018
@@ -16,8 +16,6 @@
     /**
      * can par1,par2 be used to in crafting recipe par3
      */
-    // FCMOD: Code removed and replaced later
-    /*
     public MerchantRecipe canRecipeBeUsed(ItemStack par1ItemStack, ItemStack par2ItemStack, int par3)
     {
         if (par3 > 0 && par3 < this.size())
@@ -40,8 +38,6 @@
             return null;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * checks if there is a recipie for the same ingredients already on the list, and replaces it. otherwise, adds it
@@ -54,14 +50,10 @@
 
             if (par1MerchantRecipe.hasSameIDsAs(var3))
             {
-            	// FCMOD: Removed to avoid problems with similar items, like skulls or colored candles, replacing each other
-            	/*
                 if (par1MerchantRecipe.hasSameItemsAs(var3))
                 {
                     this.set(var2, par1MerchantRecipe);
                 }
-                */
-            	// END FCMOD
 
                 return;
             }
@@ -88,10 +80,6 @@
             }
 
             par1DataOutputStream.writeBoolean(var3.func_82784_g());
-            
-            // FCMOD: Code added
-            par1DataOutputStream.writeShort( var3.m_iTradeLevel );
-            // END FCMOD
         }
     }
 
@@ -120,77 +108,4 @@
         var1.setTag("Recipes", var2);
         return var1;
     }
-    
-    // FCMOD: Code added
-    public MerchantRecipe canRecipeBeUsed( ItemStack inputStack1, ItemStack inputStack2, int iRecipeIndex )
-    {
-        if ( iRecipeIndex >= 0 && iRecipeIndex < size() )
-        {
-            MerchantRecipe recipe = (MerchantRecipe)get(iRecipeIndex);
-            
-            if (IsStackValidForFirstSlotOfRecipe( inputStack1, recipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, recipe ) )
-            {
-            	return recipe;
-            }
-        }
-        else
-        {
-            for ( int iTempRecipeIndex = 0; iTempRecipeIndex < size(); ++iTempRecipeIndex )
-            {
-                MerchantRecipe tempRecipe = (MerchantRecipe)get( iTempRecipeIndex );
-
-                if (IsStackValidForFirstSlotOfRecipe( inputStack1, tempRecipe ) && IsStackValidForSecondSlotOfRecipe( inputStack2, tempRecipe ) )
-                {
-                	return tempRecipe;
-                }
-            }
-        }
-        
-        return null;
-    }
-    
-    private boolean IsStackValidForFirstSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
-    {
-    	if ( stack.itemID == recipe.getItemToBuy().itemID && stack.stackSize >= recipe.getItemToBuy().stackSize )
-    	{
-    		if ( recipe.getItemToBuy().getHasSubtypes() )
-    		{
-    			return stack.getItemDamage() == recipe.getItemToBuy().getItemDamage(); 
-    		}
-    		else
-    		{
-    			return true;
-    		}
-    	}
-    	
-    	return false;
-    }
-    
-    private boolean IsStackValidForSecondSlotOfRecipe( ItemStack stack, MerchantRecipe recipe )
-    {
-    	if ( recipe.hasSecondItemToBuy() )
-    	{
-    		if ( stack != null )
-    		{
-	        	if ( stack.itemID == recipe.getSecondItemToBuy().itemID && stack.stackSize >= recipe.getSecondItemToBuy().stackSize )
-	        	{
-	        		if ( recipe.getSecondItemToBuy().getHasSubtypes() )
-	        		{
-	        			return stack.getItemDamage() == recipe.getSecondItemToBuy().getItemDamage(); 
-	        		}
-	        		else
-	        		{
-	        			return true;
-	        		}
-	        	}
-    		}
-    	}
-    	else if ( stack == null )
-    	{
-    		return true;
-    	}
-    	
-    	return false;
-    }
-    // END FCMOD
 }
--- MobSpawnerBaseLogic.java	Sun Nov 22 13:59:02 2020
+++ MobSpawnerBaseLogic.java	Fri Apr 20 22:33:14 2018
@@ -118,12 +118,6 @@
                     double var7 = (double)(this.getSpawnerY() + this.getSpawnerWorld().rand.nextInt(3) - 1);
                     double var9 = (double)this.getSpawnerZ() + (this.getSpawnerWorld().rand.nextDouble() - this.getSpawnerWorld().rand.nextDouble()) * (double)this.spawnRange;
                     EntityLiving var11 = var13 instanceof EntityLiving ? (EntityLiving)var13 : null;
-                    // FCMOD: Added
-                    if ( var11 != null )
-                    {
-                    	var11.PreInitCreature();
-                    }
-                    // END FCMOD
                     var13.setLocationAndAngles(var5, var7, var9, this.getSpawnerWorld().rand.nextFloat() * 360.0F, 0.0F);
 
                     if (var11 == null || var11.getCanSpawnHere())
@@ -199,12 +193,7 @@
         }
         else if (par1Entity instanceof EntityLiving && par1Entity.worldObj != null)
         {
-        	// FCMOD: Code change to prevent mobs spawning with armor and weapons
-        	/*
             ((EntityLiving)par1Entity).initCreature();
-            */
-            ((EntityLiving)par1Entity).SpawnerInitCreature();
-        	// END FCMOD
             this.getSpawnerWorld().spawnEntityInWorld(par1Entity);
         }
 
--- NetHandler.java	Fri May 25 20:22:50 2018
+++ NetHandler.java	Fri Apr 20 22:33:14 2018
@@ -458,11 +458,4 @@
     {
         this.unexpectedPacket(par1Packet63WorldParticles);
     }
-    
-    // FCMOD: Added
-    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
-    {
-        unexpectedPacket( packet );
-    }
-    // END FCMOD
 }
--- NetServerHandler.java	Thu May 14 15:42:06 2020
+++ NetServerHandler.java	Fri Apr 20 22:33:14 2018
@@ -8,20 +8,13 @@
 import java.util.Random;
 import net.minecraft.server.MinecraftServer;
 
-// FCMOD: Added
-import java.util.List;
-// END FCMOD
-
 public class NetServerHandler extends NetHandler
 {
     /** The underlying network manager for this server handler. */
     public final INetworkManager netManager;
 
     /** Reference to the MinecraftServer object. */
-    // FCMOD: Changed to public for simplicity with add-on authors
-    //private final MinecraftServer mcServer;
-    public final MinecraftServer mcServer;
-    // END FCMOD
+    private final MinecraftServer mcServer;
 
     /** This is set to true whenever a player disconnects from the server. */
     public boolean connectionClosed = false;
@@ -271,22 +264,11 @@
                 }
 
                 float var27 = 0.0625F;
-	            // FCMOD: Line changed so that players don't warp through platforms
-	            /*
                 boolean var28 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
-	            */
-	            boolean var28 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
-	            // END FCMOD
 
                 if (this.playerEntity.onGround && !par1Packet10Flying.onGround && var15 > 0.0D)
                 {
-                	// FCMOD: Changed to take sprinting into account when jumping on server
-                    //this.playerEntity.addExhaustion(0.2F);
-                	if ( !playerEntity.isOnLadder() )
-                	{
-                		playerEntity.AddExhaustionForJump();
-                	}
-                    // END FCMOD
+                    this.playerEntity.addExhaustion(0.2F);
                 }
 
                 this.playerEntity.moveEntity(var13, var15, var17);
@@ -312,12 +294,7 @@
                 }
 
                 this.playerEntity.setPositionAndRotation(var5, var7, var9, var11, var12);
-	            // FCMOD: Line changed so that players don't warp through platforms
-	            /*
                 boolean var32 = var2.getCollidingBoundingBoxes(this.playerEntity, this.playerEntity.boundingBox.copy().contract((double)var27, (double)var27, (double)var27)).isEmpty();
-	            */
-	            boolean var32 = getCollidingBoundingBoxesIgnoreSpecifiedEntities( var2, playerEntity, playerEntity.boundingBox.copy().contract(var27, var27, var27)).isEmpty();
-	            // END FCMOD
 
                 if (var28 && (var31 || !var32) && !this.playerEntity.isPlayerSleeping())
                 {
@@ -327,13 +304,7 @@
 
                 AxisAlignedBB var33 = this.playerEntity.boundingBox.copy().expand((double)var27, (double)var27, (double)var27).addCoord(0.0D, -0.55D, 0.0D);
 
-                // FCMOD: Line change to prevent player being kicked while standing on entities like Wind Mills or Platforms
-                /*
                 if (!this.mcServer.isFlightAllowed() && !this.playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33))
-                */
-                if (!mcServer.isFlightAllowed() && !playerEntity.theItemInWorldManager.isCreative() && !var2.checkBlockCollision(var33) && 
-            		var2.checkNoEntityCollision( var33, playerEntity ) )
-            	// END FCMOD
                 {
                     if (var29 >= -0.03125D)
                     {
@@ -442,10 +413,7 @@
             }
             else if (par1Packet14BlockDig.status == 2)
             {
-            	// FCMOD: Changed (function name differs between client and server )
-                //this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6);
-                this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6, par1Packet14BlockDig.face);
-                // END FCMOD
+                this.playerEntity.theItemInWorldManager.blockRemoving(var4, var5, var6);
 
                 if (var2.getBlockId(var4, var5, var6) != 0)
                 {
@@ -755,16 +723,6 @@
                 var5 = 9.0D;
             }
 
-        	// FCMOD: Code added to prevent funkiness in interacting with Wind Mills due to size            	
-        	if ( var3 instanceof FCIEntityPacketHandler )
-        	{
-        		if ( ((FCIEntityPacketHandler)var3).ShouldServerTreatAsOversized() )
-        		{
-	        		var4 = true;
-	        		var5 = 256D;
-        		}
-        	}
-        	// END FCMOD
             if (this.playerEntity.getDistanceSqToEntity(var3) < var5)
             {
                 if (par1Packet7UseEntity.isLeftClick == 0)
@@ -847,32 +805,6 @@
                 this.playerEntity.openContainer.detectAndSendChanges();
                 this.playerEntity.updateHeldItem();
                 this.playerEntity.isChangingQuantityOnly = false;
-                // FCMOD: Added fix for items falling out of sync when player uses numerical hotkeys to swap items to the hotbar
-                // by mousing over in inventory (this is what the 2 indicates)
-                if ( par1Packet102WindowClick.holdingShift == 2 ) 
-                {
-                	int iSlotTo = par1Packet102WindowClick.mouseClick;
-
-                	if ( iSlotTo >= 0 && iSlotTo < 9 )
-                	{
-	                	int iSlotFrom = par1Packet102WindowClick.inventorySlot;
-	                	
-	                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotFrom, 
-	                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotFrom ) );
-
-	                	// The following assumes the player's hotbar occupies the last 9 slots of all containers, but should be
-	                	// harmless if not, as it'll just refresh some other slot.
-	                	
-                		iSlotTo += playerEntity.openContainer.inventorySlots.size() - 9;
-                		
-                		if ( iSlotTo >= 0 && iSlotTo < playerEntity.openContainer.inventorySlots.size() )
-                		{
-		                	playerEntity.sendSlotContents( playerEntity.openContainer, iSlotTo,
-		                		(ItemStack)playerEntity.openContainer.inventoryItemStacks.get( iSlotTo ) );
-                		}
-                	}
-                }
-                // END FCMOD
             }
             else
             {
@@ -1061,24 +993,6 @@
     public void handleClientInfo(Packet204ClientInfo par1Packet204ClientInfo)
     {
         this.playerEntity.updateClientInfo(par1Packet204ClientInfo);
-        
-        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
-        if ( !par1Packet204ClientInfo.IsBTWInstalled() )
-        {
-        	playerEntity.playerNetServerHandler.sendPacket( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
-	    		append("WARNING: You do not currently have Better Than Wolves installed on your system." ).toString() ) );
-            	
-	    	playerEntity.playerNetServerHandler.sendPacket( new Packet3Chat( (new StringBuilder()).append( "\2474"). // red text
-	    		append( "This server requires all clients to have Better Than Wolves version ").
-	    		append( FCBetterThanWolves.fcVersionString).toString() ) );
-                	
-			// client
-	    	//mcServer.getLogAgent().logInfo( (new StringBuilder()).
-    		// server
-	    	mcServer.getLogAgent().func_98233_a( (new StringBuilder()).	    		
-	    		append( playerEntity.username ).append( " logged in without BTW installed" ).toString() );
-        }
-        // END FCMOD
     }
 
     public void handleCustomPayload(Packet250CustomPayload par1Packet250CustomPayload)
@@ -1243,127 +1157,7 @@
                         var13.updateItemName("");
                     }
                 }
-                // FCMOD: Added
-                else
-                {
-                	FCAddOnHandler.ServerCustomPacketReceived( this, par1Packet250CustomPayload );
-                }
-                // END FCMOD
             }
         }
     }
-
-	// FCMOD: Added
-	public List getCollidingBoundingBoxesIgnoreSpecifiedEntities( World world, Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
-	{
-		// Copied over from World.java with modifications 
-
-	    ArrayList collidingBoundingBoxes = new ArrayList();
-	    
-	    int i = MathHelper.floor_double(par2AxisAlignedBB.minX);
-	    int j = MathHelper.floor_double(par2AxisAlignedBB.maxX + 1.0D);
-	    int k = MathHelper.floor_double(par2AxisAlignedBB.minY);
-	    int l = MathHelper.floor_double(par2AxisAlignedBB.maxY + 1.0D);
-	    int i1 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
-	    int j1 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
-	
-	    for (int k1 = i; k1 < j; k1++)
-	    {
-	        for (int l1 = i1; l1 < j1; l1++)
-	        {
-	            if (!world.blockExists(k1, 64, l1))
-	            {
-	                continue;
-	            }
-	
-	            for (int i2 = k - 1; i2 < l; i2++)
-	            {
-	                Block block = Block.blocksList[world.getBlockId(k1, i2, l1)];
-	
-	                if (block != null)
-	                {
-	                    block.addCollisionBoxesToList(world, k1, i2, l1, par2AxisAlignedBB, collidingBoundingBoxes, par1Entity);
-	                }
-	            }
-	        }
-	    }
-	
-	    double d = 0.25D;
-	    // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
-		/*
-	    List list = getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, d, d));
-		*/
-	    List list = world.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d, 2.0, d));
-	    // END FCMOD
-	    Iterator iterator = list.iterator();
-	
-	    do
-	    {
-	        if (!iterator.hasNext())
-	        {
-	            break;
-	        }
-	
-	        Entity entity = (Entity)iterator.next();
-	        
-	        if ( !( entity instanceof FCIEntityIgnoreServerValidation ) )
-			{
-	            AxisAlignedBB axisalignedbb = entity.getBoundingBox();
-	
-	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
-	            {
-	                collidingBoundingBoxes.add(axisalignedbb);
-	            }
-	
-	            axisalignedbb = par1Entity.getCollisionBox(entity);
-	
-	            if (axisalignedbb != null && axisalignedbb.intersectsWith(par2AxisAlignedBB))
-	            {
-	                collidingBoundingBoxes.add(axisalignedbb);
-	            }
-			}
-	    }
-	    while (true);
-	
-	    return collidingBoundingBoxes;
-	}
-	
-    public void HandleStartBlockHarvest( FCPacket166StartBlockHarvest packet )
-    {
-        WorldServer world = mcServer.worldServerForDimension( playerEntity.dimension );
-
-        int i = packet.iIPos;
-        int j = packet.iJPos;
-        int k = packet.iKPos;
-
-        double dDeltaX = playerEntity.posX - ( (double)i + 0.5D );
-        double dDeltaY = playerEntity.posY - ( (double)j + 0.5D ) + 1.5D;
-        double dDeltaZ = playerEntity.posZ - ( (double)k + 0.5D );
-        
-        double dDistSq = dDeltaX * dDeltaX + dDeltaY * dDeltaY + dDeltaZ * dDeltaZ;
-
-        if ( dDistSq <= 36D && j < mcServer.getBuildLimit() )
-        {
-	        if ( !IsBlockWithinSpawnProtection( world, i, j, k ) )
-	        {
-	        	playerEntity.SetMiningSpeedModifier( packet.GetMiningSpeedModifier() );
-	        	
-	            playerEntity.theItemInWorldManager.onBlockClicked(i, j, k, packet.iFace );
-	        }
-	        else
-	        {
-	        	// I assume the following resets the block harvest on the player's client
-
-	        	FCUtilsWorld.SendPacketToPlayer( playerEntity.playerNetServerHandler, new Packet53BlockChange( i, j, k, world ) );
-	        }
-        }
-    }
-    
-    private boolean IsBlockWithinSpawnProtection( World world, int i, int j, int k )
-    {
-    	// func_96290_a checks if the block is within the spawn protection area on dedicated servers
-    	
-    	return mcServer.func_96290_a( world, i, j, k, playerEntity );
-    }
-	// END FCMOD
 }
--- Packet15Place.java	Fri Jun 14 14:02:25 2013
+++ Packet15Place.java	Fri Apr 20 22:33:14 2018
@@ -33,16 +33,9 @@
         this.zPosition = par1DataInputStream.readInt();
         this.direction = par1DataInputStream.read();
         this.itemStack = readItemStack(par1DataInputStream);
-        // FCMOD: Code change to fix rounding errors
-        /*
         this.xOffset = (float)par1DataInputStream.read() / 16.0F;
         this.yOffset = (float)par1DataInputStream.read() / 16.0F;
         this.zOffset = (float)par1DataInputStream.read() / 16.0F;
-        */
-        this.xOffset = (float)par1DataInputStream.readShort() / 32000F;
-        this.yOffset = (float)par1DataInputStream.readShort() / 32000F;
-        this.zOffset = (float)par1DataInputStream.readShort() / 32000F;
-        // END FCMOD
     }
 
     /**
@@ -55,16 +48,9 @@
         par1DataOutputStream.writeInt(this.zPosition);
         par1DataOutputStream.write(this.direction);
         writeItemStack(this.itemStack, par1DataOutputStream);
-        // FCMOD: Code change to fix rounding errors
-        /*
         par1DataOutputStream.write((int)(this.xOffset * 16.0F));
         par1DataOutputStream.write((int)(this.yOffset * 16.0F));
         par1DataOutputStream.write((int)(this.zOffset * 16.0F));
-        */
-        par1DataOutputStream.writeShort((int)(this.xOffset * 32000F + 0.5F));
-        par1DataOutputStream.writeShort((int)(this.yOffset * 32000F + 0.5F));
-        par1DataOutputStream.writeShort((int)(this.zOffset * 32000F + 0.5F));
-        // END FCMOD        
     }
 
     /**
@@ -80,12 +66,7 @@
      */
     public int getPacketSize()
     {
-    	// FCMOD: Code change
-    	/*
         return 19;
-        */
-        return 22;
-        // END FCMOD
     }
 
     public int getXPosition()
--- Packet204ClientInfo.java	Fri Jun 14 14:03:00 2013
+++ Packet204ClientInfo.java	Fri Apr 20 22:33:14 2018
@@ -77,12 +77,6 @@
 
     public int getDifficulty()
     {
-        // FCMOD: Code added to encode whether BTW is installed in the game difficulty
-    	if ( gameDifficulty >= 10 )
-    	{
-    		return gameDifficulty - 10;
-    	}
-    	// END FCMOD
         return this.gameDifficulty;
     }
 
@@ -107,11 +101,4 @@
     {
         return true;
     }
-    
-    // FCMOD: Function added to encode whether BTW is installed in the game difficulty
-    public boolean IsBTWInstalled()
-    {
-    	return gameDifficulty >= 10;
-    }
-    // END FCMOD
 }
--- Packet24MobSpawn.java	Fri Jun 14 14:03:20 2013
+++ Packet24MobSpawn.java	Fri Apr 20 22:33:14 2018
@@ -43,12 +43,7 @@
     public Packet24MobSpawn(EntityLiving par1EntityLiving)
     {
         this.entityId = par1EntityLiving.entityId;
-        // FCMOD: Code change to avoid truncation
-        /*
         this.type = (byte)EntityList.getEntityID(par1EntityLiving);
-        */
-        this.type = EntityList.getEntityID(par1EntityLiving);
-        // END FCMOD
         this.xPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posX);
         this.yPosition = MathHelper.floor_double(par1EntityLiving.posY * 32.0D);
         this.zPosition = par1EntityLiving.myEntitySize.multiplyBy32AndRound(par1EntityLiving.posZ);
@@ -148,15 +143,5 @@
     public int getPacketSize()
     {
         return 26;
-    }
-
-    public List getMetadata()
-    {
-        if (this.metadata == null)
-        {
-            this.metadata = this.metaData.getAllWatched();
-        }
-
-        return this.metadata;
     }
 }
--- Packet26EntityExpOrb.java	Fri Jun 14 14:03:30 2013
+++ Packet26EntityExpOrb.java	Fri Apr 20 22:33:14 2018
@@ -6,10 +6,6 @@
 
 public class Packet26EntityExpOrb extends Packet
 {
-    // FCMOD: Code added
-    public boolean m_bNotPlayerOwned;
-    // END FCMOD
-
     /** Entity ID for the XP Orb */
     public int entityId;
     public int posX;
@@ -28,9 +24,6 @@
         this.posY = MathHelper.floor_double(par1EntityXPOrb.posY * 32.0D);
         this.posZ = MathHelper.floor_double(par1EntityXPOrb.posZ * 32.0D);
         this.xpValue = par1EntityXPOrb.getXpValue();
-        // FCMOD: Code added
-        m_bNotPlayerOwned = par1EntityXPOrb.m_bNotPlayerOwned;
-        // END FCMOD
     }
 
     /**
@@ -43,9 +36,6 @@
         this.posY = par1DataInputStream.readInt();
         this.posZ = par1DataInputStream.readInt();
         this.xpValue = par1DataInputStream.readShort();
-        // FCMOD: Code added
-        m_bNotPlayerOwned = par1DataInputStream.readBoolean();
-        // END FCMOD
     }
 
     /**
@@ -58,9 +48,6 @@
         par1DataOutputStream.writeInt(this.posY);
         par1DataOutputStream.writeInt(this.posZ);
         par1DataOutputStream.writeShort(this.xpValue);
-        // FCMOD: Code added
-        par1DataOutputStream.writeBoolean( m_bNotPlayerOwned );
-        // END FCMOD
     }
 
     /**
@@ -76,11 +63,6 @@
      */
     public int getPacketSize()
     {
-    	// FCMOD: Code changed
-    	/*
         return 18;
-        */
-        return 19;
-        // END FCMOD
     }
 }
--- Packet41EntityEffect.java	Fri Jun 14 14:03:48 2013
+++ Packet41EntityEffect.java	Fri Apr 20 22:33:14 2018
@@ -12,9 +12,6 @@
     /** The effect's amplifier. */
     public byte effectAmplifier;
     public short duration;
-    // FCMOD: Code added
-    public byte m_bIsAmbient;
-    // END FCMOD
 
     public Packet41EntityEffect() {}
 
@@ -32,14 +29,6 @@
         {
             this.duration = (short)par2PotionEffect.getDuration();
         }
-
-        // FCMOD: Code added
-        m_bIsAmbient = 0;
-        if ( par2PotionEffect.getIsAmbient() )
-        {
-        	m_bIsAmbient = 1;
-        }
-        // END FCMOD
     }
 
     /**
@@ -51,9 +40,6 @@
         this.effectId = par1DataInputStream.readByte();
         this.effectAmplifier = par1DataInputStream.readByte();
         this.duration = par1DataInputStream.readShort();
-        // FCMOD: Code added
-        m_bIsAmbient = par1DataInputStream.readByte();
-        // END FCMOD
     }
 
     /**
@@ -65,9 +51,6 @@
         par1DataOutputStream.writeByte(this.effectId);
         par1DataOutputStream.writeByte(this.effectAmplifier);
         par1DataOutputStream.writeShort(this.duration);
-        // FCMOD: Code added
-        par1DataOutputStream.writeByte(m_bIsAmbient);
-        // END FCMOD
     }
 
     /**
@@ -83,12 +66,7 @@
      */
     public int getPacketSize()
     {
-    	// FCMOD: Code change
-    	/*
         return 8;
-        */
-    	return 9;
-    	// END FCMOD
     }
 
     /**
--- PathFinder.java	Thu Jan 10 13:18:32 2019
+++ PathFinder.java	Fri Apr 20 22:33:15 2018
@@ -54,8 +54,6 @@
     /**
      * Internal implementation of creating a path from an entity to a point
      */
-    // FCMOD: Removed and replaced
-    /*
     private PathEntity createEntityPathTo(Entity par1Entity, double par2, double par4, double par6, float par8)
     {
         this.path.clearPath();
@@ -87,8 +85,6 @@
         this.isPathingInWater = var9;
         return var14;
     }
-    */
-    // END FCMOD
 
     /**
      * Adds a path from start to end and returns the whole path (args: unused, start, end, unused, maxDistance)
@@ -284,17 +280,11 @@
      */
     public int getVerticalOffset(Entity par1Entity, int par2, int par3, int par4, PathPoint par5PathPoint)
     {
-    	// FCMOD: Code changed to call custom function
-    	/*
         return func_82565_a(par1Entity, par2, par3, par4, par5PathPoint, this.isPathingInWater, this.isMovementBlockAllowed, this.isWoddenDoorAllowed);
-        */
-    	return GetPathWeightAtLocation( par1Entity, par2, par3, par4, par5PathPoint );
-    	// END FCMOD
     }
 
     public static int func_82565_a(Entity par0Entity, int par1, int par2, int par3, PathPoint par4PathPoint, boolean par5, boolean par6, boolean par7)
     {
-    	// FCNOTE: *Mostly* dead code.  The mod prevents it being called above, but it's still called from EntityAIControlledByPlayer 
         boolean var8 = false;
 
         for (int var9 = par1; var9 < par1 + par4PathPoint.xCoord; ++var9)
@@ -313,10 +303,7 @@
                         }
                         else if (var12 != Block.waterMoving.blockID && var12 != Block.waterStill.blockID)
                         {
-                        	// FCMOD: Changed
-                            //if (!par7 && var12 == Block.doorWood.blockID)
-                            if (!par7 && ( var12 == Block.doorWood.blockID || var12 == FCBetterThanWolves.fcBlockDoorWood.blockID ) )
-                        	// END FCMOD
+                            if (!par7 && var12 == Block.doorWood.blockID)
                             {
                                 return 0;
                             }
@@ -334,7 +321,6 @@
                         Block var13 = Block.blocksList[var12];
                         int var14 = var13.getRenderType();
 
-                        // FCNOTE: 9 is the render type of BlockRailBase
                         if (par0Entity.worldObj.blockGetRenderType(var9, var10, var11) == 9)
                         {
                             int var18 = MathHelper.floor_double(par0Entity.posX);
@@ -348,7 +334,6 @@
                         }
                         else if (!var13.getBlocksMovement(par0Entity.worldObj, var9, var10, var11) && (!par6 || var12 != Block.doorWood.blockID))
                         {
-                        	// FCNOTE: 11 is the render type of BlockFence, 32 is that of BlockWall
                             if (var14 == 11 || var12 == Block.fenceGate.blockID || var14 == 32)
                             {
                                 return -3;
@@ -404,175 +389,4 @@
 
         return new PathEntity(var5);
     }
-    
-    // FCMOD: Added New
-    public int GetPathWeightAtLocation( Entity entity, int i, int j, int k, PathPoint pathPoint )
-    {
-    	boolean bAvoidsWater = isPathingInWater;
-    	boolean bPathThroughClosedWoodDoor = isMovementBlockAllowed;
-    	boolean bPathThroughOpenWoodDoor = isWoddenDoorAllowed;
-    	
-    	// this is pathfinding's inner loop, and has been rewritten to optimize
-    	
-    	World world = entity.worldObj;
-        int iReturnWeight = 1;
-        
-        int iMaxI = i + pathPoint.xCoord;
-        int iMaxJ = j + pathPoint.yCoord;
-        int iMaxK = k + pathPoint.zCoord;
-
-        for ( int iTempI = i; iTempI < iMaxI; ++iTempI )
-        {
-            for ( int iTempJ = j; iTempJ < iMaxJ; ++iTempJ )
-            {
-                for ( int iTempK = k; iTempK < iMaxK; ++iTempK )
-                {
-                    int iTempBlockID = world.getBlockId( iTempI, iTempJ, iTempK );
-
-                    if ( iTempBlockID > 0 )
-                    {
-                        Block tempBlock = Block.blocksList[iTempBlockID];
-
-                        if ( !tempBlock.CanPathThroughBlock( world, iTempI, iTempJ, iTempK, entity, this ) )
-                        {                        	
-                        	return tempBlock.GetWeightOnPathBlocked( world, iTempI, iTempJ, iTempK );
-                        }
-                        else
-                        {
-                        	iReturnWeight = tempBlock.AdjustPathWeightOnNotBlocked( iReturnWeight );
-                        }
-                    }
-                }
-            }
-        }
-
-        return iReturnWeight;
-    }
-    
-    public boolean CanPathThroughClosedWoodDoor()
-    {
-    	return isMovementBlockAllowed;
-    }
-    
-    public boolean CanPathThroughOpenWoodDoor()
-    {
-    	return isWoddenDoorAllowed;
-    }
-    
-    public boolean CanPathThroughWater()
-    {
-    	return !isPathingInWater; // member variable is misnamed
-    }
-    
-    private PathEntity createEntityPathTo( Entity entity, double dDestX, double dDestY, 
-    	double dDestZ, float fTolerance )
-    {
-        path.clearPath();
-        pointMap.clearMap();
-        
-        boolean bTempPathingInWater = isPathingInWater; // not sure what's up with how this is used
-        
-        int iIStart = MathHelper.floor_double( entity.boundingBox.minX );
-        int iJStart = MathHelper.floor_double( entity.boundingBox.minY + 0.5D );        
-        int iKStart = MathHelper.floor_double( entity.boundingBox.minZ );
-        
-        if ( canEntityDrown && entity.isInWater() )
-        {
-            iJStart = (int)entity.boundingBox.minY;
-
-            for ( int iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
-            	iJStart, MathHelper.floor_double( entity.posZ ) ); 
-            	iTempBlockID == Block.waterMoving.blockID || 
-            	iTempBlockID == Block.waterStill.blockID; 
-            	iTempBlockID = worldMap.getBlockId( MathHelper.floor_double( entity.posX ), 
-        		iJStart, MathHelper.floor_double( entity.posZ ) ) )
-            {
-                ++iJStart;
-            }
-
-            bTempPathingInWater = isPathingInWater;
-            
-            isPathingInWater = false;
-        }        
-        else if ( ShouldOffsetPositionIfPathingOutOfBlock( iIStart, iJStart, iKStart, entity ) )
-		{
-    		// smaller entities can get stuck on fence corners and such.  This bit
-        	// offsets the start point for pathing to open neighboring blocks.
-        	// Intentionally uses horizontal center of entity to determine offset.
-
-    		double dPartialX = entity.posX - (double)iIStart;
-    		
-    		int iIOffset = iIStart + ( dPartialX < 0.5 ? -1: 1 );
-
-        	if ( !CanPathThroughBlock( iIOffset, iJStart, iKStart, entity ) )
-    		{
-        		double dPartialZ = entity.posZ - (double)iKStart;	            		
-        		
-        		int iKOffset = iKStart + ( dPartialZ < 0.5 ? -1: 1 );
-        		
-            	if ( !CanPathThroughBlock( iIStart, iJStart, iKOffset, entity ) )
-        		{
-            		if ( CanPathThroughBlock( iIOffset, iJStart, iKOffset, entity ) )
-            		{
-                		iIStart = iIOffset;
-                		iKStart = iKOffset;
-            		}
-        		}
-            	else
-            	{
-            		iKStart = iKOffset;
-            	}
-    		}
-        	else
-        	{
-        		iIStart = iIOffset;
-        	}
-        }
-
-        PathPoint startPoint = openPoint( iIStart, iJStart, iKStart ); 
-        
-        PathPoint endPoint = openPoint( 
-        	MathHelper.floor_double( dDestX - ( entity.width / 2F ) ), 
-        	MathHelper.floor_double( dDestY ), 
-        	MathHelper.floor_double( dDestZ - ( entity.width / 2F ) ) );
-        
-        PathPoint spaceNeeded = new PathPoint( MathHelper.floor_float( entity.width + 1F ), 
-        	MathHelper.floor_float( entity.height + 1F ), 
-        	MathHelper.floor_float( entity.width + 1F ) );
-        
-        PathEntity path = addToPath( entity, startPoint, endPoint, spaceNeeded, fTolerance );
-        
-        isPathingInWater = bTempPathingInWater;
-        
-        return path;
-    }
-    
-    private boolean ShouldOffsetPositionIfPathingOutOfBlock( int i, int j, int k, Entity entity )
-    {
-        int iStartBlockID = worldMap.getBlockId( i, j, k );
-
-        if ( iStartBlockID > 0 )
-        {
-	        Block startBlock = Block.blocksList[iStartBlockID];
-	    	
-	        return startBlock.ShouldOffsetPositionIfPathingOutOf( worldMap, i, j, k, entity, this );
-        }
-        
-        return false;
-    }
-    
-    private boolean CanPathThroughBlock( int i, int j, int k, Entity entity )
-    {
-        int iStartBlockID = worldMap.getBlockId( i, j, k );
-
-        if ( iStartBlockID > 0 )
-        {
-	        Block startBlock = Block.blocksList[iStartBlockID];
-	    	
-	        return startBlock.CanPathThroughBlock( worldMap, i, j, k, entity, this );
-        }
-        
-        return true;
-    }
-    // END FCMOD
 }
--- PathNavigate.java	Wed Jan  9 01:10:34 2019
+++ PathNavigate.java	Fri Apr 20 22:33:15 2018
@@ -226,8 +226,6 @@
             }
         }
 
-        // FCMOD: Changed to use rectangular bounds to reduce spazziness.
-        /*
         float var8 = this.theEntity.width * this.theEntity.width;
         int var4;
 
@@ -238,24 +236,6 @@
                 this.currentPath.setCurrentPathIndex(var4 + 1);
             }
         }
-        */
-        // slightly less than a half block width to ensure the creature is actually within the
-        // destination block, which is important for stuff like eating grass
-        
-        for ( int iTempIndex = currentPath.getCurrentPathIndex(); iTempIndex < var2; iTempIndex++ )
-        {
-        	Vec3 currentDest = currentPath.getVectorFromIndex( theEntity, iTempIndex );
-        	
-            if ( Math.abs( var1.xCoord - currentDest.xCoord ) < 0.49D && 
-            	Math.abs( var1.zCoord - currentDest.zCoord ) < 0.49D &&
-            	Math.abs( var1.yCoord - currentDest.yCoord ) < 0.49D )
-            {
-                currentPath.setCurrentPathIndex( iTempIndex + 1 );
-            }
-        }
-        
-        int var4;
-        // END FCMOD
 
         var4 = MathHelper.ceiling_float_int(this.theEntity.width);
         int var5 = (int)this.theEntity.height + 1;
@@ -536,43 +516,4 @@
 
         return true;
     }
-    
-    // FCMOD: Added New
-    public boolean tryMoveToXYZ( int i, int j, int k, float fSpeed )
-    {
-    	// int based version of vanilla double based function, to avoid unnecessary type casts
-    	
-        PathEntity path = getPathToXYZ( i, j, k );
-        
-        return setPath( path, fSpeed );
-    }
-    
-    public PathEntity getPathToXYZ( int i, int j, int k )
-    {
-    	// int based version of vanilla double based function, to avoid unnecessary type casts
-    	
-    	if ( canNavigate() )
-    	{
-    		return worldObj.getEntityPathToXYZ( theEntity, i, j, k,  
-    			pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
-    			avoidsWater, canSwim);
-    	}
-    	
-    	return null;
-    }
-    
-    public PathEntity GetPathToEntity( Entity toEntity )
-    {
-        return !canNavigate() ? null : worldObj.getPathEntityToEntity( theEntity, 
-        	toEntity, pathSearchRange, canPassOpenWoodenDoors, canPassClosedWoodenDoors, 
-        	avoidsWater, canSwim);
-    }
-
-    public boolean TryMoveToEntity( Entity toEntity, float fMoveSpeed )
-    {
-        PathEntity newPath = GetPathToEntity( toEntity );
-        
-        return newPath != null ? setPath( newPath, fMoveSpeed ) : false;
-    }
-    // END FCMOD
 }
--- Potion.java	Thu Jan 16 15:25:00 2014
+++ Potion.java	Fri Apr 20 22:33:15 2018
@@ -135,8 +135,6 @@
         {
             ((EntityPlayer)par1EntityLiving).addExhaustion(0.025F * (float)(par2 + 1));
         }
-        // FCMOD: Changed this to get rid of whole "healing hurts undead, harming helps them" thing
-        /*
         else if ((this.id != heal.id || par1EntityLiving.isEntityUndead()) && (this.id != harm.id || !par1EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par1EntityLiving.isEntityUndead() || this.id == heal.id && par1EntityLiving.isEntityUndead())
@@ -148,16 +146,6 @@
         {
             par1EntityLiving.heal(6 << par2);
         }
-        */
-        else if ( this.id == harm.id )
-        {
-            par1EntityLiving.attackEntityFrom(DamageSource.magic, 6 << par2);
-        }
-        else if ( this.id == heal.id )
-        {
-            par1EntityLiving.heal(6 << par2);
-        }
-        // END FCMOD
     }
 
     /**
@@ -167,8 +155,6 @@
     {
         int var6;
 
-        // FCMOD: Code change to get rid of special casing of undead in potion use
-        /*
         if ((this.id != heal.id || par2EntityLiving.isEntityUndead()) && (this.id != harm.id || !par2EntityLiving.isEntityUndead()))
         {
             if (this.id == harm.id && !par2EntityLiving.isEntityUndead() || this.id == heal.id && par2EntityLiving.isEntityUndead())
@@ -186,22 +172,6 @@
             }
         }
         else
-        */
-        if ( this.id == harm.id )
-        {
-            var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
-
-            if (par1EntityLiving == null)
-            {
-                par2EntityLiving.attackEntityFrom(DamageSource.magic, var6);
-            }
-            else
-            {
-                par2EntityLiving.attackEntityFrom(DamageSource.causeIndirectMagicDamage(par2EntityLiving, par1EntityLiving), var6);
-            }
-        }
-        else if ( this.id == heal.id )
-        // END FCMOD        
         {
             var6 = (int)(par4 * (double)(6 << par3) + 0.5D);
             par2EntityLiving.heal(var6);
--- RandomPositionGenerator.java	Thu Dec 27 23:46:59 2018
+++ RandomPositionGenerator.java	Fri Apr 20 22:33:15 2018
@@ -67,14 +67,9 @@
 
         for (int var16 = 0; var16 < 10; ++var16)
         {
-        	// FCMOD: Changed to fix bias towards the northwest
-            //int var12 = var4.nextInt(2 * par1) - par1;
-            //int var17 = var4.nextInt(2 * par2) - par2;
-            //int var14 = var4.nextInt(2 * par1) - par1;
-            int var12 = var4.nextInt( 2 * par1 + 1 ) - par1;
-            int var17 = var4.nextInt( 2 * par2 + 1 ) - par2;
-            int var14 = var4.nextInt( 2 * par1 + 1 ) - par1;
-            // END FCMOD
+            int var12 = var4.nextInt(2 * par1) - par1;
+            int var17 = var4.nextInt(2 * par2) - par2;
+            int var14 = var4.nextInt(2 * par1) - par1;
 
             if (par3Vec3 == null || (double)var12 * par3Vec3.xCoord + (double)var14 * par3Vec3.zCoord >= 0.0D)
             {
--- RecipeFireworks.java	Sun Aug 12 19:40:46 2018
+++ RecipeFireworks.java	Fri Apr 20 22:33:15 2018
@@ -245,18 +245,4 @@
     {
         return this.field_92102_a;
     }
-    
-    // FCMOD: Function added
-    @Override
-    public boolean matches( IRecipe recipe )
-    {
-    	return false;
-    }
-    
-    @Override
-    public boolean HasSecondaryOutput()
-    {
-    	return false;
-    }    
-    // END FCMOD
 }
--- RecipesArmorDyes.java	Sun Aug 12 19:40:58 2018
+++ RecipesArmorDyes.java	Fri Apr 20 22:33:15 2018
@@ -22,19 +22,7 @@
                 {
                     ItemArmor var7 = (ItemArmor)var6.getItem();
 
-                    // FCMOD: Code change
-                    /*
                     if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
-                    */                    
-                    if ( var7 instanceof FCItemArmorMod )
-                    {
-                    	if ( !((FCItemArmorMod)var7).HasCustomColors() || var3 != null )
-                    	{
-                    		return false;
-                    	}
-                    }
-                    else if (var7.getArmorMaterial() != EnumArmorMaterial.CLOTH || var3 != null)
-                	// END FCMOD
                     {
                         return false;
                     }
@@ -81,19 +69,8 @@
                 if (var8.getItem() instanceof ItemArmor)
                 {
                     var6 = (ItemArmor)var8.getItem();
-                    // FCMOD: Code change
-                    /*
+
                     if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
-                    */                    
-                    if ( var6 instanceof FCItemArmorMod )
-                    {
-                    	if ( !((FCItemArmorMod)var6).HasCustomColors() || var2 != null )
-                    	{
-                    		return null;
-                    	}
-                    }
-                    else if (var6.getArmorMaterial() != EnumArmorMaterial.CLOTH || var2 != null)
-                	// END FCMOD
                     {
                         return null;
                     }
@@ -167,18 +144,4 @@
     {
         return null;
     }
-    
-    // FCMOD: Function added
-    @Override
-    public boolean matches( IRecipe recipe )
-    {
-    	return false;
-    }
-    
-    @Override
-    public boolean HasSecondaryOutput()
-    {
-    	return false;
-    }
-    // END FCMOD
 }
--- RecipesMapCloning.java	Sun Aug 12 19:41:23 2018
+++ RecipesMapCloning.java	Fri Apr 20 22:33:15 2018
@@ -104,18 +104,4 @@
     {
         return null;
     }
-    
-    // FCMOD: Function added
-    @Override
-    public boolean matches( IRecipe recipe )
-    {
-    	return false;
-    }
-    
-    @Override
-    public boolean HasSecondaryOutput()
-    {
-    	return false;
-    }
-    // END FCMOD
 }
--- SaveHandler.java	Wed Oct 31 11:53:57 2018
+++ SaveHandler.java	Fri Apr 20 22:33:15 2018
@@ -342,138 +342,4 @@
     {
         return this.saveDirectoryName;
     }
-    
-    // FCMOD: Added    
-    @Override
-    public void LoadModSpecificData( WorldServer world )
-    {
-        File modSaveFile = new File( GetDimensionDirectory( world ), "FCWorld.dat");
-        
-        if ( modSaveFile.exists() )
-        {
-            try
-            {
-            	NBTTagCompound fileTag = CompressedStreamTools.readCompressed( new FileInputStream(modSaveFile) );
-            	NBTTagCompound dataTag = fileTag.getCompoundTag("Data");
-            	
-                LoadModSpecificDataFromNBT( world, dataTag );
-            }
-            catch ( Exception exception )
-            {
-                exception.printStackTrace();
-            }
-        }
-    }
-    
-    @Override
-    public void SaveModSpecificData( WorldServer world )
-    {
-        NBTTagCompound modData = new NBTTagCompound();
-        
-        SaveModSpecificDataToNBT( world, modData );
-        
-        NBTTagCompound fileData = new NBTTagCompound();
-        
-        fileData.setTag( "Data", modData );
-
-        try
-        {
-            File modSaveFile = new File( GetDimensionDirectory( world ), "FCWorld.dat");
-            
-            if ( modSaveFile.exists() )
-            {
-            	modSaveFile.delete();
-            }
-            
-            CompressedStreamTools.writeCompressed( fileData, new FileOutputStream( modSaveFile ) );
-
-        }
-        catch ( Exception exception )
-        {
-            exception.printStackTrace();
-        }
-    }
-    
-    private File GetDimensionDirectory( WorldServer world )
-    {
-        if ( world.provider.dimensionId == -1 ) // nether
-        {
-            return new File( worldDirectory, "DIM-1");
-        }
-        else if ( world.provider.dimensionId == 1 ) // the end
-        {
-        	return new File( worldDirectory, "DIM1");
-        }
-        else
-        {
-            return worldDirectory;
-        }        
-    }
-
-    private void LoadModSpecificDataFromNBT( WorldServer world, NBTTagCompound tag )
-    {
-	    if ( tag.hasKey( "FCMagneticPoints" ) )
-	    {
-	        NBTTagList nbttaglist1 = tag.getTagList( "FCMagneticPoints" );
-	        
-	    	world.GetMagneticPointList().loadFromNBT( nbttaglist1 );
-	    }
-	    
-	    if ( tag.hasKey( "FCEnderItems" ) )
-	    {
-	        NBTTagList itemList = tag.getTagList( "FCEnderItems" );
-	        
-	    	world.GetLocalEnderChestInventory().loadInventoryFromNBT( itemList );
-	    }
-	    
-	    if ( tag.hasKey( "FCLPEnderItems" ) )
-	    {
-	        NBTTagList itemList = tag.getTagList( "FCLPEnderItems" );
-	        
-	    	world.GetLocalLowPowerEnderChestInventory().loadInventoryFromNBT( itemList );
-	    }
-	    
-	    if ( tag.hasKey( "FCLootingBeacons" ) )
-	    {
-	        NBTTagList nbttaglist1 = tag.getTagList( "FCLootingBeacons" );
-	        
-	    	world.GetLootingBeaconLocationList().loadFromNBT( nbttaglist1 );
-	    }	    
-	    
-	    if ( tag.hasKey( "FCSpawnLocations" ) )
-	    {
-	        NBTTagList nbttaglist1 = tag.getTagList( "FCSpawnLocations" );
-	        
-	    	world.GetSpawnLocationList().loadFromNBT( nbttaglist1 );
-	    }	    
-    }
-    
-    private void SaveModSpecificDataToNBT( WorldServer world, NBTTagCompound tag )
-    {
-	    if ( world.GetMagneticPointList() != null )
-	    {
-	    	tag.setTag( "FCMagneticPoints", world.GetMagneticPointList().saveToNBT() );
-	    }
-	    
-	    if ( world.GetLocalEnderChestInventory() != null )
-	    {
-	    	tag.setTag( "FCEnderItems", world.GetLocalEnderChestInventory().saveInventoryToNBT() );
-	    }
-	    
-	    if ( world.GetLocalLowPowerEnderChestInventory() != null )
-	    {
-	    	tag.setTag( "FCLPEnderItems", world.GetLocalLowPowerEnderChestInventory().saveInventoryToNBT() );
-	    }
-	    
-	    if ( world.GetLootingBeaconLocationList() != null )
-	    {
-	    	tag.setTag( "FCLootingBeacons", world.GetLootingBeaconLocationList().saveToNBT() );
-	    }	    
-	    
-	    if ( world.GetSpawnLocationList() != null )
-	    {
-	    	tag.setTag( "FCSpawnLocations", world.GetSpawnLocationList().saveToNBT() );
-	    }	    
-    }    
-    // END FCMOD
 }
--- ServerCommandManager.java	Fri Jun 14 14:05:26 2013
+++ ServerCommandManager.java	Fri Apr 20 22:33:15 2018
@@ -30,9 +30,6 @@
         this.registerCommand(new CommandClearInventory());
         this.registerCommand(new ServerCommandTestFor());
         this.registerCommand(new ServerCommandScoreboard());
-        // FCMOD: Code added
-        registerCommand(new FCCommandServerLoc());
-        // END FCMOD
 
         if (MinecraftServer.getServer().isDedicatedServer())
         {
--- ServerConfigurationManager.java	Wed Dec 23 15:44:56 2020
+++ ServerConfigurationManager.java	Fri Apr 20 22:33:15 2018
@@ -116,9 +116,6 @@
                 var10.field_98038_p = false;
             }
         }
-        // FCMOD: Code added
-        FCBetterThanWolves.ServerPlayerConnectionInitialized( var7, par2EntityPlayerMP );
-        //END FCMOD
     }
 
     protected void func_96456_a(ServerScoreboard par1ServerScoreboard, EntityPlayerMP par2EntityPlayerMP)
@@ -166,25 +163,16 @@
 
         if (par2WorldServer != null)
         {
-        	// FCMOD: Changed
-            //par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
-            par2WorldServer.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
-            // END FCMOD
+            par2WorldServer.getPlayerManager().removePlayer(par1EntityPlayerMP);
         }
 
-    	// FCMOD: Changed
-        //var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
-        var3.GetChunkTracker().AddPlayer(par1EntityPlayerMP);
-        // END FCMOD
+        var3.getPlayerManager().addPlayer(par1EntityPlayerMP);
         var3.theChunkProviderServer.loadChunk((int)par1EntityPlayerMP.posX >> 4, (int)par1EntityPlayerMP.posZ >> 4);
     }
 
     public int getEntityViewDistance()
     {
-    	// FCMOD: Changed    	
-        //return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
-        return FCChunkTracker.GetFurthestViewableBlock( getViewDistance() );
-    	// END FCMOD
+        return PlayerManager.getFurthestViewableBlock(this.getViewDistance());
     }
 
     /**
@@ -238,16 +226,9 @@
     /**
      * using player's dimension, update their movement when in a vehicle (e.g. cart, boat)
      */
-    /** 
-     * FCNOTE: This is totally misnamed.  It is called for all moving players, not just mounted ones
-     */
     public void serverUpdateMountedMovingPlayer(EntityPlayerMP par1EntityPlayerMP)
     {
-    	// FCMOD: Changed
-        //par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
-        par1EntityPlayerMP.getServerForPlayer().GetChunkTracker().UpdateMovingPlayer(
-        	par1EntityPlayerMP);
-        // END FCMOD
+        par1EntityPlayerMP.getServerForPlayer().getPlayerManager().updateMountedMovingPlayer(par1EntityPlayerMP);
     }
 
     /**
@@ -265,10 +246,7 @@
         }
 
         var2.removeEntity(par1EntityPlayerMP);
-        // FCMOD: Changed
-        //var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
-        var2.GetChunkTracker().RemovePlayer(par1EntityPlayerMP);
-        // END FCMOD
+        var2.getPlayerManager().removePlayer(par1EntityPlayerMP);
         this.playerEntityList.remove(par1EntityPlayerMP);
         this.sendPacketToAllPlayers(new Packet201PlayerInfo(par1EntityPlayerMP.username, false, 9999));
     }
@@ -362,8 +340,6 @@
     /**
      * Called on respawn
      */
-    // FCMOD: Function removed and replaced later
-    /*
     public EntityPlayerMP recreatePlayerEntity(EntityPlayerMP par1EntityPlayerMP, int par2, boolean par3)
     {
         par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(par1EntityPlayerMP);
@@ -428,9 +404,6 @@
         var7.setEntityHealth(var7.getHealth());
         return var7;
     }
-	*/
-	// FCMOD
-
 
     /**
      * moves provided player from overworld to nether or vice versa
@@ -457,11 +430,6 @@
             PotionEffect var7 = (PotionEffect)var6.next();
             par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet41EntityEffect(par1EntityPlayerMP.entityId, var7));
         }
-        
-        // FCMOD: Added
-        par1EntityPlayerMP.FlagAllWatchedObjectsDirty();
-        par1EntityPlayerMP.m_lTimeOfLastDimensionSwitch = var5.getWorldTime();
-        // END FCMOD
     }
 
     /**
@@ -534,21 +502,10 @@
 
             if (par1Entity.isEntityAlive())
             {
-            	// FCMOD: Code change to fix other players not showing up when going through a portal in SMP
-            	/*
                 par4WorldServer.spawnEntityInWorld(par1Entity);
                 par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
                 par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
                 par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
-                */
-                par1Entity.setLocationAndAngles(var5, par1Entity.posY, var7, par1Entity.rotationYaw, par1Entity.rotationPitch);
-                
-                FlagChunksAroundTeleportingEntityForCheckForUnload( par4WorldServer, par1Entity );
-                
-                par4WorldServer.getDefaultTeleporter().placeInPortal(par1Entity, var11, var13, var15, var17);
-                par4WorldServer.spawnEntityInWorld(par1Entity);
-                par4WorldServer.updateEntityWithOptionalForce(par1Entity, false);
-                // END FCMOD
             }
 
             par3WorldServer.theProfiler.endSection();
@@ -929,20 +886,8 @@
 
         if (par2WorldServer.isRaining())
         {
-        	// FCMOD: Code change so that initial rain strength is set to full on client
-        	/*
             par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(1, 0));
-            */
-            par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(1, 1));
-        	// END FCMOD
-        }
-        
-        // FCMOD: Code added
-        if (par2WorldServer.worldInfo.isThundering())
-        {
-            par1EntityPlayerMP.playerNetServerHandler.sendPacket(new Packet70GameEvent(7, 1));
-        }        
-        // END FCMOD
+        }
     }
 
     /**
@@ -1061,164 +1006,4 @@
         this.mcServer.logInfo(par1Str);
         this.sendPacketToAllPlayers(new Packet3Chat(par1Str));
     }
-
-    // FCMOD: Added    
-    // client
-    //public EntityPlayerMP respawnPlayer( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
-    // server
-    public EntityPlayerMP recreatePlayerEntity( EntityPlayerMP oldPlayer, int iDefaultDimension, boolean bPlayerLeavingTheEnd )
-    {
-        oldPlayer.getServerForPlayer().getEntityTracker().removePlayerFromTrackers( oldPlayer );
-        
-    	// client
-        //oldPlayer.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers( oldPlayer );
-    	// server    	
-    	oldPlayer.getServerForPlayer().getEntityTracker().untrackEntity( oldPlayer );
-        
-        oldPlayer.getServerForPlayer().GetChunkTracker().RemovePlayer( oldPlayer );
-        
-        playerEntityList.remove( oldPlayer );
-        
-        mcServer.worldServerForDimension( oldPlayer.dimension ).removePlayerEntityDangerously( oldPlayer );
-        
-        ChunkCoordinates verifiedRespawnCoords = null;
-        boolean bRetainPreviousSpawn = false;
-
-    	String sSpawnFailMessage = null;
-    	
-    	int iNewDimension = iDefaultDimension;
-    	
-        if ( oldPlayer.HasRespawnCoordinates() )
-        {
-            if ( !bPlayerLeavingTheEnd )
-            {
-	        	ChunkCoordinates rawRespawnCoords = new ChunkCoordinates();
-	        	
-	            int iReturnValue = oldPlayer.GetValidatedRespawnCoordinates( mcServer.worldServerForDimension( oldPlayer.m_iSpawnDimension ), rawRespawnCoords );
-	
-	            if ( iReturnValue == 0 )
-	            {
-	            	verifiedRespawnCoords = rawRespawnCoords;	
-	            	iNewDimension = oldPlayer.m_iSpawnDimension;
-	            }
-	            else
-	            {
-		            if ( iReturnValue == 1 )
-		            {
-		            	sSpawnFailMessage = "Your respawn location was invalid";
-		            }
-		            else if ( iReturnValue == 2 )
-		            {
-		            	sSpawnFailMessage = "The beacon to which you were bound is no longer present";
-		            }
-		            else if ( iReturnValue == 3 )
-		            {
-		            	sSpawnFailMessage = "The beacon to which you are bound was too far away";
-		            	bRetainPreviousSpawn = true;
-		            }
-		            else if ( iReturnValue == 4 )
-		            {
-		            	sSpawnFailMessage = "The beacon to which you are bound was obstructed";
-		            	bRetainPreviousSpawn = true;
-		            }
-		            else
-		            {
-		            	sSpawnFailMessage = "Your respawn failed for an unknown reason";
-		            }
-		            
-	            }
-	        }
-            else
-            {
-            	// retain the player's previous respawn location when you pop back from the end
-            	
-            	bRetainPreviousSpawn = true;
-            }
-        }
-
-        ItemInWorldManager worldManager;
-
-        if (this.mcServer.isDemo())
-        {
-            worldManager = new DemoWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
-        }
-        else
-        {
-            worldManager = new ItemInWorldManager(this.mcServer.worldServerForDimension( iNewDimension ) );
-        }
-
-        EntityPlayerMP newPlayer = new EntityPlayerMP( mcServer, mcServer.worldServerForDimension( iNewDimension ), oldPlayer.username, worldManager );
-        
-        newPlayer.playerNetServerHandler = oldPlayer.playerNetServerHandler;
-        
-        oldPlayer.dimension = iNewDimension;        
-        newPlayer.clonePlayer( oldPlayer, bPlayerLeavingTheEnd );
-        newPlayer.entityId = oldPlayer.entityId;
-        
-        WorldServer newWorldServer = mcServer.worldServerForDimension( oldPlayer.dimension );
-        
-        func_72381_a( newPlayer, oldPlayer, newWorldServer ); // initializes the game type
-        
-        if ( verifiedRespawnCoords != null )
-        {
-            newPlayer.setLocationAndAngles((double)((float)verifiedRespawnCoords.posX + 0.5F), (double)((float)verifiedRespawnCoords.posY + 0.1F), (double)((float)verifiedRespawnCoords.posZ + 0.5F), 0.0F, 0.0F);
-            
-            bRetainPreviousSpawn = true;
-            
-        }
-        else if ( !bPlayerLeavingTheEnd )
-        {
-    		FCUtilsHardcoreSpawn.HandleHardcoreSpawn( mcServer, oldPlayer, newPlayer );
-        }
-        
-        if ( bRetainPreviousSpawn )
-        {
-            newPlayer.setSpawnChunk( oldPlayer.getBedLocation(), oldPlayer.isSpawnForced(), oldPlayer.m_iSpawnDimension );
-        }
-        
-        if ( sSpawnFailMessage != null )
-        {
-            FCUtilsWorld.SendPacketToPlayer( newPlayer.playerNetServerHandler, new Packet3Chat( sSpawnFailMessage ) );
-        }
-        
-        newWorldServer.theChunkProviderServer.loadChunk((int)newPlayer.posX >> 4, (int)newPlayer.posZ >> 4);
-
-        while (!newWorldServer.getCollidingBoundingBoxes(newPlayer, newPlayer.boundingBox).isEmpty())
-        {
-            newPlayer.setPosition(newPlayer.posX, newPlayer.posY + 1.0D, newPlayer.posZ);
-        }
-
-        newPlayer.playerNetServerHandler.sendPacket(new Packet9Respawn(newPlayer.dimension, (byte)newPlayer.worldObj.difficultySetting, newPlayer.worldObj.getWorldInfo().getTerrainType(), newPlayer.worldObj.getHeight(), newPlayer.theItemInWorldManager.getGameType()));
-        verifiedRespawnCoords = newWorldServer.getSpawnPoint();
-        newPlayer.playerNetServerHandler.sendPacket(new Packet6SpawnPosition(verifiedRespawnCoords.posX, verifiedRespawnCoords.posY, verifiedRespawnCoords.posZ));
-        newPlayer.playerNetServerHandler.sendPacket(new Packet43Experience(newPlayer.experience, newPlayer.experienceTotal, newPlayer.experienceLevel));
-        this.updateTimeAndWeatherForPlayer(newPlayer, newWorldServer);
-        newWorldServer.GetChunkTracker().AddPlayer(newPlayer);
-        newWorldServer.spawnEntityInWorld(newPlayer);
-        this.playerEntityList.add(newPlayer);
-        newPlayer.addSelfToInternalCraftingInventory();
-        newPlayer.setEntityHealth(newPlayer.getHealth());
-        
-        // Code moved relative to vanilla version so that some loading occurs before loading screen dissapears
-        newPlayer.playerNetServerHandler.setPlayerLocation(newPlayer.posX, newPlayer.posY, newPlayer.posZ, newPlayer.rotationYaw, newPlayer.rotationPitch);
-        
-        return newPlayer;
-    }
-    
-    private void FlagChunksAroundTeleportingEntityForCheckForUnload( WorldServer world, Entity entity )
-    {
-        // flag area checked for teleport for unload check as the Teleporter 
-        // class potentially loads a whole bunch of chunks in the placeInPortal() call.
-    	
-    	int iChunkX = MathHelper.floor_double( entity.posX / 16D ); 
-    	int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
-    	
-    	// Teleporter.placeInExistingPortal() checks out to 128 blocks, or 8 chunks
-    	
-    	int iChunkRange = 9;
-    	
-    	world.AddChunkRangeToCheckForUnloadList( iChunkX - iChunkRange, iChunkZ - iChunkRange,
-    		iChunkX + iChunkRange, iChunkZ + iChunkRange );        
-    }
-    // END FCMOD
 }
--- ShapedRecipes.java	Sun Aug 12 19:46:03 2018
+++ ShapedRecipes.java	Fri Apr 20 22:33:15 2018
@@ -37,18 +37,10 @@
      */
     public boolean matches(InventoryCrafting par1InventoryCrafting, World par2World)
     {
-    	// FCMOD: Changed the following to support 4X4 crafting grid
-    	/*
         for (int var3 = 0; var3 <= 3 - this.recipeWidth; ++var3)
         {
             for (int var4 = 0; var4 <= 3 - this.recipeHeight; ++var4)
             {
-        */    	
-        for (int var3 = 0; var3 <= 4 - this.recipeWidth; ++var3)
-        {
-            for (int var4 = 0; var4 <= 4 - this.recipeHeight; ++var4)
-            {
-    	// END FCMOD
                 if (this.checkMatch(par1InventoryCrafting, var3, var4, true))
                 {
                     return true;
@@ -69,18 +61,10 @@
      */
     private boolean checkMatch(InventoryCrafting par1InventoryCrafting, int par2, int par3, boolean par4)
     {
-    	// FCMOD: Changed the following to support 4X4 crafting grid
-    	/*
         for (int var5 = 0; var5 < 3; ++var5)
         {
             for (int var6 = 0; var6 < 3; ++var6)
             {
-        */
-        for (int var5 = 0; var5 < 4; ++var5)
-        {
-            for (int var6 = 0; var6 < 4; ++var6)
-            {
-    	// END FCMOD
                 int var7 = var5 - par2;
                 int var8 = var6 - par3;
                 ItemStack var9 = null;
@@ -99,13 +83,6 @@
 
                 ItemStack var10 = par1InventoryCrafting.getStackInRowAndColumn(var5, var6);
 
-                // FCMOD: Code added to ignore Moulds                
-                if ( var10 != null && var10.itemID == FCBetterThanWolves.fcItemMould.itemID )
-                {
-                	var10 = null;
-                }
-                // END FCMOD
-                
                 if (var10 != null || var9 != null)
                 {
                     if (var10 == null && var9 != null || var10 != null && var9 == null)
@@ -165,63 +142,4 @@
         this.field_92101_f = true;
         return this;
     }
-
-    // FCMOD: Added
-    private boolean m_bHasSecondaryOutput = false;
-    
-    @Override
-    public boolean matches( IRecipe recipe )
-    {
-    	if ( recipe instanceof ShapedRecipes )
-    	{
-    		ShapedRecipes shapedRecipe = (ShapedRecipes)recipe;
-    		
-    		if ( recipeWidth == shapedRecipe.recipeWidth  && recipeHeight == shapedRecipe.recipeHeight )
-    		{
-    			if ( recipeOutputItemID == shapedRecipe.recipeOutputItemID &&
-    				recipeOutput.stackSize == shapedRecipe.recipeOutput.stackSize && 
-    				recipeOutput.getItemDamage() == shapedRecipe.recipeOutput.getItemDamage() )
-    			{
-    				if ( recipeItems.length == shapedRecipe.recipeItems.length )
-    				{
-	    				for ( int iTempIndex = 0; iTempIndex < recipeItems.length; iTempIndex++ )
-	    				{
-	    					ItemStack item1 = recipeItems[iTempIndex];
-	    					ItemStack item2 = shapedRecipe.recipeItems[iTempIndex]; 
-	    						
-	    					if ( item1 == null || item2 == null )
-	    					{
-	    						if ( item1 != null || item2 != null )
-	    						{
-	    							return false;
-	    						}
-	    					}
-	    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
-	    							item1.stackSize != item2.stackSize ||
-	    							item1.getItemDamage() != item2.getItemDamage() )
-	    					{
-	    						return false;
-	    					}
-	    				}
-	    				
-	    				return true;
-    				}
-    			}
-    		}
-    	}
-    	
-    	return false;
-    }
-    
-    @Override
-    public boolean HasSecondaryOutput()
-    {
-    	return m_bHasSecondaryOutput;
-    }
-    
-    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
-    {
-    	m_bHasSecondaryOutput = bHasSecondaryOutput;
-    }
-    // END FCMOD    
 }
--- ShapelessRecipes.java	Tue Nov 27 15:34:26 2018
+++ ShapelessRecipes.java	Fri Apr 20 22:33:15 2018
@@ -30,29 +30,14 @@
     {
         ArrayList var3 = new ArrayList(this.recipeItems);
 
-    	// FCMOD: Changed to support 4X4 crafting
-		/*
         for (int var4 = 0; var4 < 3; ++var4)
         {
             for (int var5 = 0; var5 < 3; ++var5)
             {
-        */
-        for (int var4 = 0; var4 < 4; ++var4)
-        {
-            for (int var5 = 0; var5 < 4; ++var5)
-            {
-    	// END FCMOD
                 ItemStack var6 = par1InventoryCrafting.getStackInRowAndColumn(var5, var4);
 
                 if (var6 != null)
                 {
-                    // FCMOD: Code added to ignore Moulds                
-                    if ( var6.itemID == FCBetterThanWolves.fcItemMould.itemID )
-                    {
-                    	continue;
-                    }
-                    // END FCMOD
-                    
                     boolean var7 = false;
                     Iterator var8 = var3.iterator();
 
@@ -94,60 +79,4 @@
     {
         return this.recipeItems.size();
     }
-    
-    // FCMOD: Added
-    private boolean m_bHasSecondaryOutput = false;
-    
-    @Override
-    public boolean matches( IRecipe recipe )
-    {
-    	if ( recipe instanceof ShapelessRecipes )
-    	{
-    		ShapelessRecipes shapelessRecipe = (ShapelessRecipes)recipe;
-    		
-			if ( recipeOutput.getItem().itemID == shapelessRecipe.recipeOutput.getItem().itemID &&
-				recipeOutput.stackSize == shapelessRecipe.recipeOutput.stackSize && 
-				recipeOutput.getItemDamage() == shapelessRecipe.recipeOutput.getItemDamage() )
-			{
-				if ( recipeItems.size() == shapelessRecipe.recipeItems.size() )
-				{
-    				for ( int iTempIndex = 0; iTempIndex < recipeItems.size(); iTempIndex++ )
-    				{
-    					ItemStack item1 = (ItemStack)recipeItems.get( iTempIndex );
-    					ItemStack item2 = (ItemStack)shapelessRecipe.recipeItems.get( iTempIndex ); 
-    						
-    					if ( item1 == null || item2 == null )
-    					{
-    						if ( item1 != null || item2 != null )
-    						{
-    							return false;
-    						}
-    					}
-    					else if ( item1.getItem().itemID != item2.getItem().itemID ||
-    							item1.stackSize != item2.stackSize ||
-    							item1.getItemDamage() != item2.getItemDamage() )
-    					{
-    						return false;
-    					}
-    				}
-    				
-    				return true;
-				}
-    		}
-    	}
-    	
-    	return false;
-    }
-    
-    @Override
-    public boolean HasSecondaryOutput()
-    {
-    	return m_bHasSecondaryOutput;
-    }
-    
-    public void SetHasSecondaryOutput( boolean bHasSecondaryOutput )
-    {
-    	m_bHasSecondaryOutput = bHasSecondaryOutput;
-    }
-    // END FCMOD    
-}
\ No newline at end of file
+}
--- SlotCrafting.java	Tue Nov 27 15:32:49 2018
+++ SlotCrafting.java	Fri Apr 20 22:33:15 2018
@@ -112,43 +112,10 @@
 
             if (var4 != null)
             {
-            	// FCMOD: Added            	
-            	var4.getItem().OnUsedInCrafting( var4.getItemDamage(), par1EntityPlayer, 
-            		par2ItemStack );
-            	
-            	if ( !var4.getItem().IsConsumedInCrafting() )
-            	{
-            		continue;
-            	}
-            	else if ( var4.getItem().IsDamagedInCrafting() )
-            	{
-            		if ( var4.getItemDamage() >= var4.getMaxDamage() - 1 )
-            		{
-            			var4.getItem().OnBrokenInCrafting( par1EntityPlayer );
-            			
-                        craftMatrix.decrStackSize(var3, 1);
-            		}
-            		else
-            		{
-            			var4.getItem().OnDamagedInCrafting( par1EntityPlayer );
-            			
-            			var4.damageItem( 1, par1EntityPlayer );
-            		}
-
-            		continue;
-            	}            	
-        		// END FCMOD
                 this.craftMatrix.decrStackSize(var3, 1);
 
                 if (var4.getItem().hasContainerItem())
                 {
-                    // FCMOD: Code added
-                    if ( par2ItemStack.getItem().DoesConsumeContainerItemWhenCrafted( var4.getItem().getContainerItem() ) )
-                    {
-                    	continue;
-                    }
-                    // END FCMOD
-
                     ItemStack var5 = new ItemStack(var4.getItem().getContainerItem());
 
                     if (!var4.getItem().doesContainerItemLeaveCraftingGrid(var4) || !this.thePlayer.inventory.addItemStackToInventory(var5))
@@ -165,9 +132,5 @@
                 }
             }
         }
-        
-        // FCMOD: Code added
-        par1EntityPlayer.m_iTimesCraftedThisTick++;
-        // END FCMOD
     }
 }
--- SlotFurnace.java	Fri Jun 14 14:09:47 2013
+++ SlotFurnace.java	Fri Apr 20 22:33:15 2018
@@ -79,16 +79,12 @@
                 var2 = var4;
             }
 
-            // FCMOD: Code removed
-            /*
             while (var2 > 0)
             {
                 var4 = EntityXPOrb.getXPSplit(var2);
                 var2 -= var4;
                 this.thePlayer.worldObj.spawnEntityInWorld(new EntityXPOrb(this.thePlayer.worldObj, this.thePlayer.posX, this.thePlayer.posY + 0.5D, this.thePlayer.posZ + 0.5D, var4));
             }
-            */
-            // END FCMOD
         }
 
         this.field_75228_b = 0;
@@ -102,13 +98,5 @@
         {
             this.thePlayer.addStat(AchievementList.cookFish, 1);
         }
-        
-        // FCMOD: Code added
-		if ( par1ItemStack.getItem().itemID == Item.bread.itemID )
-		{
-            thePlayer.addStat( AchievementList.makeBread, 1 );
-		}
-		// END FCMOD
-        
     }
 }
--- SpawnerAnimals.java	Sun Nov 22 13:50:17 2020
+++ SpawnerAnimals.java	Fri Apr 20 22:33:15 2018
@@ -2,21 +2,16 @@
 
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Random;
 
 public final class SpawnerAnimals
 {
     /** The 17x17 area around the player where mobs can spawn */
-	// FCMOD: Removed in favor of using the world's active chunk list	
-    //private static HashMap eligibleChunksForSpawning = new HashMap();
-	// END FCMOD
+    private static HashMap eligibleChunksForSpawning = new HashMap();
 
     /** An array of entity classes that spawn at night. */
-    // FCMOD: Removed due to deprecation
-    //protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
-    // END FCMOD
+    protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
 
     /**
      * Given a chunk, find a random position in it.
@@ -42,8 +37,6 @@
         }
         else
         {
-        	// FCMOD: Changed
-        	/*
             eligibleChunksForSpawning.clear();
             int var4;
             int var7;
@@ -73,17 +66,9 @@
                     }
                 }
             }
-            */
-        	LinkedList<ChunkCoordIntPair> activeChunks = par0WorldServer.GetActiveChunksCoordsList();
-            
-            int var4;
-            int var7;
-            // END FCMOD
 
             var4 = 0;
-            // FCMOD: Removed
-            //ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
-            // END FCMOD
+            ChunkCoordinates var32 = par0WorldServer.getSpawnPoint();
             EnumCreatureType[] var33 = EnumCreatureType.values();
             var7 = var33.length;
 
@@ -91,41 +76,23 @@
             {
                 EnumCreatureType var35 = var33[var34];
 
-                // FCMOD: Changed to use custom spawn cap counting
-                //if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
-                if ( ( !var35.getPeacefulCreature() || par2 ) && 
-                	( var35.getPeacefulCreature() || par1 ) && 
-                	( !var35.getAnimal() || par3 ) && 
-                	par0WorldServer.CountEntitiesThatApplyToSpawnCap( var35.getCreatureClass() ) <= 
-                		var35.getMaxNumberOfCreature() * activeChunks.size() / 256 )
-            	// END FCMOD
+                if ((!var35.getPeacefulCreature() || par2) && (var35.getPeacefulCreature() || par1) && (!var35.getAnimal() || par3) && par0WorldServer.countEntities(var35.getCreatureClass()) <= var35.getMaxNumberOfCreature() * eligibleChunksForSpawning.size() / 256)
                 {
-                	// FCMOD: Changed
-                    //Iterator var37 = eligibleChunksForSpawning.keySet().iterator();
-                    Iterator var37 = activeChunks.iterator();                    
-                    // END FCMOD
+                    Iterator var37 = eligibleChunksForSpawning.keySet().iterator();
                     label110:
 
                     while (var37.hasNext())
                     {
                         ChunkCoordIntPair var36 = (ChunkCoordIntPair)var37.next();
 
-                        // FCMOD: Removed
-                        //if (!((Boolean)eligibleChunksForSpawning.get(var36)).booleanValue())
-                    	// END FCMOD
+                        if (!((Boolean)eligibleChunksForSpawning.get(var36)).booleanValue())
                         {
                             ChunkPosition var38 = getRandomSpawningPointInChunk(par0WorldServer, var36.chunkXPos, var36.chunkZPos);
                             int var13 = var38.x;
                             int var14 = var38.y;
                             int var15 = var38.z;
 
-                            // FCMOD: Changed as this was preventing spawns in weird circumstances
-                            // like superflat worlds with snow cover.
-                            //if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
-                            if ( !par0WorldServer.isBlockNormalCube(var13, var14, var15) && 
-                            	CanCreatureTypeSpawnInMaterial( var35, 
-                        		par0WorldServer.getBlockMaterial( var13, var14, var15 ) ) )
-                        	// END FCMOD
+                            if (!par0WorldServer.isBlockNormalCube(var13, var14, var15) && par0WorldServer.getBlockMaterial(var13, var14, var15) == var35.getCreatureMaterial())
                             {
                                 int var16 = 0;
                                 int var17 = 0;
@@ -146,8 +113,6 @@
                                             label103:
                                             {
                                                 var18 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
-                                                // FCNOTE: The following results in 0 all the time.  
-                                                // Bug?  Check if leaves world bounds if fix?
                                                 var19 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
                                                 var20 += par0WorldServer.rand.nextInt(var21) - par0WorldServer.rand.nextInt(var21);
 
@@ -155,27 +120,16 @@
                                                 {
                                                     float var24 = (float)var18 + 0.5F;
                                                     float var25 = (float)var19;
-                                                    // FCMOD: Added
-                                                    var25 += GetVerticalOffsetForPos( var35, par0WorldServer, var18, var19, var20 );
-                                                    var25 += 0.01F; // wiggle
-                                                	// END FCMOD
                                                     float var26 = (float)var20 + 0.5F;
 
                                                     if (par0WorldServer.getClosestPlayer((double)var24, (double)var25, (double)var26, 24.0D) == null)
                                                     {
-                                                    	// FCCHUNK: Decide on updates around original spawn
-                                                    	// FCMOD: Removed distance check from creature to 
-                                                    	// original spawn which prevents spawning 
-                                                    	// within 24 blocks (root of 576)
-                                                    	/*
                                                         float var27 = var24 - (float)var32.posX;
                                                         float var28 = var25 - (float)var32.posY;
                                                         float var29 = var26 - (float)var32.posZ;
                                                         float var30 = var27 * var27 + var28 * var28 + var29 * var29;
 
                                                         if (var30 >= 576.0F)
-                                                        */
-                                                    	// END FCMOD
                                                         {
                                                             if (var22 == null)
                                                             {
@@ -199,10 +153,6 @@
                                                                 return var4;
                                                             }
 
-                                                            // FCMOD: Added
-                                                            var39.PreInitCreature();
-                                                            // END FCMOD
-
                                                             var39.setLocationAndAngles((double)var24, (double)var25, (double)var26, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
 
                                                             if (var39.getCanSpawnHere())
@@ -244,8 +194,6 @@
     /**
      * Returns whether or not the specified creature type can spawn at the specified location.
      */
-    // FCMOD: Removed and replaced
-    /*
     public static boolean canCreatureTypeSpawnAtLocation(EnumCreatureType par0EnumCreatureType, World par1World, int par2, int par3, int par4)
     {
         if (par0EnumCreatureType.getCreatureMaterial() == Material.water)
@@ -262,8 +210,6 @@
             return var5 != Block.bedrock.blockID && !par1World.isBlockNormalCube(par2, par3, par4) && !par1World.getBlockMaterial(par2, par3, par4).isLiquid() && !par1World.isBlockNormalCube(par2, par3 + 1, par4);
         }
     }
-    */
-    // END FCMOD
 
     /**
      * determines if a skeleton spawns on a spider, and if a sheep is a different color
@@ -299,12 +245,7 @@
                     {
                         int var17 = par0World.getTopSolidOrLiquidBlock(var10, var11);
 
-                        // FCMOD: Changed
-                        /*
                         if (canCreatureTypeSpawnAtLocation(EnumCreatureType.creature, par0World, var10, var17, var11))
-                        */
-                        if (CanAnimalSpawnAtLocationDuringWorldGen(EnumCreatureType.creature, par0World, var10, var17, var11))
-                        // END FCMOD
                         {
                             float var18 = (float)var10 + 0.5F;
                             float var19 = (float)var17;
@@ -321,9 +262,6 @@
                                 continue;
                             }
 
-                            // FCMOD: Added
-                            var21.PreInitCreature();
-                            // END FCMOD
                             var21.setLocationAndAngles((double)var18, (double)var19, (double)var20, par6Random.nextFloat() * 360.0F, 0.0F);
                             par0World.spawnEntityInWorld(var21);
                             creatureSpecificInit(var21, par0World, var18, var19, var20);
@@ -341,108 +279,4 @@
             }
         }
     }
-    
-    // FCMOD: Added New
-    public static boolean CanAnimalSpawnAtLocationDuringWorldGen( EnumCreatureType type, 
-    	World world, int i, int j, int k )
-    {
-    	// modified and trimmed down version of canCreatureTypeSpawnAtLocation() so that animals 
-    	// don't initially spawn burried in leaves and to reduce the overall number of tests 
-    	// performed
-    	
-    	int iBlockID = world.getBlockId( i, j, k );
-    	
-    	if ( !Block.isNormalCube( iBlockID ) && !world.getBlockMaterial(i, j, k).isLiquid() && 
-    		iBlockID != Block.leaves.blockID )
-    	{
-    		int iBlockAboveID = world.getBlockId( i, j + 1, k );
-    		
-    		if ( !Block.isNormalCube( iBlockAboveID ) && iBlockAboveID != Block.leaves.blockID )
-    		{
-	            int iBlockBelowID = world.getBlockId( i, j - 1, k );
-	            
-	            return Block.isNormalCube( iBlockBelowID ) && 
-	            	iBlockBelowID != Block.bedrock.blockID;
-    		}
-    	}
-        
-        return false;
-    }
-    
-    public static boolean CanWitchSpawnAtLocationDuringWorldGen( World world, int i, int j, int k )
-    {
-    	// modified version of CanAnimalSpawnAtLocationDuringWorldGen that allows
-    	// witches to spawn over water and leaves to maximize chances they'll find a spot
-    	// around generated witch huts
-    	
-    	int iBlockID = world.getBlockId( i, j, k );
-    	
-    	if ( !Block.isNormalCube( iBlockID ) && !world.getBlockMaterial(i, j, k).isLiquid() && 
-    		iBlockID != Block.leaves.blockID )
-    	{
-    		int iBlockAboveID = world.getBlockId( i, j + 1, k );
-    		
-    		if ( !Block.isNormalCube( iBlockAboveID ) && iBlockAboveID != Block.leaves.blockID )
-    		{
-	            int iBlockBelowID = world.getBlockId( i, j - 1, k );
-	            
-	            return iBlockBelowID != Block.bedrock.blockID && 
-	            	( Block.isNormalCube( iBlockBelowID ) || 
-	            	world.getBlockMaterial( i, j - 1, k ) == Material.water ||
-	            	iBlockBelowID == Block.leaves.blockID );
-    		}
-    	}
-        
-        return false;
-    }
-    
-    public static boolean canCreatureTypeSpawnAtLocation( EnumCreatureType type, 
-    	World world, int i, int j, int k )
-    {
-        if ( type.getCreatureMaterial() == Material.water )
-        {
-            return world.getBlockMaterial( i, j, k ).isLiquid() && 
-            	world.getBlockMaterial( i, j - 1, k ).isLiquid() && 
-            	!world.isBlockNormalCube( i, j + 1, k );
-        }
-
-    	if ( !world.isBlockNormalCube( i, j, k ) && 
-    		!world.getBlockMaterial( i, j, k ).isLiquid() )
-    	{
-	    	Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
-	    	
-			return blockBelow != null && blockBelow.CanMobsSpawnOn( world, i, j - 1, k );
-    	}
-		
-		return false;
-    }
-    
-    public static float GetVerticalOffsetForPos( EnumCreatureType type, 
-    	World world, int i, int j, int k )
-    {
-        if ( type.getCreatureMaterial() != Material.water )
-        {
-	    	Block blockBelow = Block.blocksList[world.getBlockId( i, j - 1, k )];
-	    	
-			if ( blockBelow != null )
-			{
-				return blockBelow.MobSpawnOnVerticalOffset( world, i, j - 1, k );
-			}
-        }
-		
-		return 0F;
-    }   
-    
-	public static boolean CanCreatureTypeSpawnInMaterial( EnumCreatureType type, Material material ) 
-	{
-		if ( material == Material.water )
-		{
-			return type.getCreatureMaterial() == Material.water;
-		}
-		else
-		{
-			return type.getCreatureMaterial() != Material.water;
-		}
-	}    
-    // END FCMOD
-}
\ No newline at end of file
+}
--- StatList.java	Tue Jan  9 14:52:52 2018
+++ StatList.java	Fri Apr 20 22:33:15 2018
@@ -173,16 +173,9 @@
      */
     private static StatBase[] initMinableStats(String par0Str, int par1)
     {
-    	// FCMOD: Change to accomodate extended block IDs 
-    	/*
         StatBase[] var2 = new StatBase[256];
 
         for (int var3 = 0; var3 < 256; ++var3)
-        */
-        StatBase[] var2 = new StatBase[4096];
-
-        for (int var3 = 0; var3 < 4096; ++var3)
-    	// END FCMOD
         {
             if (Block.blocksList[var3] != null && Block.blocksList[var3].getEnableStats())
             {
--- StringTranslate.java	Thu Feb  8 23:40:36 2018
+++ StringTranslate.java	Fri Apr 20 22:33:15 2018
@@ -9,7 +9,6 @@
 import java.util.IllegalFormatException;
 import java.util.Properties;
 import java.util.TreeMap;
-import java.util.zip.ZipEntry;
 
 public class StringTranslate
 {
@@ -155,10 +154,6 @@
 
             this.currentLanguage = par1Str;
             this.translateTable = var3;
-
-            // FCMOD: Code added
-            FCAddOnHandler.OnLanguageLoaded( this );
-            // END FCMOD
         }
     }
 
@@ -202,49 +197,4 @@
     {
         return this.translateTable.getProperty(par1Str + ".name", "");
     }
-
-    // FCMOD
-    public Properties GetTranslateTable()
-    {
-    	return translateTable;
-    }
-    
-    public void LoadAddonLanguageExtension( String sAddonPrefix )
-    {
-    	SafeLoadLanguage( sAddonPrefix + "_" + "en_US" );
-    	
-        SafeLoadLanguage( sAddonPrefix + "_" + currentLanguage );
-    }
-    
-    private void SafeLoadLanguage( String sLanguageName )
-    {
-        if ( StringTranslate.class.getResource( "/lang/" + sLanguageName + ".lang" ) != null )
-        {
-	        try
-	        {
-	            loadLanguage( translateTable, sLanguageName );
-	        }
-	        catch ( IOException exception )
-	        {
-	            ;
-	        }
-        }
-    }
-    
-    public void DebugOutputCurrentLanguage()
-    {
-        Enumeration var4 = translateTable.propertyNames();
-
-        while ( var4.hasMoreElements() )
-        {
-            Object var5 = var4.nextElement();
-            Object var6 = translateTable.get(var5);
-
-            if (var6 != null)
-            {
-                System.out.println( var5.toString() + "=" + var6.toString() );
-            }
-        }
-    }
-    // END FCMOD
 }
--- StructureComponent.java	Sun Apr  8 18:09:16 2018
+++ StructureComponent.java	Fri Apr 20 22:33:15 2018
@@ -210,10 +210,7 @@
                 return 1;
             }
         }
-        // FCMOD: Changed
-        //else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
-        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID && par1 != FCBetterThanWolves.fcBlockDoorWood.blockID)
-    	// END FCMOD
+        else if (par1 != Block.doorWood.blockID && par1 != Block.doorIron.blockID)
         {
             if (par1 != Block.stairsCobblestone.blockID && par1 != Block.stairsWoodOak.blockID && par1 != Block.stairsNetherBrick.blockID && par1 != Block.stairsStoneBrick.blockID && par1 != Block.stairsSandStone.blockID)
             {
@@ -773,17 +770,9 @@
         int var10 = this.getYWithOffset(par5);
         int var11 = this.getZWithOffset(par4, par6);
 
-        // FCMOD: Changed
-        /*
         if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && par1World.getBlockId(var9, var10, var11) != Block.chest.blockID)
         {
             par1World.setBlock(var9, var10, var11, Block.chest.blockID, 0, 2);
-        */
-        if (par2StructureBoundingBox.isVecInside(var9, var10, var11) && 
-        	par1World.getBlockId(var9, var10, var11) != FCBetterThanWolves.fcBlockChest.blockID)
-        {
-            par1World.setBlock(var9, var10, var11, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
-        // END FCMOD
             TileEntityChest var12 = (TileEntityChest)par1World.getBlockTileEntity(var9, var10, var11);
 
             if (var12 != null)
@@ -834,10 +823,7 @@
 
         if (par2StructureBoundingBox.isVecInside(var8, var9, var10))
         {
-            // FCMOD: Changed
-            //ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
-            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, FCBetterThanWolves.fcBlockDoorWood);
-            // END FCMOD
+            ItemDoor.placeDoorBlock(par1World, var8, var9, var10, par7, Block.doorWood);
         }
     }
 }
--- TileEntity.java	Fri Jun 14 14:18:05 2013
+++ TileEntity.java	Fri Apr 20 22:33:16 2018
@@ -36,12 +36,7 @@
     /**
      * Adds a new two-way mapping between the class and its string name in both hashmaps.
      */
-    // FCMOD: Code change
-    /*
     private static void addMapping(Class par0Class, String par1Str)
-    */
-    public static void addMapping(Class par0Class, String par1Str)
-    // END FCMOD
     {
         if (nameToClassMap.containsKey(par1Str))
         {
@@ -272,19 +267,4 @@
         addMapping(TileEntityHopper.class, "Hopper");
         addMapping(TileEntityComparator.class, "Comparator");
     }
-    
-    // FCMOD: Code added
-    public static void ReplaceVanillaMapping( Class vanillaClass, Class newClass, String name )
-    {
-    	removeTileEntityMapping( vanillaClass, name );
-    	
-    	addMapping( newClass, name );
-    }
-    
-    public static void removeTileEntityMapping( Class className, String sTileEntityName )
-    {
-        nameToClassMap.remove( sTileEntityName );
-        classToNameMap.remove( className );
-    }
-    // END FCMOD
 }
--- TileEntityBeacon.java	Sun Jul  6 16:54:48 2014
+++ TileEntityBeacon.java	Fri Apr 20 22:33:16 2018
@@ -349,31 +349,4 @@
     {
         return par2ItemStack.itemID == Item.emerald.itemID || par2ItemStack.itemID == Item.diamond.itemID || par2ItemStack.itemID == Item.ingotGold.itemID || par2ItemStack.itemID == Item.ingotIron.itemID;
     }
-    
-    // FCMOD: Code added
-    protected boolean IsOn()
-    {
-    	return isBeaconActive;
-    }
-    
-    protected void SetIsOn( boolean bOn )
-    {
-    	isBeaconActive = bOn;
-    }
-    
-    protected void SetPrimaryEffect( int iEffect )
-    {
-    	primaryEffect = iEffect;
-    }
-    
-    public void setLevelsServerSafe(int par1)
-    {
-        levels = par1;
-    }
-    
-    public boolean IsHomeBeacon()
-    {
-    	return false;
-    }
-    // END FCMOD
 }
--- TileEntityFurnace.java	Sat Sep  8 13:11:55 2018
+++ TileEntityFurnace.java	Fri Apr 20 22:33:16 2018
@@ -9,10 +9,7 @@
     /**
      * The ItemStacks that hold the items currently being used in the furnace
      */
-    // FCMOD: Changed
-    //private ItemStack[] furnaceItemStacks = new ItemStack[3];
-    protected ItemStack[] furnaceItemStacks = new ItemStack[3];
-    // END FCMOD
+    private ItemStack[] furnaceItemStacks = new ItemStack[3];
 
     /** The number of ticks that the furnace will keep burning */
     public int furnaceBurnTime = 0;
@@ -157,19 +154,6 @@
         {
             this.field_94130_e = par1NBTTagCompound.getString("CustomName");
         }
-        
-        // FCMOD: Code added to track extended burn times
-        if ( par1NBTTagCompound.hasKey( "fcBurnTimeEx" ) )
-        {
-	        furnaceBurnTime = par1NBTTagCompound.getInteger( "fcBurnTimeEx" );
-	        furnaceCookTime = par1NBTTagCompound.getInteger( "fcCookTimeEx" );
-	        
-	        if ( par1NBTTagCompound.hasKey( "fcItemBurnTimeEx" ) )
-	        {
-	            currentItemBurnTime = par1NBTTagCompound.getInteger( "fcItemBurnTimeEx" );
-	        }
-        }
-        // END FCMOD
     }
 
     /**
@@ -199,12 +183,6 @@
         {
             par1NBTTagCompound.setString("CustomName", this.field_94130_e);
         }
-        
-        // FCMOD: Code added to track extended burn times
-        par1NBTTagCompound.setInteger( "fcBurnTimeEx", furnaceBurnTime );
-        par1NBTTagCompound.setInteger( "fcCookTimeEx", furnaceCookTime );
-        par1NBTTagCompound.setInteger( "fcItemBurnTimeEx", currentItemBurnTime );
-        // END FCMOD
     }
 
     /**
@@ -240,12 +218,7 @@
 
         if (!this.worldObj.isRemote)
         {
-        	// FCMOD: Code change to consume fuel regardless of whether you can smelt
-        	/*
             if (this.furnaceBurnTime == 0 && this.canSmelt())
-            */
-            if (this.furnaceBurnTime == 0)
-        	// END FCMOD
             {
                 this.currentItemBurnTime = this.furnaceBurnTime = getItemBurnTime(this.furnaceItemStacks[1]);
 
@@ -270,12 +243,7 @@
             {
                 ++this.furnaceCookTime;
 
-            	// FCMOD: Change to double burn times
-                /*
                 if (this.furnaceCookTime == 200)
-                */
-                if (this.furnaceCookTime >= GetCookTimeForCurrentItem())
-            	// END FCMOD
                 {
                     this.furnaceCookTime = 0;
                     this.smeltItem();
@@ -287,34 +255,11 @@
                 this.furnaceCookTime = 0;
             }
 
-            // FCMOD: Added
-            boolean bHasVisibleContents = furnaceItemStacks[0] != null || furnaceItemStacks[2] != null;
-            
-            FCBlockFurnace furnaceBlock = (FCBlockFurnace)Block.blocksList[worldObj.getBlockId( xCoord, yCoord, zCoord )];            
-            // END FCMOD
-            
             if (var1 != this.furnaceBurnTime > 0)
             {
                 var2 = true;
-                
-                // FCMOD: Changed
-                /*
                 BlockFurnace.updateFurnaceBlockState(this.furnaceBurnTime > 0, this.worldObj, this.xCoord, this.yCoord, this.zCoord);
-                */
-                furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
-                // END FCMOD
-            }
-            // FCMOD: Added
-            else
-            {
-            	boolean bPreviousContentsState = ( worldObj.getBlockMetadata( xCoord, yCoord, zCoord ) & 8 ) != 0;
-            	
-            	if ( bPreviousContentsState != bHasVisibleContents )
-            	{
-            		furnaceBlock.updateFurnaceBlockState( furnaceBurnTime > 0, worldObj, xCoord, yCoord, zCoord, bHasVisibleContents );
-            	}
             }
-            // END FCMOD            
         }
 
         if (var2)
@@ -326,10 +271,7 @@
     /**
      * Returns true if the furnace can smelt an item, i.e. has a source item, destination stack isn't full, etc.
      */
-    // FCMOD: Changed    
-    //private boolean canSmelt()
-    protected boolean canSmelt()
-    // END FCMOD
+    private boolean canSmelt()
     {
         if (this.furnaceItemStacks[0] == null)
         {
@@ -338,36 +280,7 @@
         else
         {
             ItemStack var1 = FurnaceRecipes.smelting().getSmeltingResult(this.furnaceItemStacks[0].getItem().itemID);
-            // FCMOD: Change to take into account variable output stack sizes
-            /*
             return var1 == null ? false : (this.furnaceItemStacks[2] == null ? true : (!this.furnaceItemStacks[2].isItemEqual(var1) ? false : (this.furnaceItemStacks[2].stackSize < this.getInventoryStackLimit() && this.furnaceItemStacks[2].stackSize < this.furnaceItemStacks[2].getMaxStackSize() ? true : this.furnaceItemStacks[2].stackSize < var1.getMaxStackSize())));
-            */
-            if ( var1 == null )
-            {
-            	return false;
-            }
-            else if ( this.furnaceItemStacks[2] == null )
-            {
-            	return true;
-            }
-            else if ( !this.furnaceItemStacks[2].isItemEqual(var1) )
-            {
-            	return false;
-            }
-            else 
-            {
-            	int iOutputStackSizeIfCooked = furnaceItemStacks[2].stackSize + var1.stackSize;
-            	
-            	if ( iOutputStackSizeIfCooked <= getInventoryStackLimit() && iOutputStackSizeIfCooked <= furnaceItemStacks[2].getMaxStackSize()  )
-            	{
-            		return true;
-            	}
-                else
-                {            	
-                	return iOutputStackSizeIfCooked <= var1.getMaxStackSize();
-                }
-            }            
-            // END FCMOD
         }
     }
 
@@ -386,12 +299,7 @@
             }
             else if (this.furnaceItemStacks[2].itemID == var1.itemID)
             {
-            	// FCMOD: Code change so that output can be greater than 1
-            	/*
                 ++this.furnaceItemStacks[2].stackSize;
-                */
-                furnaceItemStacks[2].stackSize += var1.stackSize;
-                // END FCMOD
             }
 
             --this.furnaceItemStacks[0].stackSize;
@@ -407,8 +315,6 @@
      * Returns the number of ticks that the supplied fuel item will keep the furnace burning, or 0 if the item isn't
      * fuel
      */
-    // FCMOD: Removed and replaced
-    /*
     public static int getItemBurnTime(ItemStack par0ItemStack)
     {
         if (par0ItemStack == null)
@@ -438,18 +344,13 @@
             return var2 instanceof ItemTool && ((ItemTool)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemSword && ((ItemSword)var2).getToolMaterialName().equals("WOOD") ? 200 : (var2 instanceof ItemHoe && ((ItemHoe)var2).getMaterialName().equals("WOOD") ? 200 : (var1 == Item.stick.itemID ? 100 : (var1 == Item.coal.itemID ? 1600 : (var1 == Item.bucketLava.itemID ? 20000 : (var1 == Block.sapling.blockID ? 100 : (var1 == Item.blazeRod.itemID ? 2400 : 0)))))));
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Return true if item is a fuel source (getItemBurnTime() > 0).
      */
     public static boolean isItemFuel(ItemStack par0ItemStack)
     {
-    	// FCMOD: Changed
-        //return getItemBurnTime(par0ItemStack) > 0;
-    	return par0ItemStack.getItem().GetFurnaceBurnTime( par0ItemStack.getItemDamage() ) > 0;
-    	// END FCMOD
+        return getItemBurnTime(par0ItemStack) > 0;
     }
 
     /**
@@ -497,33 +398,4 @@
     {
         return par3 != 0 || par1 != 1 || par2ItemStack.itemID == Item.bucketEmpty.itemID;
     }
-
-    // FCMOD: Added
-    public static final int m_iDefaultCookTime = 400;
-    public static final int m_iBaseBurnTimeMultiplier = 2;
-    
-    protected int GetCookTimeForCurrentItem()
-    {
-    	int iCookTimeShift = 0;
-    	
-    	if ( furnaceItemStacks[0] != null )
-    	{
-    		iCookTimeShift = FurnaceRecipes.smelting().GetCookTimeBinaryShift( 
-    			furnaceItemStacks[0].getItem().itemID );    		
-    	}
-    	
-    	return m_iDefaultCookTime << iCookTimeShift;
-    }
-    
-    public int getItemBurnTime( ItemStack stack )
-    {
-        if ( stack != null )
-        {
-        	return stack.getItem().GetFurnaceBurnTime( stack.getItemDamage() ) * 
-        		m_iBaseBurnTimeMultiplier;            
-        }
-        
-        return 0;
-    }
-    // END FCMOD
 }
--- TileEntityPiston.java	Mon Dec 10 15:06:41 2018
+++ TileEntityPiston.java	Fri Apr 20 22:33:16 2018
@@ -21,17 +21,6 @@
     private float lastProgress;
     private List pushedObjects = new ArrayList();
 
-    // FCMOD: Added
-    private boolean m_bShoveledBlock = false;
-    
-    public TileEntityPiston( int iBlockID, int iMetadata, int iFacing, boolean bExtending, boolean bShouldHeadBeRendered, boolean bShoveledBlock )
-    {
-    	this( iBlockID, iMetadata, iFacing, bExtending, bShouldHeadBeRendered );
-    	
-    	m_bShoveledBlock = true;    	
-    }
-    // END FCMOD
-
     public TileEntityPiston() {}
 
     public TileEntityPiston(int par1, int par2, int par3, boolean par4, boolean par5)
@@ -132,15 +121,6 @@
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
-            	// FCMOD: Added
-            	if ( DestroyAndDropIfShoveled() )
-            	{
-            		return;
-            	}
-            	
-            	PreBlockPlaced();
-            	// END FCMOD
-            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -158,25 +138,11 @@
         if (this.lastProgress >= 1.0F)
         {
             this.updatePushedObjects(1.0F, 0.25F);
-            
-            // FCMOD: Added
-            AttemptToPackItems();
-            // END FCMOD
-            
             this.worldObj.removeBlockTileEntity(this.xCoord, this.yCoord, this.zCoord);
             this.invalidate();
 
             if (this.worldObj.getBlockId(this.xCoord, this.yCoord, this.zCoord) == Block.pistonMoving.blockID)
             {
-            	// FCMOD: Added
-            	if ( DestroyAndDropIfShoveled() )
-            	{
-            		return;
-            	}
-            	
-            	PreBlockPlaced();
-            	// END FCMOD
-            	
                 this.worldObj.setBlock(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID, this.storedMetadata, 3);
                 this.worldObj.notifyBlockOfNeighborChange(this.xCoord, this.yCoord, this.zCoord, this.storedBlockID);
             }
@@ -208,13 +174,6 @@
         this.storedOrientation = par1NBTTagCompound.getInteger("facing");
         this.lastProgress = this.progress = par1NBTTagCompound.getFloat("progress");
         this.extending = par1NBTTagCompound.getBoolean("extending");
-
-        // FCMOD: Added
-        if ( par1NBTTagCompound.hasKey( "fcShovel" ) )
-        {
-        	m_bShoveledBlock = par1NBTTagCompound.getBoolean( "fcShovel" );
-        }
-        // END FCMOD        
     }
 
     /**
@@ -228,238 +187,5 @@
         par1NBTTagCompound.setInteger("facing", this.storedOrientation);
         par1NBTTagCompound.setFloat("progress", this.lastProgress);
         par1NBTTagCompound.setBoolean("extending", this.extending);
-        
-        // FCMOD: Added
-        par1NBTTagCompound.setBoolean( "fcShovel", m_bShoveledBlock );
-        // END FCMOD        
-    }
-    
-    // FCMOD: Added
-    private void AttemptToPackItems()
-    {
-    	if ( !worldObj.isRemote && isExtending() && ( storedBlockID == Block.pistonExtension.blockID || Block.isNormalCube( storedBlockID ) || storedBlockID == Block.glass.blockID ) )
-    	{
-	    	FCUtilsBlockPos targetPos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, storedOrientation );
-	    	
-	    	if ( IsLocationSuitableForPacking( targetPos.i, targetPos.j, targetPos.k, Block.GetOppositeFacing( storedOrientation ) ) )
-			{
-	    		AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB((double)targetPos.i, (double)targetPos.j, (double)targetPos.k, 
-	    			(double)targetPos.i + 1D, (double)targetPos.j + 1D, (double)targetPos.k + 1D );
-	    		
-	    		List itemsWithinBox = worldObj.getEntitiesWithinAABB( EntityItem.class, targetBox );
-	    		
-	    		if ( !itemsWithinBox.isEmpty() )
-	    		{
-	                Iterator itemIterator = itemsWithinBox.iterator();
-	
-	                while ( itemIterator.hasNext() )
-	                {
-	        			EntityItem tempItem = (EntityItem)itemIterator.next();
-	        			
-	        			if ( !tempItem.isDead )
-	        			{
-		        			ItemStack tempStack = tempItem.getEntityItem();
-		        			
-		        			if ( IsPackableItem( tempStack ) )
-		        			{
-		        				int iRequiredCount = GetItemCountToPack( tempStack );
-		        				int iCountOfItems = CountItemsOfTypeInList( tempStack, itemsWithinBox );
-		        				
-		        				if ( iCountOfItems >= iRequiredCount )
-		        				{
-		        					RemoveItemsOfTypeFromList( tempStack, iRequiredCount, itemsWithinBox );
-		        					
-		        					CreatePackedBlockOfTypeAtLocation( tempStack, targetPos.i, targetPos.j, targetPos.k );
-		        					
-		        					break;
-		        				}
-		        			}
-	        			}
-	                }
-	    		}
-			}
-    	}
-    }
-    
-    private boolean IsLocationSuitableForPacking( int i, int j, int k, int iPistonDirection )
-	{
-    	if ( worldObj.isAirBlock( i, j, k ) )
-    	{
-	    	for ( int iTempFacing = 0; iTempFacing < 6; iTempFacing++ )
-	    	{
-	    		if ( iTempFacing != iPistonDirection )
-	    		{
-	    			FCUtilsBlockPos tempPos = new FCUtilsBlockPos( i, j, k, iTempFacing );
-	    			
-	    			if ( !IsBlockSuitableForPackingToFacing ( tempPos.i, tempPos.j, tempPos.k, Block.GetOppositeFacing( iTempFacing ) ) )
-    				{
-	    				return false;
-    				}
-	    				
-	    		}
-	    	}
-	    	
-	    	return true;
-    	}
-    	
-    	return false;
-	}
-    
-    private boolean IsBlockSuitableForPackingToFacing( int i, int j, int k, int iFacing )
-    {
-    	Block block = Block.blocksList[worldObj.getBlockId( i, j, k )];
-    	
-    	if ( block != null )
-    	{
-    		return block.CanContainPistonPackingToFacing( worldObj, i, j, k, iFacing );
-    	}
-    	
-    	return false;    	
-    }
-    
-    private boolean IsPackableItem( ItemStack stack )
-    {
-    	return stack.getItem().IsPistonPackable( stack );    	
-    }
-    
-    private int GetItemCountToPack( ItemStack stack )
-    {
-    	return stack.getItem().GetRequiredItemCountToPistonPack( stack );
-    }
-    
-    private void CreatePackedBlockOfTypeAtLocation( ItemStack stack, int i, int j, int k )
-    {
-    	int iBlockID = stack.getItem().GetResultingBlockIDOnPistonPack( stack );;
-    	int iBlockMetadata = stack.getItem().GetResultingBlockMetadataOnPistonPack( stack );
-    	
-    	worldObj.setBlockAndMetadataWithNotify( i, j, k, iBlockID, iBlockMetadata );
-    	
-        worldObj.playAuxSFX( FCBetterThanWolves.m_iBlockPlaceAuxFXID, i, j, k, iBlockID );                            
-    }
-    
-    private int CountItemsOfTypeInList( ItemStack stack, List list )
-    {
-        Iterator itemIterator = list.iterator();
-        int iCount = 0;
-
-        while ( itemIterator.hasNext() )
-        {
-			EntityItem tempItem = (EntityItem)itemIterator.next();
-			
-			if ( !tempItem.isDead )
-			{
-				ItemStack tempStack = tempItem.getEntityItem();
-				
-				if ( tempStack.itemID == stack.itemID )
-				{
-					iCount += tempStack.stackSize;
-				}
-			}
-        }
-        
-        return iCount;
-    }
-    
-    private void RemoveItemsOfTypeFromList( ItemStack stack, int iCount, List list )
-    {
-        Iterator itemIterator = list.iterator();
-
-        while ( itemIterator.hasNext() )
-        {
-			EntityItem tempItem = (EntityItem)itemIterator.next();
-			
-			if ( !tempItem.isDead )
-			{
-				ItemStack tempStack = tempItem.getEntityItem();
-				
-				if ( tempStack.itemID == stack.itemID )
-				{
-					if ( tempStack.stackSize > iCount )
-					{
-						tempStack.stackSize -= iCount;
-						
-						break;
-					}
-					else
-					{
-						iCount -= tempStack.stackSize;
-						
-						tempStack.stackSize = 0;
-						
-						tempItem.setDead();
-						
-						if ( iCount <= 0 )
-						{
-							break;
-						}
-					}
-				}
-			}
-        }
-        
-    }
-    
-    private boolean DestroyAndDropIfShoveled()
-    {
-    	if ( m_bShoveledBlock )
-    	{
-            Block tempBlock = Block.blocksList[storedBlockID];
-            
-            if ( tempBlock != null && !worldObj.isRemote )
-            {
-            	ItemStack tempStack = null;
-            	
-	        	if ( tempBlock.canSilkHarvest( storedMetadata ) )
-	        	{
-	                tempStack = tempBlock.createStackedBlock( storedMetadata );
-	        	}
-	            else
-	            {
-	            	tempStack = new ItemStack( tempBlock.idDropped( storedMetadata, worldObj.rand, 0 ), 
-	            		tempBlock.quantityDropped( worldObj.rand ), tempBlock.damageDropped( storedMetadata ) );
-	            }
-	        	
-	        	if ( tempStack != null )
-	        	{
-	        		EjectStackOnShoveled( tempStack );
-	        	}
-            }
-        	
-            worldObj.setBlockToAir( xCoord, yCoord, zCoord );
-            worldObj.notifyBlockOfNeighborChange( xCoord, yCoord, zCoord, storedBlockID );
-            
-            return true;
-    	}
-    	
-    	return false;
-    }
-    
-    private void EjectStackOnShoveled( ItemStack stack )
-    {
-    	FCUtilsBlockPos sourcePos = new FCUtilsBlockPos( xCoord, yCoord, zCoord, Block.GetOppositeFacing( storedOrientation ) );
-    	
-    	FCUtilsItem.EjectStackFromBlockTowardsFacing( worldObj, sourcePos.i, sourcePos.j, sourcePos.k, stack, storedOrientation ); 
-    }    
-    
-    private void PreBlockPlaced()
-    {
-        Block tempBlock = Block.blocksList[storedBlockID];
-        
-        if ( tempBlock != null && !worldObj.isRemote )
-        {
-	    	storedMetadata = tempBlock.OnPreBlockPlacedByPiston( worldObj, xCoord, yCoord, zCoord, 
-	    		storedMetadata, GetDirectionMoving() );
-        }
-    }
-    
-    private int GetDirectionMoving()
-    {
-    	if ( !extending )
-    	{
-    		return Block.GetOppositeFacing( storedOrientation );
-    	}
-    	
-		return storedOrientation;
     }
-    // END FCMOD    
 }
--- TileEntitySkull.java	Fri Jun 14 14:19:20 2013
+++ TileEntitySkull.java	Fri Apr 20 22:33:16 2018
@@ -79,11 +79,4 @@
     {
         return this.extraType;
     }
-    
-    // FCMOD: Code added
-    public int GetSkullRotationServerSafe()
-    {
-    	return this.skullRotation;
-    }
-    // END FCMOD
 }
--- Vec3.java	Fri Jan  4 12:53:38 2019
+++ Vec3.java	Fri Apr 20 22:33:16 2018
@@ -60,13 +60,6 @@
         return this;
     }
 
-    // FCMOD: Added (server only) to duplicate client functionality
-    public Vec3 subtract(Vec3 par1Vec3)
-    {
-        return this.myVec3LocalPool.getVecFromPool(par1Vec3.xCoord - this.xCoord, par1Vec3.yCoord - this.yCoord, par1Vec3.zCoord - this.zCoord);
-    }    
-    // END FCMOD
-    
     /**
      * Normalizes the vector to a length of 1 (except if it is the zero vector)
      */
@@ -81,13 +74,6 @@
         return this.xCoord * par1Vec3.xCoord + this.yCoord * par1Vec3.yCoord + this.zCoord * par1Vec3.zCoord;
     }
 
-    // FCMOD: Added (server only) to duplicate client functionality
-    public Vec3 crossProduct(Vec3 par1Vec3)
-    {
-        return this.myVec3LocalPool.getVecFromPool(this.yCoord * par1Vec3.zCoord - this.zCoord * par1Vec3.yCoord, this.zCoord * par1Vec3.xCoord - this.xCoord * par1Vec3.zCoord, this.xCoord * par1Vec3.yCoord - this.yCoord * par1Vec3.xCoord);
-    }
-    // END FCMOD
-    
     /**
      * Adds the specified x,y,z vector components to this vector and returns the resulting vector. Does not change this
      * vector.
@@ -235,184 +221,4 @@
         this.yCoord = var6;
         this.zCoord = var8;
     }
-    
-    // FCMOD: Added
-    public static Vec3 createVectorHelper( Vec3 copyVector )
-    {
-        return new Vec3( fakePool, copyVector.xCoord, copyVector.yCoord, copyVector.zCoord );
-    }
-    
-	/**
-	 * Yaws the vector around the J axis. Assumes that initial facing is along the negative K axis (facing 2)
-	 */
-	public void RotateAsBlockPosAroundJToFacing( int iFacing )
-    {
-		if ( iFacing > 2 )
-		{
-	    	if ( iFacing == 5 ) // i + 1
-	    	{
-	    		double tempZ = xCoord;
-	    		
-	    		xCoord = 1D - zCoord;
-	    		zCoord = tempZ;
-	    	}
-	    	else if ( iFacing == 4 ) // i - 1
-	    	{
-	    		double tempZ = 1D - xCoord;
-	    		
-	    		xCoord = zCoord;
-	    		zCoord = tempZ;
-	    	}
-	    	else // if ( iFacing == 3 ) // k + 1
-	    	{
-	    		xCoord = 1D - xCoord;
-	    		zCoord = 1D - zCoord;
-	    	}
-		}    	
-    }
-	
-	/**
-	 * Yaws the vector around the J axis. Assumes that initial facing is along the negative K axis (facing 2)
-	 */
-	public void RotateAsVectorAroundJToFacing( int iFacing )
-    {
-		if ( iFacing > 2 )
-		{
-	    	if ( iFacing == 5 ) // i + 1
-	    	{
-	    		double tempZ = xCoord;
-	    		
-	    		xCoord = -zCoord;
-	    		zCoord = tempZ;
-	    	}
-	    	else if ( iFacing == 4 ) // i - 1
-	    	{
-	    		double tempZ = -xCoord;
-	    		
-	    		xCoord = zCoord;
-	    		zCoord = tempZ;
-	    	}
-	    	else // if ( iFacing == 3 ) // k + 1
-	    	{
-	    		xCoord = -xCoord;
-	    		zCoord = -zCoord;
-	    	}
-		}    	
-    }
-	
-	/**
-	 * "Tilts" the vector towards the desired facingas if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
-	 */	
-	public void TiltAsBlockPosToFacingAlongJ( int iFacing )
-	{
-		if ( iFacing == 0 ) // j - 1
-		{
-			// rotating around k axis here to point downwards
-			
-			yCoord = 1D - yCoord;
-			xCoord = 1D - xCoord;
-		}
-		else if ( iFacing == 2 ) // k - 1
-		{
-			double tempZ = 1D - yCoord;
-			
-			yCoord = zCoord;
-			zCoord = tempZ;
-		}			
-		else if ( iFacing == 3 ) // k + 1
-		{
-			double tempZ = yCoord;
-			
-			yCoord = 1D - zCoord;
-			zCoord = tempZ;
-		}
-		else if ( iFacing == 4 ) // i - 1
-		{
-			double tempY = xCoord;
-			
-			xCoord = 1D - yCoord;
-			yCoord = tempY;
-		}			
-		else if ( iFacing == 5 ) // i + 1
-		{
-			double tempY = 1D - xCoord;
-			
-			xCoord = yCoord;
-			yCoord = tempY;
-		}			
-	}
-	
-	/**
-	 * "Tilts" the vector towards the desired facing as if it's a local coordinate internal to a block.  Takes the up vector and either yaws or rolls it towards the specified axis.
-	 */	
-	public void TiltAsVectorToFacingAlongJ( int iFacing )
-	{
-		if ( iFacing == 0 ) // j - 1
-		{
-			// rotating around k axis here to point downwards
-			
-			yCoord = -yCoord;
-			xCoord = -xCoord;
-		}
-		else if ( iFacing == 2 ) // k - 1
-		{
-			double tempZ = -yCoord;
-			
-			yCoord = zCoord;
-			zCoord = tempZ;
-		}			
-		else if ( iFacing == 3 ) // k + 1
-		{
-			double tempZ = yCoord;
-			
-			yCoord = -zCoord;
-			zCoord = tempZ;
-		}
-		else if ( iFacing == 4 ) // i - 1
-		{
-			double tempY = xCoord;
-			
-			xCoord = -yCoord;
-			yCoord = tempY;
-		}			
-		else if ( iFacing == 5 ) // i + 1
-		{
-			double tempY = -xCoord;
-			
-			xCoord = yCoord;
-			yCoord = tempY;
-		}			
-	}
-	
-	/**
-	 * Alternate name for clarity
-	 */
-    public final Vec3 SubtractFrom( Vec3 vec )
-    {
-    	return subtract( vec );    	
-    }
-    
-    public Vec3 AddVector( Vec3 vec )
-    {
-        return myVec3LocalPool.getVecFromPool( xCoord + vec.xCoord, yCoord + vec.yCoord, zCoord + vec.zCoord );
-    }
-    
-    public void Scale( double dScale )
-    {
-    	xCoord *= dScale;
-    	yCoord *= dScale;
-    	zCoord *= dScale;
-    }
-    
-    /**
-     * Only considers the x and z components
-     */
-    public double DistanceSquareFlat( Vec3 toVec )
-    {
-        double dDeltaX = toVec.xCoord - xCoord;
-        double dDeltaZ = toVec.zCoord - zCoord;
-        
-        return dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
-    }
-    // END FCMOD
 }
--- Village.java	Fri Oct 12 17:44:01 2018
+++ Village.java	Fri Apr 20 22:33:16 2018
@@ -64,8 +64,6 @@
             this.updateNumIronGolems();
         }
 
-        // FCMOD: Code removed to get rid of spawning of iron golems
-        /*
         int var2 = this.numVillagers / 10;
 
         if (this.numIronGolems < var2 && this.villageDoorInfoList.size() > 20 && this.worldObj.rand.nextInt(7000) == 0)
@@ -80,8 +78,6 @@
                 ++this.numIronGolems;
             }
         }
-        */
-        // END FCMOD
     }
 
     /**
@@ -395,14 +391,6 @@
                 var4.resetDoorOpeningRestrictionCounter();
             }
 
-            // FCMOD: Added to prevent unintentionally loading chunks
-            if ( !worldObj.chunkExists( var4.posX >> 4, var4.posZ >> 4 ) )
-            {
-            	continue;
-            	
-            }
-            // END FCMOD
-
             if (!this.isBlockDoor(var4.posX, var4.posY, var4.posZ) || Math.abs(this.tickCounter - var4.lastActivityTimestamp) > 1200)
             {
                 this.centerHelper.posX -= var4.posX;
@@ -423,11 +411,7 @@
     private boolean isBlockDoor(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        
-        // FCMOD: Changed
-        //return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
-        return var4 <= 0 ? false : ( var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID );
-    	// END FCMOD
+        return var4 <= 0 ? false : var4 == Block.doorWood.blockID;
     }
 
     private void updateVillageRadiusAndCenter()
--- VillageCollection.java	Sun Apr  8 18:45:57 2018
+++ VillageCollection.java	Fri Apr 20 22:33:16 2018
@@ -329,11 +329,7 @@
     private boolean isWoodenDoorAt(int par1, int par2, int par3)
     {
         int var4 = this.worldObj.getBlockId(par1, par2, par3);
-        
-        // FCMOD: Changed
-        //return var4 == Block.doorWood.blockID;
-        return var4 == Block.doorWood.blockID || var4 == FCBetterThanWolves.fcBlockDoorWood.blockID;
-        // END FCMOD
+        return var4 == Block.doorWood.blockID;
     }
 
     /**
--- World.java	Tue Feb 19 17:50:31 2019
+++ World.java	Fri Apr 20 22:33:16 2018
@@ -9,10 +9,6 @@
 import java.util.Random;
 import java.util.Set;
 
-//FCMOD: Added
-import java.util.LinkedList;
-// END FCMOD
-
 public abstract class World implements IBlockAccess
 {
     /**
@@ -89,9 +85,7 @@
     public boolean findingSpawnPoint;
     public MapStorage mapStorage;
     public final VillageCollection villageCollectionObj;
-    // FCMOD: Removed
-    //protected final VillageSiege villageSiegeObj = new VillageSiege(this);
-    // END FCMOD
+    protected final VillageSiege villageSiegeObj = new VillageSiege(this);
     public final Profiler theProfiler;
 
     /** The world-local pool of vectors */
@@ -111,22 +105,7 @@
     protected boolean spawnPeacefulMobs = true;
 
     /** populated by chunks that are within 9 chunks of any player */
-    // FCMOD: Changed to use same type as ChunkProviderServer.loadedChunkHashMap, to avoid
-    // duplicate hash values.  Renamed as new type requires existing references to be adapated
-    // appropriately.
-    //protected Set activeChunkSet = new HashSet();
-    /** 
-     * populated by chunks that are within the view distance (default 8 chunks) of any player,
-     * the original spawn, or any other chunk loader
-     */
-    protected LongHashMap m_activeChunksCoordsMap = new LongHashMap();
-    
-    /** 
-     * list of same coords in m_activeChunksCoordsMap
-     */
-    protected LinkedList<ChunkCoordIntPair> m_activeChunksCoordsList = 
-    	new LinkedList<ChunkCoordIntPair>(); 
-    // END FCMOD
+    protected Set activeChunkSet = new HashSet();
 
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
@@ -167,11 +146,6 @@
 
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
     {
-        // FCMOD: Added
-    	// function tests internally to make sure this only occurs once
-        FCAddOnHandler.InitializeMods(); 
-        // END FCMOD
-    	
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int[32768];
         this.isRemote = false;
@@ -319,14 +293,7 @@
      */
     public boolean isAirBlock(int par1, int par2, int par3)
     {
-    	// FCMOD: Change
-		/*
         return this.getBlockId(par1, par2, par3) == 0;
-		*/
-    	int iBlockID = getBlockId(par1, par2, par3);
-    	
-        return iBlockID == 0 || Block.blocksList[iBlockID].IsAirBlock(); 
-        // END FCMOD
     }
 
     /**
@@ -423,10 +390,6 @@
      * cause a block update. Flag 2 will send the change to clients (you almost always want this). Flag 4 prevents the
      * block from being re-rendered, if this is a client world. Flags can be added together.
      */
-    /**
-     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
-     * Bit 4 seems to prevent a render update when called on client
-     */
     public boolean setBlock(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -524,10 +487,6 @@
      * Sets the blocks metadata and if set will then notify blocks that this block changed, depending on the flag. Args:
      * x, y, z, metadata, flag. See setBlock for flag description
      */
-    /**
-     * FCNOTE: Bit 1 notify neighbors.  Bit 2 sends change to clients.
-     * Bit 4 seems to prevent a render update when called on client
-     */
     public boolean setBlockMetadata(int par1, int par2, int par3, int par4, int par5)
     {
         if (par1 >= -30000000 && par3 >= -30000000 && par1 < 30000000 && par3 < 30000000)
@@ -1028,8 +987,6 @@
         return this.rayTraceBlocks_do_do(par1Vec3, par2Vec3, par3, false);
     }
 
-    // FCMOD: Code removed and replaced later
-    /*
     public MovingObjectPosition rayTraceBlocks_do_do(Vec3 par1Vec3, Vec3 par2Vec3, boolean par3, boolean par4)
     {
         if (!Double.isNaN(par1Vec3.xCoord) && !Double.isNaN(par1Vec3.yCoord) && !Double.isNaN(par1Vec3.zCoord))
@@ -1239,8 +1196,6 @@
             return null;
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Plays a sound at the entity's position. Args: entity, sound, volume (relative to 1.0), and frequency (or pitch,
@@ -1470,21 +1425,10 @@
         }
 
         double var14 = 0.25D;
-        // FCMOD: Line replaced. Expanded this to help with vertical collisions on Wind Mills
-		/*
         List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
-		*/
-        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, 2.0, var14));
-        // END FCMOD
 
         for (int var15 = 0; var15 < var16.size(); ++var15)
         {
-        	// FCMOD: Code added
-        	if ( !par1Entity.CanCollideWithEntity( (Entity)var16.get( var15 ) ) )
-        	{
-        		continue;
-        	}
-        	// END FCMOD
             AxisAlignedBB var13 = ((Entity)var16.get(var15)).getBoundingBox();
 
             if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
@@ -1592,10 +1536,9 @@
     {
         return this.getChunkFromBlockCoords(par1, par2).getPrecipitationHeight(par1 & 15, par2 & 15);
     }
-    
+
     /**
      * Finds the highest block on the x, z coordinate that is solid and returns its y coord. Args x, z
-     * FCNOTE: Despite name, actually returns the block ABOVE the top one, and does not count liquids
      */
     public int getTopSolidOrLiquidBlock(int par1, int par2)
     {
@@ -1695,21 +1638,6 @@
         }
 
         this.unloadedEntityList.clear();
-        // FCMOD: Code added to prevent jerkiness when one entity pushes another (like on Platforms)
-        for (int l = 0; l < loadedEntityList.size(); l++)
-        {
-            Entity tempEntity = (Entity)loadedEntityList.get(l);
-            
-            if (!tempEntity.isDead)
-            {
-            	tempEntity.lastTickPosX = tempEntity.posX;
-            	tempEntity.lastTickPosY = tempEntity.posY;
-            	tempEntity.lastTickPosZ = tempEntity.posZ;        
-            	tempEntity.prevRotationYaw = tempEntity.rotationYaw;
-            	tempEntity.prevRotationPitch = tempEntity.rotationPitch;
-            }
-        }        
-        // END FCMOD
         this.theProfiler.endStartSection("regular");
 
         for (var1 = 0; var1 < this.loadedEntityList.size(); ++var1)
@@ -1772,12 +1700,7 @@
         {
             TileEntity var9 = (TileEntity)var14.next();
 
-        	// FCCHUNK: Decide on updates around original spawn
-            // FCMOD: Changed
-            //if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
-            if ( !var9.isInvalid() && var9.func_70309_m() && 
-            	IsBlockPosActive( var9.xCoord, var9.yCoord, var9.zCoord ) )            	            	
-        	// END FCMOD
+            if (!var9.isInvalid() && var9.func_70309_m() && this.blockExists(var9.xCoord, var9.yCoord, var9.zCoord))
             {
                 try
                 {
@@ -1875,33 +1798,20 @@
     /**
      * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
      * Args: entity, forceUpdate
-     * FCNOTE: 2nd parameter is more "bOnlyUpdateInLoadedChunks" rather than what is said above
-     * The "OptionalForce" in the function name refers to forcing the update, not a physical force
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
         int var3 = MathHelper.floor_double(par1Entity.posX);
         int var4 = MathHelper.floor_double(par1Entity.posZ);
-        // FCMOD: Changed
-        //byte var5 = 32;
-        int var5 = m_iLoadedChunksUpdateRange;
-        // END FCMOD
-
-    	// FCCHUNK: Decide on updates around original spawn
-        // FCMOD: Changed
-        //if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
-        if ( !par2 || IsBlockPosActive( var3, 0, var4 ) )
-        	// END FCMOD
+        byte var5 = 32;
+
+        if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
         {
-            // FCMOD: Removed and moved to a pre-update loop elsewhere in this file
-            /*
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
             par1Entity.prevRotationYaw = par1Entity.rotationYaw;
             par1Entity.prevRotationPitch = par1Entity.rotationPitch;
-		    */
-		    // END FCMOD
 
             if (par2 && par1Entity.addedToChunk)
             {
@@ -2105,15 +2015,8 @@
     /**
      * Returns whether or not the given bounding box is on fire or not
      */
-    // FCMOD: Changed
-    //public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
-    public boolean isBoundingBoxBurning( Entity entity )
-    // END FCMOD
-    {
-    	// FCMOD: Added
-    	AxisAlignedBB par1AxisAlignedBB = entity.boundingBox.contract(0.001D, 0.001D, 0.001D);
-    	// END FCMOD
-    	
+    public boolean isBoundingBoxBurning(AxisAlignedBB par1AxisAlignedBB)
+    {
         int var2 = MathHelper.floor_double(par1AxisAlignedBB.minX);
         int var3 = MathHelper.floor_double(par1AxisAlignedBB.maxX + 1.0D);
         int var4 = MathHelper.floor_double(par1AxisAlignedBB.minY);
@@ -2129,16 +2032,9 @@
                 {
                     for (int var10 = var6; var10 < var7; ++var10)
                     {
-                        // FCMOD: Changed
-						/*
                         int var11 = this.getBlockId(var8, var9, var10);
 
                         if (var11 == Block.fire.blockID || var11 == Block.lavaMoving.blockID || var11 == Block.lavaStill.blockID)
-                        */
-                        Block block = Block.blocksList[getBlockId(var8, var9, var10)];
-                        
-                        if ( block != null && block.GetDoesFireDamageToEntities( this, var8, var9, var10, entity ) )
-                    	// END FCMOD
                         {
                             return true;
                         }
@@ -2372,12 +2268,7 @@
 
         if (this.getBlockId(par2, par3, par4) == Block.fire.blockID)
         {
-        	// FCMOD: Code change to fix fizz effect
-        	/*
             this.playAuxSFXAtEntity(par1EntityPlayer, 1004, par2, par3, par4, 0);
-            */
-            playAuxSFX( 1004, par2, par3, par4, 0);
-            // END FCMOD
             this.setBlockToAir(par2, par3, par4);
             return true;
         }
@@ -2535,19 +2426,7 @@
      */
     public boolean isBlockNormalCube(int par1, int par2, int par3)
     {
-    	// FCMOD: Changed
-        //return Block.isNormalCube(this.getBlockId(par1, par2, par3));
-    	int iBlockID = getBlockId( par1, par2, par3 );
-
-        Block block = Block.blocksList[iBlockID];
-
-        if( block != null)
-        {
-			return block.IsNormalCube( this, par1, par2, par3 );
-        }
-        
-        return false;
-        // END FCMOD
+        return Block.isNormalCube(this.getBlockId(par1, par2, par3));
     }
 
     public boolean func_85174_u(int par1, int par2, int par3)
@@ -2568,28 +2447,20 @@
     /**
      * Returns true if the block at the given coordinate has a solid (buildable) top surface.
      */
-    // FCMOD: Removed (replaced later)
-    /*
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
         Block var4 = Block.blocksList[this.getBlockId(par1, par2, par3)];
         return this.isBlockTopFacingSurfaceSolid(var4, this.getBlockMetadata(par1, par2, par3));
     }
-    */
-    // END FCMOD
 
     /**
      * Performs check to see if the block is a normal, solid block, or if the metadata of the block indicates that its
      * facing puts its solid side upwards. (inverted stairs, for example)
      */
-    // FCMOD: Removed (deprecated)
-    /*
     public boolean isBlockTopFacingSurfaceSolid(Block par1Block, int par2)
     {
         return par1Block == null ? false : (par1Block.blockMaterial.isOpaque() && par1Block.renderAsNormalBlock() ? true : (par1Block instanceof BlockStairs ? (par2 & 4) == 4 : (par1Block instanceof BlockHalfSlab ? (par2 & 8) == 8 : (par1Block instanceof BlockHopper ? true : (par1Block instanceof BlockSnow ? (par2 & 7) == 7 : false)))));
     }
-    */
-    // END FCMOD
 
     /**
      * Checks if the block is a solid, normal cube. If the chunk does not exist, or is not loaded, it returns the
@@ -2604,12 +2475,7 @@
             if (var5 != null && !var5.isEmpty())
             {
                 Block var6 = Block.blocksList[this.getBlockId(par1, par2, par3)];
-                // FCMOD: Change so that torches will stick to the appropriate blocks
-                /*
                 return var6 == null ? false : var6.blockMaterial.isOpaque() && var6.renderAsNormalBlock();
-                */
-                return ( var6 != null && isBlockNormalCube( par1, par2, par3 ) );
-                // END FCMOD                
             }
             else
             {
@@ -2640,12 +2506,7 @@
      */
     public void setAllowedSpawnTypes(boolean par1, boolean par2)
     {
-    	// FCMOD: Code change to remove peaceful difficulty.  If animals can spawn, then so can mobs
-    	/*
         this.spawnHostileMobs = par1;
-        */
-        this.spawnHostileMobs = par2;
-    	// END FCMOD
         this.spawnPeacefulMobs = par2;
     }
 
@@ -2654,15 +2515,7 @@
      */
     public void tick()
     {
-    	// FCMOD: Added
-    	UpdateActiveChunkMap();
-    	// END FCMOD
-    	
         this.updateWeather();
-        
-        // FCMOD: Added
-        ModSpecificTick();
-        // END FCMOD
     }
 
     /**
@@ -2684,8 +2537,6 @@
     /**
      * Updates all weather states.
      */
-    // FCMOD: Code removed and replaced later
-    /*
     protected void updateWeather()
     {
         if (!this.provider.hasNoSky)
@@ -2781,8 +2632,6 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     /**
      * start precipitation in this world (2 ticks after command posted)
@@ -2794,8 +2643,6 @@
 
     protected void setActivePlayerChunksAndCheckLight()
     {
-    	// FCMOD: Changed with active chunk functionality replaced elsewhere
-    	/*
         this.activeChunkSet.clear();
         this.theProfiler.startSection("buildList");
         int var1;
@@ -2820,12 +2667,6 @@
         }
 
         this.theProfiler.endSection();
-        */
-        int var1;
-        EntityPlayer var2;
-        int var3;
-        int var4;    	
-    	// END FCMOD
 
         if (this.ambientTickCountdown > 0)
         {
@@ -2978,16 +2819,10 @@
         {
             if (par2 >= 0 && par2 < 256 && this.getSavedLightValue(EnumSkyBlock.Block, par1, par2, par3) < 10)
             {
-                // FCMOD: Code change
-                /*
                 int var6 = this.getBlockId(par1, par2 - 1, par3);
                 int var7 = this.getBlockId(par1, par2, par3);
 
                 if (var7 == 0 && Block.snow.canPlaceBlockAt(this, par1, par2, par3) && var6 != 0 && var6 != Block.ice.blockID && Block.blocksList[var6].blockMaterial.blocksMovement())
-                */
-                if ( FCBlockSnowCover.CanSnowCoverReplaceBlock( this, par1, par2, par3 ) && 
-                	Block.snow.canPlaceBlockAt( this, par1, par2, par3 ) )
-            	// END FCMOD
                 {
                     return true;
                 }
@@ -3218,18 +3053,10 @@
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
         ArrayList var4 = new ArrayList();
-        // FCMOD: Change to increased size of box to be able to handle wind mills extending accross chunk boundaries
-        /*
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
-        */
-        int var5 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
-        int var6 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
-        int var7 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
-        int var8 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
-        // END FCMOD
 
         for (int var9 = var5; var9 <= var6; ++var9)
         {
@@ -3255,18 +3082,10 @@
 
     public List selectEntitiesWithinAABB(Class par1Class, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
-        // FCMOD: Increased size of box to be able to handle wind mills extending accross chunk boundaries
-    	/*
         int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
         int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
-        */
-        int var4 = MathHelper.floor_double((par2AxisAlignedBB.minX - 6.0D) / 16.0D);
-        int var5 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 6.0D) / 16.0D);
-        int var6 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 6.0D) / 16.0D);
-        int var7 = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 6.0D) / 16.0D);
-    	// END FCMOD
         ArrayList var8 = new ArrayList();
 
         for (int var9 = var4; var9 <= var5; ++var9)
@@ -3327,8 +3146,6 @@
     /**
      * Counts how many entities of an entity class exist in the world. Args: entityClass
      */
-    // FCMOD: Code removed and replaced by custom function later
-    /*
     public int countEntities(Class par1Class)
     {
         int var2 = 0;
@@ -3345,8 +3162,6 @@
 
         return var2;
     }
-    */
-    // END FCMOD
 
     /**
      * adds entities to the loaded entities list, and loads thier skins.
@@ -3390,14 +3205,7 @@
         }
         else
         {
-            // FCMOD: Change
-    		/*
             if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable()))
-            */
-            if (var10 != null && (var10 == Block.waterMoving || var10 == Block.waterStill || var10 == Block.lavaMoving || var10 == Block.lavaStill || var10 == Block.fire || var10.blockMaterial.isReplaceable() ||
-            	var10 == FCBetterThanWolves.fcBlockDetectorLogic || var10 == FCBetterThanWolves.fcBlockDetectorGlowingLogic || 
-            	var10 == FCBetterThanWolves.fcBlockFireStoked ) )
-        	// END FCMOD        	
             {
                 var10 = null;
             }
@@ -3524,22 +3332,6 @@
     {
         if (this.isBlockNormalCube(par1, par2, par3))
         {
-        	// FCMOD: Code added so solid blocks can act as power sources
-            int iBlockID = getBlockId( par1, par2, par3 );
-            
-        	if ( Block.blocksList[iBlockID].canProvidePower() )
-        	{
-        		int iPowerInput = getBlockPowerInput(par1, par2, par3);
-        		int iPowerProvided = Block.blocksList[iBlockID].isProvidingWeakPower(this, par1, par2, par3, par4);
-        		
-        		if ( iPowerInput > iPowerProvided )
-        		{
-        			return iPowerInput;
-        		}
-        		
-        		return iPowerProvided;
-        	}
-        	// END FCMOD
             return this.getBlockPowerInput(par1, par2, par3);
         }
         else
@@ -3815,15 +3607,8 @@
         return (double)this.getRainStrength(1.0F) > 0.2D;
     }
 
-    /** 
-     * FCNOTE: Terribly named.  Was actually whether a specific block is currently being rained on
-     * Deprecated through sending message to avoid modifying vanilla classes that use it
-     * while still ensuring that it isn't actually called.
-     */
     public boolean canLightningStrikeAt(int par1, int par2, int par3)
     {
-    	// FCMOD: Changed
-    	/*    	 
         if (!this.isRaining())
         {
             return false;
@@ -3841,18 +3626,6 @@
             BiomeGenBase var4 = this.getBiomeGenForCoords(par1, par3);
             return var4.getEnableSnow() ? false : var4.canSpawnLightningBolt();
         }
-        */
-    	if ( !m_bCanLightningStrikeAtMessageSent )
-    	{
-	    	FCBetterThanWolves.DebugWarning( (new StringBuilder()).
-	    		append( "Deprecated method World.canLightningStrikeAt() called.  " ).
-	    		append( "Use IsRainingAtPos() or CanLightingStrikeAtPos() instead." ).toString() );
-	    	
-	    	m_bCanLightningStrikeAtMessageSent = true;
-    	}
-    	
-    	return IsRainingAtPos( par1, par2, par3 );
-    	// END FCMOD
     }
 
     /**
@@ -3891,10 +3664,6 @@
         return this.mapStorage.getUniqueDataId(par1Str);
     }
 
-    /**
-     * FCNOTE: Sends an auxSFX to all players, regardless of distance to the effect.
-     * Good for stuff like long range wolf howls and thunder claps.  
-     */
     public void func_82739_e(int par1, int par2, int par3, int par4, int par5)
     {
         for (int var6 = 0; var6 < this.worldAccesses.size(); ++var6)
@@ -4072,1143 +3841,4 @@
     {
         return this.worldLogAgent;
     }
-
-    // FCMOD: Added New
-    private boolean m_bCanLightningStrikeAtMessageSent = false;
-    
-    private long m_lTimeOfLastSquidPossessionCapCount = -1;
-    private int m_iLastSquidPossessionCapCount = 0;
-    
-    public static final int m_iLoadedChunksUpdateRange = 32;
-
-    static public boolean InstallationIntegrityTest()
-    {
-    	return true;
-    }
-
-    public void ModSpecificTick()
-    {
-    }
-    
-    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
-    {   
-        return false;
-    }
-    
-    /** 
-     * Wrapper function for clarity: while ticks are being processed they are not still scheduled,
-     * but are in a separate list for this tick.
-     */
-    public boolean IsUpdatePendingThisTickForBlock( int i, int j, int k, int iBlockID )
-    {   
-        return isBlockTickScheduled( i, j, k, iBlockID );
-    }
-    
-    public boolean setBlockAndMetadataWithNotify( int i, int j, int k, int iBlockID, int iMetadata )
-    {
-        return this.setBlock( i, j, k, iBlockID, iMetadata, 3 );
-    }
-
-    public boolean setBlockWithNotify( int i, int j, int k, int iBlockID )
-    {
-        return this.setBlock( i, j, k, iBlockID, 0, 3 );
-    }
-    
-    /**
-	 * Alias to avoid inconsistent naming between client and server
-     * Bit 1 notify neighbors.  Bit 2 sends change to clients.
-     * Bit 4 seems to prevent a render update when called on client
-     */
-    public boolean SetBlockMetadataWithNotify( int i, int j, int k, int iMetadata, int iNotifyBitField )
-    {
-    	// client
-        //return setBlockMetadataWithNotify( i, j, k, iMetadata, iNotifyBitField );
-    	// server
-        return setBlockMetadata( i, j, k, iMetadata, iNotifyBitField );
-    }
-    
-    public boolean setBlockMetadata( int i, int j, int k, int iMetadata )
-    {
-        return this.setBlockMetadata( i, j, k, iMetadata, 0 );
-    }
-
-    public boolean setBlockMetadataWithNotify( int i, int j, int k, int iMetadata )
-    {
-        return this.setBlockMetadata( i, j, k, iMetadata, 3 );
-    }
-    
-    public boolean setBlockMetadataWithClient( int i, int j, int k, int iMetadata )
-    {
-        return this.setBlockMetadata( i, j, k, iMetadata, 2 );
-    }
-    
-    public boolean setBlockMetadataWithNotifyNoClient( int i, int j, int k, int iMetadata )
-    {
-        return this.setBlockMetadata( i, j, k, iMetadata, 1 );
-    }
-    
-    public boolean setBlockAndMetadata( int i, int j, int k, int iBlockID, int iMetadata )
-    {
-        return this.setBlock( i, j, k, iBlockID, iMetadata, 2 );
-    }
-    
-    public boolean isBlockGettingPowered( int i, int j, int k )
-    {
-    	return getBlockPowerInput( i, j, k ) > 0;
-    }
-
-    
-    public MovingObjectPosition rayTraceBlocks_do_do( Vec3 startVec, Vec3 endVec, boolean bHitFluidSources, boolean bIgnoreNonMovementBlockingBlocks )
-    {
-    	// refactored version of vanilla function to try to optimize and correct errors
-    	
-        if ( !Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord) &&
-        	!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord) )
-        {
-        	Vec3 currentVec = getWorldVec3Pool().getVecFromPool( startVec.xCoord, startVec.yCoord, startVec.zCoord );
-        	
-        	double dTotalDeltaX = endVec.xCoord - startVec.xCoord;
-        	double dTotalDeltaY = endVec.yCoord - startVec.yCoord;
-        	double dTotalDeltaZ = endVec.zCoord - startVec.zCoord;
-        	
-            int iEndPosI = MathHelper.floor_double(endVec.xCoord);
-            int iEndPosJ = MathHelper.floor_double(endVec.yCoord);
-            int iEndPosK = MathHelper.floor_double(endVec.zCoord);
-            
-            int iCurrentPosI = MathHelper.floor_double(currentVec.xCoord);
-            int iCurrentPosJ = MathHelper.floor_double(currentVec.yCoord);
-            int iCurrentPosK = MathHelper.floor_double(currentVec.zCoord);
-            
-            double dProportionOfLengthToNextBlockBoundaryX;
-            double dProportionOfLengthToNextBlockBoundaryY;
-            double dProportionOfLengthToNextBlockBoundaryZ;
-            
-        	int iAxisFinishedCount = 0;
-        	
-        	int iIncrementI = -1;
-        	
-        	double dNextBlockBoundaryX = (double)iCurrentPosI;
-        	double dBlockBoundaryIncrementX = -1D; 
-        	
-        	if ( iEndPosI > iCurrentPosI )
-        	{
-        		iIncrementI = 1;
-        		
-            	dNextBlockBoundaryX += 1D;
-            	dBlockBoundaryIncrementX = 1D;                	
-        	}
-        	else if ( iEndPosI == iCurrentPosI )
-        	{
-        		iIncrementI = 0;
-        		
-        		iAxisFinishedCount++;
-        	}
-        	
-        	int iIncrementJ = -1;
-        	
-        	double dNextBlockBoundaryY = (double)iCurrentPosJ;
-        	double dBlockBoundaryIncrementY = -1D;
-        	
-        	if ( iEndPosJ > iCurrentPosJ )
-        	{
-        		iIncrementJ = 1;
-        		
-            	dNextBlockBoundaryY += 1D;
-            	dBlockBoundaryIncrementY = 1D; 
-        	}
-        	else if ( iEndPosJ == iCurrentPosJ )
-        	{
-        		iIncrementJ = 0;
-        		
-        		iAxisFinishedCount++;
-        	}
-        	
-        	int iIncrementK = -1;
-        	
-        	double dNextBlockBoundaryZ = (double)iCurrentPosK;
-        	double dBlockBoundaryIncrementZ = -1D;
-        	
-        	if ( iEndPosK > iCurrentPosK )
-        	{
-        		iIncrementK = 1;
-        		
-            	dNextBlockBoundaryZ += 1D;
-            	dBlockBoundaryIncrementZ = 1D; 
-        	}
-        	else if ( iEndPosK == iCurrentPosK )
-        	{
-        		iIncrementK = 0;
-        		
-        		iAxisFinishedCount++;
-        	}
-        	
-            int iTempCount = 200;
-
-            while ( iTempCount-- >= 0 )
-            {                    
-                int iCurrentBlockID = getBlockId( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
-                
-                if ( iCurrentBlockID > 0 )
-                {
-                    Block currentBlock = Block.blocksList[iCurrentBlockID];
-
-	                if ( !bIgnoreNonMovementBlockingBlocks || currentBlock.getCollisionBoundingBoxFromPool(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK ) != null )
-	                {
-	                    int iFirstBlockMetadata = getBlockMetadata( iCurrentPosI, iCurrentPosJ, iCurrentPosK );
-	                    
-	                	if (  currentBlock.canCollideCheck( iFirstBlockMetadata, bHitFluidSources ) )
-	                	{
-		                    MovingObjectPosition collisionPosition = currentBlock.collisionRayTrace(this, iCurrentPosI, iCurrentPosJ, iCurrentPosK, currentVec, endVec);
-		
-		                    if ( collisionPosition != null )
-		                    {
-		                        return collisionPosition;
-		                    }
-	                	}
-	                }
-                }
-
-                if ( iAxisFinishedCount >= 3 )
-                {
-                    return null;
-                }
-                
-                if ( iIncrementI != 0 )
-                {
-                    dProportionOfLengthToNextBlockBoundaryX = ( dNextBlockBoundaryX - currentVec.xCoord ) / dTotalDeltaX;                        
-                }
-                else
-                {
-                	dProportionOfLengthToNextBlockBoundaryX = 999.0D;
-                }
-                
-                
-                if ( iIncrementJ != 0 )
-                {
-                    dProportionOfLengthToNextBlockBoundaryY = ( dNextBlockBoundaryY - currentVec.yCoord ) / dTotalDeltaY;                        
-                }
-                else
-                {
-                	dProportionOfLengthToNextBlockBoundaryY = 999.0D;
-                }
-                
-                
-                if ( iIncrementK != 0 )
-                {
-                    dProportionOfLengthToNextBlockBoundaryZ = ( dNextBlockBoundaryZ - currentVec.zCoord ) / dTotalDeltaZ;                        
-                }
-                else
-                {
-                	dProportionOfLengthToNextBlockBoundaryZ = 999.0D;
-                }
-                
-                if ( dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryY && 
-                	dProportionOfLengthToNextBlockBoundaryX < dProportionOfLengthToNextBlockBoundaryZ )
-                {
-                    currentVec.xCoord = dNextBlockBoundaryX;
-                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryX;
-                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryX;
-                    
-                    iCurrentPosI += iIncrementI;
-                	dNextBlockBoundaryX += dBlockBoundaryIncrementX;
-                    
-                    if ( iCurrentPosI == iEndPosI )
-                    {
-                    	iAxisFinishedCount++;
-                    	iIncrementI = 0;
-                    }
-                    
-                }
-                else if (dProportionOfLengthToNextBlockBoundaryY < dProportionOfLengthToNextBlockBoundaryZ)
-                {
-                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryY;
-                    currentVec.yCoord = dNextBlockBoundaryY;
-                    currentVec.zCoord += dTotalDeltaZ * dProportionOfLengthToNextBlockBoundaryY;
-                    
-                    iCurrentPosJ += iIncrementJ;
-                	dNextBlockBoundaryY += dBlockBoundaryIncrementY;
-                    
-                    if ( iCurrentPosJ == iEndPosJ )
-                    {
-                    	iAxisFinishedCount++;
-                    	iIncrementJ = 0;
-                    }                        
-                }
-                else
-                {
-                    currentVec.xCoord += dTotalDeltaX * dProportionOfLengthToNextBlockBoundaryZ;
-                    currentVec.yCoord += dTotalDeltaY * dProportionOfLengthToNextBlockBoundaryZ;
-                    currentVec.zCoord = dNextBlockBoundaryZ;
-                    
-                    iCurrentPosK += iIncrementK;
-                	dNextBlockBoundaryZ += dBlockBoundaryIncrementZ;
-                	
-                    if ( iCurrentPosK == iEndPosK )
-                    {
-                    	iAxisFinishedCount++;
-                    	iIncrementK = 0;
-                    }                        
-                }
-            }
-        }
-        
-        return null;
-    }
-    
-    public MovingObjectPosition MouseOverRayTrace( Vec3 startVec, Vec3 endVec )
-    {
-        if (!Double.isNaN(startVec.xCoord) && !Double.isNaN(startVec.yCoord) && !Double.isNaN(startVec.zCoord))
-        {
-            if (!Double.isNaN(endVec.xCoord) && !Double.isNaN(endVec.yCoord) && !Double.isNaN(endVec.zCoord))
-            {
-                int iEndI = MathHelper.floor_double(endVec.xCoord);
-                int iEndJ = MathHelper.floor_double(endVec.yCoord);
-                int iEndK = MathHelper.floor_double(endVec.zCoord);
-                int iTempI = MathHelper.floor_double(startVec.xCoord);
-                int iTempJ = MathHelper.floor_double(startVec.yCoord);
-                int iTempK = MathHelper.floor_double(startVec.zCoord);
-                
-                MovingObjectPosition tempCollisionPos = 
-                	CheckLocationForMouseOverRayTrace( iTempI, iTempJ, iTempK,
-            		startVec, endVec );
-                
-                if ( tempCollisionPos != null )
-                {
-                	return tempCollisionPos;
-                }                    
-
-                int iTempCount = 200;
-
-                while (iTempCount-- >= 0)
-                {
-                    if (Double.isNaN(startVec.xCoord) || Double.isNaN(startVec.yCoord) || Double.isNaN(startVec.zCoord))
-                    {
-                        return null;
-                    }
-
-                    if (iTempI == iEndI && iTempJ == iEndJ && iTempK == iEndK)
-                    {
-                        return null;
-                    }
-
-                    boolean var39 = true;
-                    boolean var40 = true;
-                    boolean var41 = true;
-                    double var15 = 999.0D;
-                    double var17 = 999.0D;
-                    double var19 = 999.0D;
-
-                    if (iEndI > iTempI)
-                    {
-                        var15 = (double)iTempI + 1.0D;
-                    }
-                    else if (iEndI < iTempI)
-                    {
-                        var15 = (double)iTempI + 0.0D;
-                    }
-                    else
-                    {
-                        var39 = false;
-                    }
-
-                    if (iEndJ > iTempJ)
-                    {
-                        var17 = (double)iTempJ + 1.0D;
-                    }
-                    else if (iEndJ < iTempJ)
-                    {
-                        var17 = (double)iTempJ + 0.0D;
-                    }
-                    else
-                    {
-                        var40 = false;
-                    }
-
-                    if (iEndK > iTempK)
-                    {
-                        var19 = (double)iTempK + 1.0D;
-                    }
-                    else if (iEndK < iTempK)
-                    {
-                        var19 = (double)iTempK + 0.0D;
-                    }
-                    else
-                    {
-                        var41 = false;
-                    }
-
-                    double var21 = 999.0D;
-                    double var23 = 999.0D;
-                    double var25 = 999.0D;
-                    double var27 = endVec.xCoord - startVec.xCoord;
-                    double var29 = endVec.yCoord - startVec.yCoord;
-                    double var31 = endVec.zCoord - startVec.zCoord;
-
-                    if (var39)
-                    {
-                        var21 = (var15 - startVec.xCoord) / var27;
-                    }
-
-                    if (var40)
-                    {
-                        var23 = (var17 - startVec.yCoord) / var29;
-                    }
-
-                    if (var41)
-                    {
-                        var25 = (var19 - startVec.zCoord) / var31;
-                    }
-
-                    boolean var33 = false;
-                    byte var42;
-
-                    if (var21 < var23 && var21 < var25)
-                    {
-                        if (iEndI > iTempI)
-                        {
-                            var42 = 4;
-                        }
-                        else
-                        {
-                            var42 = 5;
-                        }
-
-                        startVec.xCoord = var15;
-                        startVec.yCoord += var29 * var21;
-                        startVec.zCoord += var31 * var21;
-                    }
-                    else if (var23 < var25)
-                    {
-                        if (iEndJ > iTempJ)
-                        {
-                            var42 = 0;
-                        }
-                        else
-                        {
-                            var42 = 1;
-                        }
-
-                        startVec.xCoord += var27 * var23;
-                        startVec.yCoord = var17;
-                        startVec.zCoord += var31 * var23;
-                    }
-                    else
-                    {
-                        if (iEndK > iTempK)
-                        {
-                            var42 = 2;
-                        }
-                        else
-                        {
-                            var42 = 3;
-                        }
-
-                        startVec.xCoord += var27 * var25;
-                        startVec.yCoord += var29 * var25;
-                        startVec.zCoord = var19;
-                    }
-
-                    Vec3 var34 = this.getWorldVec3Pool().getVecFromPool(startVec.xCoord, startVec.yCoord, startVec.zCoord);
-                    iTempI = (int)(var34.xCoord = (double)MathHelper.floor_double(startVec.xCoord));
-
-                    if (var42 == 5)
-                    {
-                        --iTempI;
-                        ++var34.xCoord;
-                    }
-
-                    iTempJ = (int)(var34.yCoord = (double)MathHelper.floor_double(startVec.yCoord));
-
-                    if (var42 == 1)
-                    {
-                        --iTempJ;
-                        ++var34.yCoord;
-                    }
-
-                    iTempK = (int)(var34.zCoord = (double)MathHelper.floor_double(startVec.zCoord));
-
-                    if (var42 == 3)
-                    {
-                        --iTempK;
-                        ++var34.zCoord;
-                    }
-
-                    tempCollisionPos = CheckLocationForMouseOverRayTrace( 
-                    	iTempI, iTempJ, iTempK, startVec, endVec );
-                    
-                    if ( tempCollisionPos != null )
-                    {
-                    	return tempCollisionPos;
-                    }                    
-                }
-            }
-        }
-        
-        return null;
-    }
-    
-    public MovingObjectPosition CheckLocationForMouseOverRayTrace( int i, 
-    	int j, int k, Vec3 startVec, Vec3 endVec )
-    {
-    	MovingObjectPosition closestPos = null;
-    	double dClosestDistSq = 0D;
-    	
-    	for ( int iTempJ = j - 1; iTempJ <= j + 1; iTempJ++ )
-    	{
-            int iTempBlockID = getBlockId( i, iTempJ, k );
-
-            if ( iTempBlockID > 0 )
-            {
-                int iTempMetadata = getBlockMetadata( i, iTempJ, k );                    
-                Block tempBlock = Block.blocksList[iTempBlockID];
-
-                if ( tempBlock.canCollideCheck( iTempMetadata, false ) )
-                {
-                    MovingObjectPosition tempCollisionPos = tempBlock.MouseOverRayTrace( 
-                    	this, i, iTempJ, k, startVec, endVec);
-                    
-                    if ( tempCollisionPos != null )
-                    {
-                    	double tempDistSq = tempCollisionPos.hitVec.squareDistanceTo( startVec );
-                    	
-                    	if ( closestPos == null || tempDistSq < dClosestDistSq )
-                    	{
-                    		dClosestDistSq = tempDistSq;
-                    		
-                    		closestPos = tempCollisionPos;
-                    	} 
-                    }
-                }
-            }
-    	}
-    	
-    	return closestPos;
-    }
-    
-    public void playSound(double par1, double par3, double par5, String par7Str, float par8, float par9 ) 
-    {
-        playSound( par1, par3, par5, par7Str, par8, par9, false );    	
-    }
-    
-    public Entity GetClosestEntityMatchingCriteriaWithinRange( double dSourcePosX, double dSourcePosY, double dSourcePosZ, double dRange, FCClosestEntitySelectionCriteria criteria )
-    {
-		int iChunkEntityListMinVerticalIndex = MathHelper.floor_double( ( dSourcePosY - dRange ) / 16.0D );
-		int iChunkEntityListMaxVerticalIndex = MathHelper.floor_double( ( dSourcePosY + dRange ) / 16.0D ) + 1;
-		
-		if ( iChunkEntityListMinVerticalIndex < 0 )
-		{
-			iChunkEntityListMinVerticalIndex = 0;
-			iChunkEntityListMaxVerticalIndex = Math.max( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
-		}
-		
-		if ( iChunkEntityListMaxVerticalIndex > 15 )
-		{
-			iChunkEntityListMaxVerticalIndex = 15;
-			iChunkEntityListMinVerticalIndex = Math.min( iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );			
-		}
-		
-    	FCClosestEntityInfo closestEntityInfo = 
-    		new FCClosestEntityInfo( dSourcePosX, dSourcePosY, dSourcePosZ, dRange * dRange, null, criteria, iChunkEntityListMinVerticalIndex, iChunkEntityListMaxVerticalIndex );
-    	
-        int iMinChunkX = MathHelper.floor_double( ( dSourcePosX - dRange ) / 16D  );
-        int iMaxChunkX = MathHelper.floor_double( ( dSourcePosX + dRange ) / 16D  ) + 1;
-        int iMinChunkZ = MathHelper.floor_double( ( dSourcePosZ - dRange ) / 16D  );
-        int iMaxChunkZ = MathHelper.floor_double( ( dSourcePosZ + dRange ) / 16D  ) + 1;
-        
-        for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
-        {
-            for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
-            {
-                if ( chunkExists( iTempChunkX, iTempChunkZ ) )
-                {
-                    getChunkFromChunkCoords( iTempChunkX, iTempChunkZ ).GetClosestEntityMatchingCriteriaWithinRangeSq( closestEntityInfo );
-                }
-            }
-        }
-
-        return closestEntityInfo.m_closestEntity;
-    }
-    
-    public int CountEntitiesThatApplyToSpawnCap( Class classToCount )
-    {
-    	// replacement for CountEntities that is slightly optimized
-    	
-        int iEntityCount = 0;
-
-        for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
-        {
-            Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
-
-            if ( tempEntity.DoesEntityApplyToSpawnCap() && classToCount.isAssignableFrom( tempEntity.getClass() ) )
-            {
-            	// verify that the entity is actually active
-            	
-            	++iEntityCount;
-            }
-        }
-
-        return iEntityCount;
-    }
-    
-    public int GetNumEntitiesThatApplyToSquidPossessionCap()
-    {
-    	long lCurrentTime = getWorldTime();
-    	
-    	if ( lCurrentTime != m_lTimeOfLastSquidPossessionCapCount )
-    	{
-    		m_iLastSquidPossessionCapCount = 0;
-    		m_lTimeOfLastSquidPossessionCapCount = lCurrentTime;
-    		
-            for ( int iTempEntityIndex = 0; iTempEntityIndex < this.loadedEntityList.size(); ++iTempEntityIndex )
-            {
-                Entity tempEntity = (Entity)this.loadedEntityList.get(iTempEntityIndex);
-
-                if ( tempEntity.DoesEntityApplyToSquidPossessionCap() )
-                {
-                	m_iLastSquidPossessionCapCount++;
-                }
-            }            
-    	}
-    	
-		return m_iLastSquidPossessionCapCount;
-    }
-
-	public void NotifyNearbyAnimalsOfPlayerBlockAddOrRemove( EntityPlayer player, Block block, int i, int j, int k )
-	{
-		if ( !isRemote && block.blockMaterial.blocksMovement() && !player.capabilities.isCreativeMode )
-		{
-			double dXBlock = (double)i + 0.5D;
-			double dYBlock = (double)j + 0.5D;
-			double dZBlock = (double)k + 0.5D;
-			
-			AxisAlignedBB targetBox = AxisAlignedBB.getAABBPool().getAABB( dXBlock - 8D, dYBlock - 4D, dZBlock - 8D, dXBlock + 8D, dYBlock + 4D, dZBlock + 8D );
-			
-	        List animalList = this.getEntitiesWithinAABB( EntityAnimal.class, targetBox );
-	        
-	        Iterator animalIterator = animalList.iterator();
-	
-	        while ( animalIterator.hasNext())
-	        {
-	    		EntityAnimal tempAnimal = (EntityAnimal)animalIterator.next();
-	    		
-		        if ( !tempAnimal.isLivingDead )
-		        {
-		        	tempAnimal.OnNearbyPlayerBlockAddOrRemove( player ); 
-		        }		        
-	        }
-		}
-	}
-	
-    public int GetBlockNaturalLightValue( int i, int j, int k )
-    {
-        return GetBlockNaturalLightValue_do( i, j, k, true, skylightSubtracted );
-    }
-
-    public int GetBlockNaturalLightValueMaximum( int i, int j, int k )
-    {
-        return GetBlockNaturalLightValue_do( i, j, k, true, 0 );
-    }
-
-    public float GetNaturalLightBrightness( int i, int j, int k )
-    {
-        return provider.lightBrightnessTable[GetBlockNaturalLightValue(i, j, k)];
-    }
-
-    private int GetBlockNaturalLightValue_do( int i, int j, int k, boolean bConsiderNeighbors, int iSkylightToSubtract )
-    {
-    	// Version of getBlockLightValue_do modified to only consider natural light    	
-        if ( i >= -30000000 && k >= -30000000 && i < 30000000 && k < 30000000 )
-        {
-            if ( bConsiderNeighbors )
-            {
-                int iBlockID = getBlockId( i, j, k );
-
-                if ( Block.useNeighborBrightness[iBlockID] )
-                {
-                    int iNeighbor1 = GetBlockNaturalLightValue_do( i, j + 1, k, false, iSkylightToSubtract );
-                    int iNeighbor2 = GetBlockNaturalLightValue_do( i + 1, j, k, false, iSkylightToSubtract );
-                    int iNeighbor3 = GetBlockNaturalLightValue_do( i - 1, j, k, false, iSkylightToSubtract );
-                    int iNeighbor4 = GetBlockNaturalLightValue_do( i, j, k + 1, false, iSkylightToSubtract );
-                    int iNeighbor5 = GetBlockNaturalLightValue_do( i, j, k - 1, false, iSkylightToSubtract );
-
-                    if (iNeighbor2 > iNeighbor1)
-                    {
-                        iNeighbor1 = iNeighbor2;
-                    }
-
-                    if (iNeighbor3 > iNeighbor1)
-                    {
-                        iNeighbor1 = iNeighbor3;
-                    }
-
-                    if (iNeighbor4 > iNeighbor1)
-                    {
-                        iNeighbor1 = iNeighbor4;
-                    }
-
-                    if (iNeighbor5 > iNeighbor1)
-                    {
-                        iNeighbor1 = iNeighbor5;
-                    }
-
-                    return iNeighbor1;
-                }
-            }
-
-            if (j < 0)
-            {
-                return 0;
-            }
-            else
-            {
-                if (j >= 256)
-                {
-                    j = 255;
-                }
-
-                Chunk chunk = this.getChunkFromChunkCoords(i >> 4, k >> 4);
-                
-                i &= 15;
-                k &= 15;
-                
-                return chunk.GetBlockNaturalLightValue( i, j, k, iSkylightToSubtract );
-            }
-        }
-        else
-        {
-            return 15;
-        }
-    }
-    
-    // @Override // client only override
-    public boolean doesBlockHaveSolidTopSurface( int i, int j, int k )
-    {
-        Block block = Block.blocksList[this.getBlockId(i, j, k)];
-        
-        return block != null && block.HasLargeCenterHardPointToFacing( this, i, j, k, 1 );
-    }
-    
-    //------------- Hardcore of Darkness Handling ------------//    
-    
-    static private double[] m_dMoonBrightnessByPhase = new double[] { 1.25D, 0.875, 0.75D, 0.5D, 0D, 0.5D, 0.75D, 1.25D }; 
-	
-    public float ComputeOverworldSunBrightnessWithMoonPhases()
-    {
-		// slight modified version of regular moon phase equation so that phase switches over at noon to avoid sudden jump in lighting at dawn
-		long lOffsetWorldTime = worldInfo.getWorldTime() - 12000L;
-		
-		if ( lOffsetWorldTime < 0L )
-		{
-			lOffsetWorldTime = 0L;
-		}
-		
-		int iMoonPhase = (int)( ( lOffsetWorldTime / 24000L ) % 8L );		
-		double dMoonBrightness = m_dMoonBrightnessByPhase[iMoonPhase];
-		
-        float fCelestialAngle = getCelestialAngle( 1F );
-        
-        // slight modifcation from vanilla calc so that gloom starts to set in on moonless nights the moment the sun drops beneath the horizon, and is removed at the moment of rise
-        //float fSunInvertedBrightness = 1.0F - (MathHelper.cos(fCelestialAngle * (float)Math.PI * 2.0F) * 2.0F + 0.2F);
-        float fSunInvertedBrightness = 1.0F - ( ( MathHelper.cos( fCelestialAngle * (float)Math.PI * 2.0F ) * 2.0F ) + 0.25F );
-
-        if ( fSunInvertedBrightness < 0.0F)
-        {
-        	fSunInvertedBrightness = 0.0F;
-        }
-        else if ( fSunInvertedBrightness > 1.0F)
-        {
-        	fSunInvertedBrightness = 1.0F;
-        }
-
-        double dSunBrightness = 1.0D - fSunInvertedBrightness;
-        
-        double dRainBrightnessModifier = ( 1.0D - (double)( getRainStrength( 1F ) * 5.0F ) / 16.0D );
-        double dStormBrightnessModifier = ( 1.0D - (double)( getWeightedThunderStrength( 1F ) * 5.0F ) / 16.0D );
-        
-        dSunBrightness = dSunBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
-
-        double dMinBrightness = 0.2D;
-        
-        dMinBrightness *= dMoonBrightness * dRainBrightnessModifier * dStormBrightnessModifier;
-        
-        // clamp at a value that causes the world to descend into gloom on a new moon during a storm
-        if ( dMinBrightness < 0.05D )
-        {
-        	dMinBrightness = 0D;
-        }            
-    	
-        return (float)( dSunBrightness * ( 1D - dMinBrightness ) + dMinBrightness );
-    }
-    
-    public boolean IsTheEndNigh()
-    {
-    	return false;
-    }
-    
-    //------------- Magnetic Point Handling ------------//
-    
-    protected FCMagneticPointList m_MagneticPointList = new FCMagneticPointList();
-    
-    public FCMagneticPointList GetMagneticPointList()
-    {
-    	return m_MagneticPointList;
-    }
-    
-    //------------- Ender Chest Handling ------------//
-    
-    protected InventoryEnderChest m_localEnderChestInventory = new InventoryEnderChest();
-    protected InventoryEnderChest m_localLowPowerEnderChestInventory = new InventoryEnderChest();
-    
-    public InventoryEnderChest GetLocalEnderChestInventory()
-    {
-    	return m_localEnderChestInventory;
-    }
-    
-    public InventoryEnderChest GetLocalLowPowerEnderChestInventory()
-    {
-    	return m_localLowPowerEnderChestInventory;
-    }
-    
-    //------------- Looting Beacon Handling ------------//
-    
-    protected FCBeaconEffectLocationList m_LootingBeaconLocationList = new FCBeaconEffectLocationList();
-    
-    public FCBeaconEffectLocationList GetLootingBeaconLocationList()
-    {
-    	return m_LootingBeaconLocationList;
-    }
-    
-    public int GetAmbientLootingEffectAtLocation( int iLocI, int iLocJ, int iLocK )
-    {
-    	return m_LootingBeaconLocationList.GetMostPowerfulBeaconEffectForLocation( iLocI, iLocK );
-    }
-    
-    //------------- Spawn Location Handling ------------//
-    
-    protected FCSpawnLocationList m_SpawnLocationList = new FCSpawnLocationList();
-    
-    public FCSpawnLocationList GetSpawnLocationList()
-    {
-    	return m_SpawnLocationList;
-    }    
-    
-    //------------- Explosion Handling ------------//
-    
-    /**
-     * Copy of newExplosion() that suppresses the audio/visual effects
-     */
-    public Explosion NewExplosionNoFX( Entity par1Entity, double dPosX, double dPosY, double dPosZ, 
-    	float fExplosionSize, boolean bCreatesFlames, boolean bDestroysBlocks )
-    {
-        Explosion explosion = new Explosion( this, par1Entity, dPosX, dPosY, dPosZ, fExplosionSize );
-        
-        explosion.isFlaming = bCreatesFlames;
-        explosion.isSmoking = bDestroysBlocks;
-        explosion.m_bSuppressFX = true;
-        
-        explosion.doExplosionA();
-        explosion.doExplosionB( false ); // false tells individual block destruction effects not to play
-        
-        return explosion;
-    }
-    
-    //------------- "View Distance" / Chunk Update Handling ------------//
-    
-    /** 
-     * The "view distance" is actually the range at which chunks are loaded, specified as 
-     * a vanilla server parameter (default is 10 chunks). 
-     */
-    public int GetClampedViewDistanceInChunks()
-    {
-    	return 10;
-    }
-    
-    public int GetMobSpawnRangeInChunks()
-    {
-    	return GetClampedViewDistanceInChunks() - 2;
-    }
-    
-    /** 
-     * "Active" chunks handle stuff like random block updates (grass growing, etc.)
-     * and precipitation
-     */
-    public int GetActiveChunkRangeInChunks()
-    {
-    	int iRange = GetClampedViewDistanceInChunks() - 3;
-    	
-    	if ( iRange < 1 )
-    	{
-    		iRange = 1;
-    	}
-    	
-    	return iRange;
-    }
-    
-    protected void UpdateActiveChunkMap()
-    {
-    	ClearActiveChunkMap();
-    	
-        for ( int iTempIndex = 0; iTempIndex < playerEntities.size(); ++iTempIndex )
-        {
-            EntityPlayer tempPlayer = (EntityPlayer)playerEntities.get( iTempIndex );
-            
-            AddEntityToActiveChunkMap( tempPlayer );
-        }
-    }
-    
-    protected void AddEntityToActiveChunkMap( Entity entity )
-    {
-        int iChunkX = MathHelper.floor_double( entity.posX / 16D );
-        int iChunkZ = MathHelper.floor_double( entity.posZ / 16D );
-        
-        AddAreaAroundChunkToActiveChunkMap( iChunkX, iChunkZ );
-    }
-    
-    protected void AddAreaAroundChunkToActiveChunkMap( int iChunkX, int iChunkZ )
-    {
-        int iActiveRange = GetActiveChunkRangeInChunks();
-        
-        for ( int iTempChunkX = iChunkX - iActiveRange; 
-        	iTempChunkX <= iChunkX + iActiveRange; iTempChunkX++ )
-        {
-            for ( int iTempChunkZ = iChunkZ - iActiveRange; 
-            	iTempChunkZ <= iChunkZ + iActiveRange; iTempChunkZ++ )
-            {
-            	AddToActiveChunkMap( iTempChunkX, iTempChunkZ );
-            }
-        }
-    }
-    
-    protected void ClearActiveChunkMap()
-    {
-        Iterator<ChunkCoordIntPair> tempIterator = m_activeChunksCoordsList.iterator();
-
-        while ( tempIterator.hasNext() )
-        {
-        	ChunkCoordIntPair coords = tempIterator.next();
-            Long lTempKey = ChunkCoordIntPair.chunkXZ2Int( coords.chunkXPos, coords.chunkZPos );
-            
-            tempIterator.remove();
-            m_activeChunksCoordsMap.remove( lTempKey ); 
-        }
-    }
-    
-    protected void AddToActiveChunkMap( int iChunkX, int iChunkZ )
-    {
-        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
-        
-        if ( !m_activeChunksCoordsMap.containsItem( lCoordKey ) )
-        {
-	    	ChunkCoordIntPair coords = new ChunkCoordIntPair( iChunkX, iChunkZ );
-	    	
-	        m_activeChunksCoordsList.add( coords );
-	        
-	        m_activeChunksCoordsMap.add( lCoordKey, coords );
-        }
-    }
-    
-    public boolean IsChunkActive( int iChunkX, int iChunkZ )
-    {
-        long lCoordKey = ChunkCoordIntPair.chunkXZ2Int( iChunkX, iChunkZ );
-        
-        return m_activeChunksCoordsMap.containsItem( lCoordKey );
-    }
-    
-    public boolean IsBlockPosActive( int i, int j, int k )
-    {    	
-        if ( j >= 0 && j < 256 )
-        {
-        	return IsChunkActive( i >> 4, k >> 4 );
-        }
-        
-        return false;
-    }
-    
-    public LinkedList<ChunkCoordIntPair> GetActiveChunksCoordsList()
-    {
-    	return m_activeChunksCoordsList;
-    }
-    
-    //------------- Weather Handling ------------//
-    
-    protected void updateWeather()
-    {
-    	// replacement for vanilla code to clean up and ensure that storms only start after it's been raining awhile
-    	
-        if ( !provider.hasNoSky )
-        {
-            int iRainTime = worldInfo.getRainTime();
-
-            if ( iRainTime <= 0 )
-            {
-                if ( worldInfo.isRaining() )
-                {
-                    worldInfo.setRainTime( rand.nextInt( 12000 ) + 12000 );
-                }
-                else
-                {
-                    worldInfo.setRainTime( rand.nextInt( 168000 ) + 12000 );
-                }
-            }
-            else
-            {
-                --iRainTime;
-                
-                worldInfo.setRainTime( iRainTime );
-
-                if ( iRainTime <= 0 )
-                {
-                    worldInfo.setRaining( !worldInfo.isRaining() );
-                    
-                    if ( worldInfo.isRaining() && !worldInfo.isThundering() )
-                    {
-                    	// min of a minute when rain starts before storm.  About a 1/5 chance of rain turning into a storm at some point in its duration
-                    	
-                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
-                    }
-                }
-            }
-
-            if ( worldInfo.isRaining() )
-            {
-	            int iThunderTime = worldInfo.getThunderTime();
-	
-	            if ( iThunderTime <= 0 )
-	            {
-	                if ( worldInfo.isThundering() )
-	                {
-	                    worldInfo.setThunderTime( rand.nextInt( 12000 ) + 3600 );
-	                }
-	                else
-	                {
-                		worldInfo.setThunderTime( rand.nextInt( 84000 ) + 1200 );
-	                }
-	            }
-	            else
-	            {
-	                --iThunderTime;
-	                
-	                worldInfo.setThunderTime( iThunderTime );
-	
-	                if ( iThunderTime <= 0 )
-	                {
-	                    worldInfo.setThundering( !worldInfo.isThundering() );
-	                }
-	            }
-            }
-            else if ( worldInfo.isThundering() )
-        	{
-        		worldInfo.setThundering( false );
-        	}
-
-            // update the rain and thunder strength counters
-            
-            prevRainingStrength = rainingStrength;
-
-            if ( worldInfo.isRaining() )
-            {
-                rainingStrength = rainingStrength + 0.01F;
-                
-                if ( rainingStrength > 1F )
-                {
-                    rainingStrength = 1F;
-                }
-            }
-            else
-            {
-                rainingStrength = rainingStrength - 0.01F;
-                
-                if ( rainingStrength < 0F )
-                {
-                    rainingStrength = 0F;
-                }
-            }
-
-            prevThunderingStrength = thunderingStrength;
-
-            if ( worldInfo.isThundering() )
-            {
-                thunderingStrength = thunderingStrength + 0.01F;
-                
-                if ( thunderingStrength > 1F )
-                {
-                    thunderingStrength = 1F;
-                }
-            }
-            else
-            {
-                thunderingStrength = thunderingStrength - 0.01F;
-                
-                if ( thunderingStrength < 0F )
-                {
-                    thunderingStrength = 0F;
-                }
-            }
-        }
-    }
-    
-    public boolean IsRainingAtPos( int i, int j, int k )
-    {
-        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
-        	j >= getPrecipitationHeight( i, k )  )
-        {
-            BiomeGenBase biome = getBiomeGenForCoords( i, k );
-            
-            return biome.CanRainInBiome();
-        }
-        
-        return false;
-    }
-    
-    public boolean IsSnowingAtPos( int i, int j, int k )
-    {
-        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
-        	j >= getPrecipitationHeight( i, k )  )
-        {
-            BiomeGenBase biome = getBiomeGenForCoords( i, k );
-            
-            return biome.getEnableSnow();
-        }
-        
-        return false;
-    }
-    
-    public boolean IsPrecipitatingAtPos( int i, int j, int k )
-    {
-        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
-        	j >= getPrecipitationHeight( i, k )  )
-        {
-            BiomeGenBase biome = getBiomeGenForCoords( i, k );
-            
-            return biome.getEnableSnow() || biome.CanRainInBiome();
-        }
-        
-        return false;
-    }
-    
-    public boolean IsPrecipitatingAtPos( int i, int k )
-    {
-        if ( isRaining() )
-        {
-            BiomeGenBase biome = getBiomeGenForCoords( i, k );
-            
-            return biome.getEnableSnow() || biome.CanRainInBiome();
-        }
-        
-        return false;
-    }
-    
-    public boolean CanLightningStrikeAtPos( int i, int j, int k )
-    {
-        if ( isRaining() && canBlockSeeTheSky( i, j, k ) &&
-        	j >= getPrecipitationHeight( i, k )  )
-        {
-            BiomeGenBase biome = getBiomeGenForCoords( i, k );
-            
-            return biome.CanLightningStrikeInBiome();
-        }
-        
-        return false;
-    }
-    // END FCMOD
 }
--- WorldChunkManager.java	Thu Oct 23 13:03:28 2014
+++ WorldChunkManager.java	Fri Apr 20 22:33:16 2018
@@ -26,10 +26,8 @@
         this.biomesToSpawnIn.add(BiomeGenBase.taiga);
         this.biomesToSpawnIn.add(BiomeGenBase.taigaHills);
         this.biomesToSpawnIn.add(BiomeGenBase.forestHills);
-        // FCMOD: Removing jungle biomes from the valid spawn locations due to jungle spiders
-        //this.biomesToSpawnIn.add(BiomeGenBase.jungle);
-        //this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
-        // END FCMOD
+        this.biomesToSpawnIn.add(BiomeGenBase.jungle);
+        this.biomesToSpawnIn.add(BiomeGenBase.jungleHills);
     }
 
     public WorldChunkManager(long par1, WorldType par3WorldType)
--- WorldGenBigTree.java	Sun Jan 21 17:14:27 2018
+++ WorldGenBigTree.java	Fri Apr 20 22:33:16 2018
@@ -503,20 +503,7 @@
             this.generateLeaves();
             this.generateTrunk();
             this.generateLeafNodeBases();
-            
-            // FCMOD: Added
-            int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-            
-            if ( iTrunkBlockId == Block.wood.blockID )
-            {
-            	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-            	
-        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-            }
-            // END FCMOD
-            
             return true;
         }
     }
-}
\ No newline at end of file
+}
--- WorldGenDesertWells.java	Tue Jan 22 16:07:49 2019
+++ WorldGenDesertWells.java	Fri Apr 20 22:33:16 2018
@@ -89,58 +89,7 @@
                 par1World.setBlock(par3 + 1, par4 + var7, par5 + 1, Block.sandStone.blockID, 0, 2);
             }
 
-            // FCMOD: Added
-            AddModBlocks( par1World, par3, par4, par5);
-            // END FCMOD
-
             return true;
         }
     }
-    
-    // FCMOD: Added
-    private static FCUtilsRandomItemStack[] m_LootBasketContents = null;
-    
-    private void InitContentsArray()
-    {
-    	m_LootBasketContents = new FCUtilsRandomItemStack[] {
-    		new FCUtilsRandomItemStack( FCBetterThanWolves.fcItemHempSeeds.itemID, 0, 1, 4, 5 ),  
-        	new FCUtilsRandomItemStack( Item.glassBottle.itemID, 0, 2, 8, 10 ),  
-        }; 
-    }
-    
-    private void AddModBlocks( World world, int i, int j, int k )
-    {
-    	int iNumBaskets = world.rand.nextInt( 3 );
-    	
-    	for ( int iTempCount = 0; iTempCount < iNumBaskets; iTempCount++ )
-    	{
-	    	int iBasketI = i + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
-	    	int iBasketJ = j + 2;
-	    	int iBasketK = k + ( world.rand.nextInt( 2 ) == 0 ? -2 : 2 );
-	    	
-	    	AddLootBasket( world, iBasketI, iBasketJ, iBasketK );
-    	}
-    }
-    
-    private void AddLootBasket( World world, int i, int j, int k )
-    {
-    	if ( m_LootBasketContents == null )
-    	{
-    		// only initialize array on first use to ensure referenced mod items are intialized
-    		InitContentsArray();
-    	}
-    	
-        if ( world.getBlockId( i, j, k ) != FCBetterThanWolves.fcBlockBasketWicker.blockID )
-        {
-	    	world.setBlock( i, j, k, FCBetterThanWolves.fcBlockBasketWicker.blockID, world.rand.nextInt( 4 ) | 4, 2 );
-	    	
-	    	FCTileEntityBasketWicker tileEntity = (FCTileEntityBasketWicker)world.getBlockTileEntity( i, j, k );
-	    	
-	    	if ( tileEntity != null )
-	    	{
-	    		tileEntity.SetStorageStack( FCUtilsRandomItemStack.GetRandomStack( world.rand, m_LootBasketContents ) );
-	    	}
-        }	    	
-    }
-    // END FCMOD
 }
--- WorldGenDungeons.java	Wed Feb  6 12:15:15 2019
+++ WorldGenDungeons.java	Fri Apr 20 22:33:16 2018
@@ -112,12 +112,7 @@
 
                                 if (var15 == 1)
                                 {
-                                    // FCMOD: Changed
-                                    /*
                                     par1World.setBlock(var12, par4, var14, Block.chest.blockID, 0, 2);
-                                    */
-                                    par1World.setBlock(var12, par4, var14, FCBetterThanWolves.fcBlockChest.blockID, 0, 2);
-                                	// END FCMOD
                                     TileEntityChest var16 = (TileEntityChest)par1World.getBlockTileEntity(var12, par4, var14);
 
                                     if (var16 != null)
@@ -133,10 +128,6 @@
                                         }
                                     }
 
-                                    // FCMOD: Code added
-                                    FilterChestContentsForDepth( par1World, var12, par4, var14 );
-                                    // END FCMOD
-
                                     break label210;
                                 }
                             }
@@ -188,62 +179,4 @@
         int var2 = par1Random.nextInt(4);
         return var2 == 0 ? "Skeleton" : (var2 == 1 ? "Zombie" : (var2 == 2 ? "Zombie" : (var2 == 3 ? "Spider" : "")));
     }
-    
-    // FCMOD: Code added
-    private void FilterChestContentsForDepth( World world, int iChestI, int iChestJ, int iChestK )
-    {
-        TileEntityChest chestEnt = (TileEntityChest)world.getBlockTileEntity( iChestI, iChestJ, iChestK );
-        
-        if ( chestEnt != null )
-        {
-            for ( int iSlot = 0; iSlot < chestEnt.getSizeInventory(); iSlot++ )
-            {
-                ItemStack tempStack = chestEnt.getStackInSlot( iSlot );
-                
-                if ( tempStack != null )
-                {
-                	int iItemID = tempStack.itemID;
-
-                	if ( iItemID == Item.ingotIron.itemID )
-                	{
-                		if ( iChestJ > 36 )
-                		{
-                    		chestEnt.setInventorySlotContents( iSlot, null );
-                		}
-                		else
-                		{
-                			tempStack.stackSize = 1;
-                		}
-                	}
-                	else if ( iItemID == Item.bucketEmpty.itemID )
-                	{
-                		chestEnt.setInventorySlotContents( iSlot, null );
-                	}
-                	else if ( iItemID == Item.gunpowder.itemID )
-                	{
-                		if ( iChestJ > 36 )
-                		{
-                    		chestEnt.setInventorySlotContents( iSlot, null );
-                		}
-                		else
-                		{
-                			tempStack.stackSize = 1;
-                		}
-                	}
-                	else if ( iItemID == Item.redstone.itemID )
-                	{
-                		if ( iChestJ > 24 )
-                		{
-                    		chestEnt.setInventorySlotContents( iSlot, null );
-                		}
-                	}
-                	else if ( iItemID == Item.wheat.itemID )
-                	{
-                		chestEnt.setInventorySlotContents( iSlot, null );
-                	}
-                }
-            }
-        }                	
-    }
-    // END FCMOD
 }
--- WorldGeneratorBonusChest.java	Sat Mar 31 00:20:40 2018
+++ WorldGeneratorBonusChest.java	Fri Apr 20 22:33:16 2018
@@ -50,7 +50,7 @@
 
                     if (var11 != null && var11 != null)
                     {
-                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);                        
+                        WeightedRandomChestContent.generateChestContents(par2Random, this.theBonusChestGenerator, var11, this.itemsToGenerateInBonusChest);
                     }
 
                     if (par1World.isAirBlock(var8 - 1, var9, var10) && par1World.doesBlockHaveSolidTopSurface(var8 - 1, var9 - 1, var10))
--- WorldGenFlowers.java	Thu Sep  3 17:52:11 2015
+++ WorldGenFlowers.java	Fri Apr 20 22:33:16 2018
@@ -20,13 +20,7 @@
             int var8 = par4 + par2Random.nextInt(4) - par2Random.nextInt(4);
             int var9 = par5 + par2Random.nextInt(8) - par2Random.nextInt(8);
 
-            // FCMOD: Change
-            /*
             if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && Block.blocksList[this.plantBlockId].canBlockStay(par1World, var7, var8, var9))
-            */
-            if (par1World.isAirBlock(var7, var8, var9) && (!par1World.provider.hasNoSky || var8 < 127) && 
-            	Block.blocksList[this.plantBlockId].CanBlockStayDuringGenerate(par1World, var7, var8, var9))
-        	// END FCMOD
             {
                 par1World.setBlock(var7, var8, var9, this.plantBlockId, 0, 2);
             }
--- WorldGenForest.java	Sun Jan 21 17:14:43 2018
+++ WorldGenForest.java	Fri Apr 20 22:33:16 2018
@@ -105,24 +105,6 @@
                         }
                     }
 
-                    // FCMOD: Added                    
-                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
-                    {
-                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-                        
-                        if ( iTrunkBlockId == Block.wood.blockID )
-                        {
-                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-                        	
-                        	if ( iTrunkMetadata == 2 )
-                        	{
-                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-                        	}
-                        }
-                    }                    
-                    // END FCMOD
-                    
                     return true;
                 }
                 else
--- WorldGenHugeTrees.java	Sun Jan 21 17:16:19 2018
+++ WorldGenHugeTrees.java	Fri Apr 20 22:33:16 2018
@@ -185,13 +185,6 @@
                         }
                     }
 
-                    // FCMOD: Added
-                    AttemptToPlaceStump( par1World, par3, par4, par5 );
-                    AttemptToPlaceStump( par1World, par3, par4, par5 + 1 );
-                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 );
-                    AttemptToPlaceStump( par1World, par3 + 1, par4, par5 + 1 );
-                    // END FCMOD
-
                     return true;
                 }
                 else
@@ -206,24 +199,6 @@
         }
     }
 
-    // FCMOD: Added
-    private void AttemptToPlaceStump( World world, int i, int j, int k )
-    {
-        int iTrunkBlockId = world.getBlockId( i, j, k );
-        
-        if ( iTrunkBlockId == Block.wood.blockID )
-        {
-        	int iTrunkMetadata = world.getBlockMetadata( i, j, k );
-        	
-        	if ( iTrunkMetadata == woodMetadata )
-        	{
-        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-        		world.setBlockMetadataWithClient( i, j, k, iTrunkMetadata | 12 ); 
-        	}
-        }
-    }
-    // END FCMOD
-    
     private void growLeaves(World par1World, int par2, int par3, int par4, int par5, Random par6Random)
     {
         byte var7 = 2;
--- WorldGenMinable.java	Fri Jun 14 14:25:58 2013
+++ WorldGenMinable.java	Fri Apr 20 22:33:16 2018
@@ -66,30 +66,7 @@
 
                                 if (var39 * var39 + var42 * var42 + var45 * var45 < 1.0D && par1World.getBlockId(var38, var41, var44) == this.field_94523_c)
                                 {
-                                	// FCMOD: Code change
-                                	/*
                                     par1World.setBlock(var38, var41, var44, this.minableBlockId, 0, 2);
-                                    */
-                                	int iMetadata = 0;
-                                	Block block = Block.blocksList[minableBlockId];
-                                	
-                                	if ( block.HasStrata() )
-                                	{
-                                		if ( var41 <= 48  + par1World.rand.nextInt( 2 ) )
-                                		{
-                                			int iStrataLevel = 1;
-                                			
-                                			if ( var41 <= 24 + par1World.rand.nextInt( 2 ) )
-                                			{
-                                				iStrataLevel = 2;                                				
-                                			}
-                                			
-                            				iMetadata = block.GetMetadataConversionForStrataLevel( iStrataLevel, 0 );
-                                		}
-                                	}
-                                	
-                                    par1World.setBlock(var38, var41, var44, this.minableBlockId, iMetadata, 2);
-                                    // END FCMOD
                                 }
                             }
                         }
--- WorldGenPumpkin.java	Mon Feb 12 17:41:44 2018
+++ WorldGenPumpkin.java	Fri Apr 20 22:33:16 2018
@@ -6,13 +6,6 @@
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
-    	// FCMOD: Added
-        boolean bIsValidBiome = ( par1World.getBiomeGenForCoords( par3, par5 ) == BiomeGenBase.plains );
-        int iPlacedPumpkinCount = 0;
-        
-        boolean bIsFresh = CheckIfFresh( par1World, par3, par5 );
-        // END FCMOD
-        
         for (int var6 = 0; var6 < 64; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(8) - par2Random.nextInt(8);
@@ -21,47 +14,10 @@
 
             if (par1World.isAirBlock(var7, var8, var9) && par1World.getBlockId(var7, var8 - 1, var9) == Block.grass.blockID && Block.pumpkin.canPlaceBlockAt(par1World, var7, var8, var9))
             {
-            	// FCMOD: Changed
-            	/*
                 par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, par2Random.nextInt(4), 2);
-                */
-            	int iFacing = par2Random.nextInt( 4 ); // must be done regardless of whether the block is placed to avoid disrupting the random number generator
-            	
-            	if ( bIsValidBiome && iPlacedPumpkinCount < 3 )
-            	{
-            		if ( bIsFresh )
-            		{
-            			par1World.setBlock(var7, var8, var9, FCBetterThanWolves.fcBlockPumpkinFresh.blockID, iFacing, 2);
-            		}
-            		else
-            		{
-            			par1World.setBlock(var7, var8, var9, Block.pumpkin.blockID, iFacing, 2);
-            		}
-                    
-                    iPlacedPumpkinCount++;
-            	}
-            	// END FCMOD            		
             }
         }
 
         return true;
     }
-    
-	// FCMOD: Added
-    private final static double m_dDistForFreshPumpkins = 2500D;
-    private final static double m_dDistSquaredForFreshPumpkins = ( m_dDistForFreshPumpkins * m_dDistForFreshPumpkins );
-    
-    public boolean CheckIfFresh( World world, int i, int k )
-    {
-    	int iSpawnX = world.getWorldInfo().getSpawnX();
-    	int iSpawnZ = world.getWorldInfo().getSpawnZ();
-    	
-    	double dDeltaX = (double)( iSpawnX - i );
-    	double dDeltaZ = (double)( iSpawnZ - k );
-    	
-    	double dDistSqFromSpawn = dDeltaX * dDeltaX + dDeltaZ * dDeltaZ;
-    	
-    	return dDistSqFromSpawn > m_dDistSquaredForFreshPumpkins;
-    }    
-    // END FCMOD	
 }
--- WorldGenReed.java	Sun May 13 12:45:19 2018
+++ WorldGenReed.java	Fri Apr 20 22:33:16 2018
@@ -6,13 +6,6 @@
 {
     public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
     {
-    	// FCMOD: Added
-    	BiomeGenBase currentBiome = par1World.getBiomeGenForCoords( par3, par5 );
-    	
-        boolean bIsValidBiome = currentBiome == BiomeGenBase.swampland || 
-        	currentBiome == BiomeGenBase.jungle || currentBiome == BiomeGenBase.jungleHills;
-        // END FCMOD
-        
         for (int var6 = 0; var6 < 20; ++var6)
         {
             int var7 = par3 + par2Random.nextInt(4) - par2Random.nextInt(4);
@@ -22,15 +15,6 @@
             if (par1World.isAirBlock(var7, par4, var9) && (par1World.getBlockMaterial(var7 - 1, par4 - 1, var9) == Material.water || par1World.getBlockMaterial(var7 + 1, par4 - 1, var9) == Material.water || par1World.getBlockMaterial(var7, par4 - 1, var9 - 1) == Material.water || par1World.getBlockMaterial(var7, par4 - 1, var9 + 1) == Material.water))
             {
                 int var10 = 2 + par2Random.nextInt(par2Random.nextInt(3) + 1);
-                
-                // FCMOD: Added
-                if ( !bIsValidBiome )
-                {
-                	// must occur after all random number generation to avoid messing up world gen
-                	
-                	continue;
-                }
-                // END FCMOD
 
                 for (int var11 = 0; var11 < var10; ++var11)
                 {
--- WorldGenSwamp.java	Sun Jan 21 17:16:34 2018
+++ WorldGenSwamp.java	Fri Apr 20 22:33:16 2018
@@ -144,24 +144,6 @@
                         }
                     }
 
-                    // FCMOD: Added                    
-                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
-                    {
-                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-                        
-                        if ( iTrunkBlockId == Block.wood.blockID )
-                        {
-                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-                        	
-                        	if ( iTrunkMetadata == 0 )
-                        	{
-                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-                        	}
-                        }
-                    }                    
-                    // END FCMOD
-                    
                     return true;
                 }
                 else
--- WorldGenTaiga1.java	Sun Jan 21 17:16:47 2018
+++ WorldGenTaiga1.java	Fri Apr 20 22:33:16 2018
@@ -104,24 +104,6 @@
                         }
                     }
 
-                    // FCMOD: Added                    
-                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
-                    {
-                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-                        
-                        if ( iTrunkBlockId == Block.wood.blockID )
-                        {
-                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-                        	
-                        	if ( iTrunkMetadata == 1 )
-                        	{
-                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-                        	}
-                        }
-                    }                    
-                    // END FCMOD
-                    
                     return true;
                 }
                 else
--- WorldGenTaiga2.java	Sun Jan 21 17:17:04 2018
+++ WorldGenTaiga2.java	Fri Apr 20 22:33:16 2018
@@ -122,24 +122,6 @@
                             this.setBlockAndMetadata(par1World, par3, par4 + var16, par5, Block.wood.blockID, 1);
                         }
                     }
-                    
-                    // FCMOD: Added                    
-                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
-                    {
-                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-                        
-                        if ( iTrunkBlockId == Block.wood.blockID )
-                        {
-                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-                        	
-                        	if ( iTrunkMetadata == 1 )
-                        	{
-                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-                        	}
-                        }
-                    }                    
-                    // END FCMOD                    
 
                     return true;
                 }
--- WorldGenTrees.java	Sun Jan 21 17:17:26 2018
+++ WorldGenTrees.java	Fri Apr 20 22:33:16 2018
@@ -206,24 +206,6 @@
                         }
                     }
 
-                    // FCMOD: Added                    
-                    if ( var6 > 2 ) // only tree with trunks 3 blocks or higher generate trunks
-                    {
-                        int iTrunkBlockId = par1World.getBlockId( par3, par4, par5 );
-                        
-                        if ( iTrunkBlockId == Block.wood.blockID )
-                        {
-                        	int iTrunkMetadata = par1World.getBlockMetadata( par3, par4, par5 );
-                        	
-                        	if ( iTrunkMetadata == metaWood )
-                        	{
-                        		// set the metadata instead of the whole block to prevent a breakBlock() call forcing surrounding leaves to update and decay
-                        		par1World.setBlockMetadataWithClient( par3, par4, par5, iTrunkMetadata | 12 ); 
-                        	}
-                        }
-                    }                    
-                    // END FCMOD
-
                     return true;
                 }
                 else
--- WorldInfo.java	Sun Oct  7 14:40:24 2018
+++ WorldInfo.java	Fri Apr 20 22:33:16 2018
@@ -166,10 +166,6 @@
         {
             this.theGameRules.readGameRulesFromNBT(par1NBTTagCompound.getCompoundTag("GameRules"));
         }
-        
-        // FCMOD: Code added
-        LoadModInfoFromNBT( par1NBTTagCompound );
-        // END FCMOD
     }
 
     public WorldInfo(WorldSettings par1WorldSettings, String par2Str)
@@ -217,9 +213,6 @@
         this.allowCommands = par1WorldInfo.allowCommands;
         this.initialized = par1WorldInfo.initialized;
         this.theGameRules = par1WorldInfo.theGameRules;
-        // FCMOD: Code added
-        CopyModInfo( par1WorldInfo );
-        // END FCMOD        
     }
 
     /**
@@ -268,10 +261,6 @@
         par1NBTTagCompound.setBoolean("initialized", this.initialized);
         par1NBTTagCompound.setCompoundTag("GameRules", this.theGameRules.writeGameRulesToNBT());
 
-        // FCMOD: Code added
-        SaveModInfoToNBT( par1NBTTagCompound );
-        // END FCMOD
-
         if (par2NBTTagCompound != null)
         {
             par1NBTTagCompound.setCompoundTag("Player", par2NBTTagCompound);
@@ -331,10 +320,6 @@
         return this.playerTag;
     }
 
-	/** 
-	 * FCNOTE: Be careful calling this function as it can return unexpected results in derived worlds
-	 * You normally want to use world.provider.dimensionId instead
-	 */
     public int getDimension()
     {
         return this.dimension;
@@ -647,106 +632,4 @@
     {
         return par0WorldInfo.allowCommands;
     }
-
-    // FCMOD: Code added
-    private InventoryEnderChest m_globalEnderChestInventory = new InventoryEnderChest();
-
-    public boolean m_bPreviouslyRaining = false;
-    public boolean m_bPreviouslyThundering = false;
-
-    private boolean m_bHasNetherBeenAccessed = false;
-    private boolean m_bHasWitherBeenSummoned = false;
-    private boolean m_bHasEndDimensionBeenAccessed = false;
-
-    public InventoryEnderChest GetGlobalEnderChestInventory()
-    {
-    	return m_globalEnderChestInventory;
-    }
-    
-    private void LoadModInfoFromNBT( NBTTagCompound par1NBTTagCompound )
-    {
-	    if ( par1NBTTagCompound.hasKey( "FCEnderItems" ) )
-	    {
-	        NBTTagList nbttaglist1 = par1NBTTagCompound.getTagList( "FCEnderItems" );
-	        
-	    	m_globalEnderChestInventory.loadInventoryFromNBT( nbttaglist1 );
-	    }	    
-	    
-	    if ( par1NBTTagCompound.hasKey( "FCNetherAccessed" ) )
-	    {
-	    	m_bHasNetherBeenAccessed = par1NBTTagCompound.getBoolean( "FCNetherAccessed" ); 
-	    }
-	    	
-	    if ( par1NBTTagCompound.hasKey( "FCWitherSummoned" ) )
-	    {
-	    	m_bHasWitherBeenSummoned = par1NBTTagCompound.getBoolean( "FCWitherSummoned" ); 
-	    }
-	    	
-	    if ( par1NBTTagCompound.hasKey( "FCEndAccessed" ) )
-	    {
-	    	m_bHasEndDimensionBeenAccessed = par1NBTTagCompound.getBoolean( "FCEndAccessed" ); 
-	    }
-	    	
-	    m_bPreviouslyRaining = raining;
-	    m_bPreviouslyThundering = thundering;
-    }
-    
-    private void SaveModInfoToNBT( NBTTagCompound par1NBTTagCompound )
-    {
-	    if ( m_globalEnderChestInventory != null )
-	    {
-	    	par1NBTTagCompound.setTag( "FCEnderItems", m_globalEnderChestInventory.saveInventoryToNBT() );
-	    }	    
-	    
-        par1NBTTagCompound.setBoolean( "FCNetherAccessed", m_bHasNetherBeenAccessed );	    
-        par1NBTTagCompound.setBoolean( "FCWitherSummoned", m_bHasWitherBeenSummoned );	    
-        par1NBTTagCompound.setBoolean( "FCEndAccessed", m_bHasEndDimensionBeenAccessed );	    
-    }
-    
-    private void CopyModInfo(WorldInfo par1WorldInfo)
-    {
-	    if ( par1WorldInfo.m_globalEnderChestInventory != null )
-	    {
-	        m_globalEnderChestInventory = par1WorldInfo.m_globalEnderChestInventory;
-	    }	    
-	    
-	    m_bHasNetherBeenAccessed = par1WorldInfo.m_bHasNetherBeenAccessed;
-	    m_bHasWitherBeenSummoned = par1WorldInfo.m_bHasWitherBeenSummoned;
-	    m_bHasEndDimensionBeenAccessed = par1WorldInfo.m_bHasEndDimensionBeenAccessed;
-	    
-	    m_bPreviouslyRaining = raining;
-	    m_bPreviouslyThundering = thundering;
-    }
-    
-    public boolean HasNetherBeenAccessed()
-    {
-    	return m_bHasNetherBeenAccessed;
-    }
-    
-    public void SetNetherBeenAccessed()
-    {
-    	m_bHasNetherBeenAccessed = true;
-    }
-    
-    public boolean HasWitherBeenSummoned()
-    {
-    	return m_bHasWitherBeenSummoned;
-    }
-    
-    public void SetWitherHasBeenSummoned()
-    {
-    	m_bHasWitherBeenSummoned = true;
-    }
-    
-    public boolean HasEndDimensionBeenAccessed()
-    {
-    	return m_bHasEndDimensionBeenAccessed;
-    }
-    
-    public void SetEndDimensionHasBeenAccessed()
-    {
-    	m_bHasEndDimensionBeenAccessed = true;
-    }
-    
-    // END FCMOD
 }
--- WorldManager.java	Sun Oct 28 12:59:39 2018
+++ WorldManager.java	Fri Apr 20 22:33:16 2018
@@ -68,10 +68,7 @@
      */
     public void markBlockForUpdate(int par1, int par2, int par3)
     {
-    	// FCMOD: Changed
-        //this.theWorldServer.getPlayerManager().markBlockNeedsUpdate(par1, par2, par3);
-        theWorldServer.GetChunkTracker().FlagBlockForClientUpdate( par1, par2, par3 );
-        // END FCMOD
+        this.theWorldServer.getPlayerManager().markBlockNeedsUpdate(par1, par2, par3);
     }
 
     /**
--- WorldServer.java	Fri Dec 18 20:29:48 2020
+++ WorldServer.java	Fri Apr 20 22:33:16 2018
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
@@ -14,12 +13,7 @@
 {
     private final MinecraftServer mcServer;
     private final EntityTracker theEntityTracker;
-    // FCMOD: Changed
-    //private final PlayerManager thePlayerManager;
-    private final FCChunkTracker m_chunkTracker;
-    // END FCMOD
-    
-    // FCNOTE: Contains NextTickListEntry objects with updates scheduled for blocks
+    private final PlayerManager thePlayerManager;
     private Set field_73064_N;
 
     /** All work to do in future ticks. */
@@ -54,18 +48,8 @@
     {
         super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
         this.mcServer = par1MinecraftServer;
-        
-        // FCMOD: Added
-        saveHandler.LoadModSpecificData( this );
-        // END FCMOD
-        
         this.theEntityTracker = new EntityTracker(this);
-        
-        // FCMOD: Changed
-        //this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
-        m_chunkTracker = new FCChunkTracker( this, 
-        	par1MinecraftServer.getConfigurationManager().getViewDistance());
-        // END FCMOD
+        this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
 
         if (this.entityIdMap == null)
         {
@@ -107,12 +91,6 @@
         {
             this.difficultySetting = 3;
         }
-        // FCMOD: Added to eliminate peaceful and easy difficulties
-        else if ( difficultySetting < 2 )
-        {
-        	difficultySetting = 2;
-        }
-        // END FCMOD
 
         this.provider.worldChunkMgr.cleanupCache();
 
@@ -137,12 +115,7 @@
 
         if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
         {
-        	// FCMOD: Code change to prevent animal spawning after chunk generation
-        	/*
             SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
-            */
-            SpawnerAnimals.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, false);
-            // END FCMOD
         }
 
         this.theProfiler.endStartSection("chunkSource");
@@ -161,15 +134,10 @@
         this.theProfiler.endStartSection("tickTiles");
         this.tickBlocksAndAmbiance();
         this.theProfiler.endStartSection("chunkMap");
-        // FCMOD: Changed
-        //this.thePlayerManager.updatePlayerInstances();
-        m_chunkTracker.Update();
-        // END FCMOD
+        this.thePlayerManager.updatePlayerInstances();
         this.theProfiler.endStartSection("village");
         this.villageCollectionObj.tick();
-        // FCMOD: Removed
-        //this.villageSiegeObj.tick();
-        // END FCMOD
+        this.villageSiegeObj.tick();
         this.theProfiler.endStartSection("portalForcer");
         this.field_85177_Q.removeStalePortalLocations(this.getTotalWorldTime());
         this.theProfiler.endSection();
@@ -266,10 +234,7 @@
         super.tickBlocksAndAmbiance();
         int var1 = 0;
         int var2 = 0;
-        // FCMOD: Changed
-        //Iterator var3 = this.activeChunkSet.iterator();
-        Iterator<ChunkCoordIntPair> var3 = m_activeChunksCoordsList.iterator();
-        // END FCMOD
+        Iterator var3 = this.activeChunkSet.iterator();
 
         while (var3.hasNext())
         {
@@ -287,10 +252,7 @@
             int var10;
             int var11;
 
-            // FCMOD: Changed
-            //if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
-            if ( rand.nextInt( 50000 ) == 0 && isRaining() && isThundering() )
-        	// END FCMOD 
+            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
                 var8 = this.updateLCG >> 2;
@@ -298,23 +260,9 @@
                 var10 = var6 + (var8 >> 8 & 15);
                 var11 = this.getPrecipitationHeight(var9, var10);
 
-                // FCMOD: Changed
-                //if (this.canLightningStrikeAt(var9, var11, var10))
-                if ( CanLightningStrikeAtPos( var9, var11, var10 ) )
-            	// END FCMOD
+                if (this.canLightningStrikeAt(var9, var11, var10))
                 {
-                	// FCMOD: Changed
-                    //this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
-                	FCUtilsBlockPos strikePos = new FCUtilsBlockPos( var9, var11, var10 );
-            		
-            		AdjustLightningPosForSurroundings( strikePos );
-            		
-                    if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
-                    {
-                        addWeatherEffect( new FCEntityLightningBolt( this, (double)strikePos.i + 0.5D, 
-                        	(double)strikePos.j, (double)strikePos.k + 0.5D ) );
-                    }
-                	// END FCMOD
+                    this.addWeatherEffect(new EntityLightningBolt(this, (double)var9, (double)var11, (double)var10));
                 }
             }
 
@@ -338,21 +286,12 @@
                 {
                     this.setBlock(var9 + var5, var11, var10 + var6, Block.snow.blockID);
                 }
-                // FCMOD: Added
-                else if (this.isRaining() && this.canSnowAt(var9 + var5, var11 + 1, var10 + var6))
-                {
-                    setBlock(var9 + var5, var11 + 1, var10 + var6, Block.snow.blockID);
-                }
-                // END FCMOD
 
                 if (this.isRaining())
                 {
                     BiomeGenBase var12 = this.getBiomeGenForCoords(var9 + var5, var10 + var6);
 
-                    // FCMOD: Changed for clarity
-                    //if (var12.canSpawnLightningBolt())
-                    if ( var12.CanRainInBiome() )
-                	// END FCMOD
+                    if (var12.canSpawnLightningBolt())
                     {
                         var13 = this.getBlockId(var9 + var5, var11 - 1, var10 + var6);
 
@@ -388,12 +327,7 @@
                         if (var18 != null && var18.getTickRandomly())
                         {
                             ++var1;
-                            // FCMOD: Code changed
-                            /*
                             var18.updateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, this.rand);
-                            */
-                            var18.RandomUpdateTick(this, var14 + var5, var16 + var21.getYLocation(), var15 + var6, rand);
-                            // END FCMOD
                         }
                     }
                 }
@@ -401,10 +335,6 @@
 
             this.theProfiler.endSection();
         }
-
-        // FCMOD: Added
-        ModUpdateTick();
-        // END FCMOD
     }
 
     /**
@@ -427,21 +357,13 @@
     public void func_82740_a(int par1, int par2, int par3, int par4, int par5, int par6)
     {
         NextTickListEntry var7 = new NextTickListEntry(par1, par2, par3, par4);
-        // FCMOD: Removed
-        //byte var8 = 0;
-        // END FCMOD
+        byte var8 = 0;
 
         if (this.scheduledUpdatesAreImmediate && par4 > 0)
         {
             if (Block.blocksList[par4].func_82506_l())
             {
-            	// FCCHUNK: Decide on updates around original spawn
-            	// FCMOD: Changed
-            	/*
                 if (this.checkChunksExist(var7.xCoord - var8, var7.yCoord - var8, var7.zCoord - var8, var7.xCoord + var8, var7.yCoord + var8, var7.zCoord + var8))
-                */
-                if ( IsBlockPosActive( var7.xCoord, var7.yCoord, var7.zCoord ) )
-            	// END FCMOD
                 {
                     int var9 = this.getBlockId(var7.xCoord, var7.yCoord, var7.zCoord);
 
@@ -457,13 +379,7 @@
             par5 = 1;
         }
 
-    	// FCCHUNK: Decide on updates around original spawn
-    	// FCMOD: Changed
-    	/*
         if (this.checkChunksExist(par1 - var8, par2 - var8, par3 - var8, par1 + var8, par2 + var8, par3 + var8))
-        */
-        if ( IsBlockPosActive( par1, par2, par3 ) )
-        // END FCMOD
         {
             if (par4 > 0)
             {
@@ -504,8 +420,6 @@
      */
     public void updateEntities()
     {
-    	// FCMOD: Removed pausing of updates when no players in world.  Replaced elsewhere
-    	/*
         if (this.playerEntities.isEmpty())
         {
             if (this.updateEntityTick++ >= 1200)
@@ -517,8 +431,6 @@
         {
             this.resetUpdateEntityTick();
         }
-        */
-    	// END FCMOD
 
         super.updateEntities();
     }
@@ -574,16 +486,9 @@
             {
                 var4 = (NextTickListEntry)var14.next();
                 var14.remove();
-            	// FCCHUNK: Decide on updates around original spawn
-                // FCMOD: Changed to prevent neighboring chunks inadvertantly being loaded during
-                // updates.  This was causing stuff like fire loading a ton of chunks in the nether.
-                /*
                 byte var5 = 0;
-                
+
                 if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
-                */
-                if ( IsBlockPosActive( var4.xCoord, var4.yCoord, var4.zCoord ) )
-            	// END FCMOD
                 {
                     int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
 
@@ -613,19 +518,10 @@
                         }
                     }
                 }
-            	// FCCHUNK: Decide on updates around original spawn
-                // FCMOD: Removed to reduce unnecessary overhead of recheduling ticks in inactive chunks
-                /*
                 else
                 {
-                	// FCMOD: Changed to not immediately retick on next update to ease on performance
-                    //this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
-                    scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 
-                    	Block.blocksList[var4.blockID].tickRate( this ) );
-                    // END FCMOD
+                    this.scheduleBlockUpdate(var4.xCoord, var4.yCoord, var4.zCoord, var4.blockID, 0);
                 }
-                */
-                // END FCMOD
             }
 
             this.theProfiler.endSection();
@@ -704,21 +600,6 @@
 
         if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
         {
-            // Added so that creatures in periphery chunks can still despawn
-            int iEntityI = MathHelper.floor_double( par1Entity.posX );
-            int iEntityK = MathHelper.floor_double( par1Entity.posZ );
-            
-            if ( par2 && !IsBlockPosActive( iEntityI, 0, iEntityK ) && par1Entity.addedToChunk  )
-            {
-                if ( par1Entity.ridingEntity == null )
-                {
-                	par1Entity.OutOfUpdateRangeUpdate();
-                }
-                
-                return; // intentionally skip super call
-            }
-            // END FCMOD
-            
             super.updateEntityWithOptionalForce(par1Entity, par2);
         }
     }
@@ -741,12 +622,6 @@
         return this.theChunkProviderServer;
     }
 
-    // FCMOD: Added (server only) alias to match client
-    public List getAllTileEntityInBox( int par1, int par2, int par3, int par4, int par5, int par6 )
-    {
-    	return getTileEntityList( par1, par2, par3, par4, par5, par6 );
-    }
-    // END FCMOD
     /**
      * get a list of tileEntity's
      */
@@ -855,10 +730,7 @@
      */
     protected void createBonusChest()
     {
-    	// FCMOD: Changed
-        //WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
-        FCWorldGeneratorBonusBasket var1 = new FCWorldGeneratorBonusBasket();
-    	// END FCMOD
+        WorldGeneratorBonusChest var1 = new WorldGeneratorBonusChest(bonusChestContent, 10);
 
         for (int var2 = 0; var2 < 10; ++var2)
         {
@@ -901,10 +773,6 @@
             }
 
             this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
-
-            // FCMOD: Added
-            saveHandler.SaveModSpecificData( this );
-            // END FCMOD
         }
     }
 
@@ -977,19 +845,7 @@
     {
         if (super.addWeatherEffect(par1Entity))
         {
-        	// FCMOD: Changed to avoid modding Packet71Weather        	
-            //this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
-        	Packet71Weather packet = new Packet71Weather( par1Entity );
-        	
-        	if ( par1Entity instanceof FCEntityLightningBolt )
-        	{
-        		packet.isLightningBolt = 1;
-        	}
-        	
-            this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(
-            	par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, provider.dimensionId, 
-            	packet );
-            // END FCMOD
+            this.mcServer.getConfigurationManager().sendPacketToPlayersAroundPoint(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
             return true;
         }
         else
@@ -1106,8 +962,6 @@
     /**
      * Updates all weather states.
      */
-    // FCMOD: Removed and replaced later
-    /*
     protected void updateWeather()
     {
         boolean var1 = this.isRaining();
@@ -1125,8 +979,6 @@
             }
         }
     }
-    */
-    // END FCMOD
 
     /**
      * Gets the MinecraftServer.
@@ -1144,393 +996,13 @@
         return this.theEntityTracker;
     }
 
-    // FCMOD: Removed
-    /*
     public PlayerManager getPlayerManager()
     {
         return this.thePlayerManager;
     }
-    */
-    // END FCMOD
 
     public Teleporter getDefaultTeleporter()
     {
         return this.field_85177_Q;
     }
-
-    // FCMOD: Added
-    private boolean m_bHasTicked = false;
-    
-    protected LinkedList<ChunkCoordIntPair> m_chunksToCheckForUnloadList = 
-    	new LinkedList<ChunkCoordIntPair>();
-    
-    private long m_lNoPlayersOnServerTickCount = 0;
-    
-    // MinecraftServer loads out to 192 blocks, or 12 chunks. One more for wiggle.
-    
-    private final int m_iChunksAroundSpawnToCheckForUnload = 13;  
-    
-    @Override
-    public void ModSpecificTick()
-    {
-    	if ( !m_bHasTicked )
-    	{
-    		m_bHasTicked = true;
-
-    		MarkChunksAroundSpawnToCheckForUnload();
-    	}    	    	
-    	
-		CheckChunksToUnloadList();
-    }    
-    
-    public void AddChunkToCheckForUnloadList( int iChunkX, int iChunkZ )
-    {
-    	m_chunksToCheckForUnloadList.add( new ChunkCoordIntPair( iChunkX, iChunkZ ) );
-    }
-    
-    public void AddChunkRangeToCheckForUnloadList( int iMinChunkX, int iMinChunkZ, 
-    	int iMaxChunkX, int iMaxChunkZ )
-    {
-    	for ( int iTempChunkX = iMinChunkX; iTempChunkX <= iMaxChunkX; iTempChunkX++ )
-    	{
-        	for ( int iTempChunkZ = iMinChunkZ; iTempChunkZ <= iMaxChunkZ; iTempChunkZ++ )
-        	{
-        		AddChunkToCheckForUnloadList( iTempChunkX, iTempChunkZ );
-        	}
-    	}
-    }
-    
-    private void CheckChunksToUnloadList()
-    {
-    	if ( !m_chunksToCheckForUnloadList.isEmpty() )
-    	{
-        	Iterator<ChunkCoordIntPair> tempIterator = m_chunksToCheckForUnloadList.iterator();
-        	
-        	while ( tempIterator.hasNext() )
-        	{
-        		ChunkCoordIntPair tempCoord = tempIterator.next();
-        		
-        		if ( CheckChunkShouldBeUnloaded( tempCoord.chunkXPos, tempCoord.chunkZPos ) )
-        		{
-        			theChunkProviderServer.ForceAddToChunksToUnload( 
-        				tempCoord.chunkXPos, tempCoord.chunkZPos );
-        		}
-        	}
-    		
-    		m_chunksToCheckForUnloadList.clear();
-    	}
-    }
-    
-    private boolean CheckChunkShouldBeUnloaded( int iChunkX, int iChunkZ )
-    {
-    	return chunkExists( iChunkX, iChunkZ ) && 
-    		!m_chunkTracker.IsChunkBeingWatched( iChunkX, iChunkZ  )&&
-    		!theChunkProviderServer.IsSpawnChunk( iChunkX, iChunkZ );
-    }
-    
-    private void MarkChunksAroundSpawnToCheckForUnload()
-    {
-    	// this function cleans up extra useless overworld chunks loaded by 
-    	// MinecraftServer.initialWorldChunkLoad()
-    	
-		if ( provider.canRespawnHere() )
-		{
-			int iSpawnChunkX = worldInfo.getSpawnX() >> 4;
-			int iSpawnChunkZ = worldInfo.getSpawnZ() >> 4;
-            
-            AddChunkRangeToCheckForUnloadList( 
-            	iSpawnChunkX - m_iChunksAroundSpawnToCheckForUnload, 
-            	iSpawnChunkZ - m_iChunksAroundSpawnToCheckForUnload,
-            	iSpawnChunkX + m_iChunksAroundSpawnToCheckForUnload, 
-            	iSpawnChunkZ + m_iChunksAroundSpawnToCheckForUnload );        
-		}
-    }
-
-    @Override
-    public boolean IsUpdateScheduledForBlock( int i, int j, int k, int iBlockID )
-    {
-        NextTickListEntry tempEntry = new NextTickListEntry( i, j, k, iBlockID );
-        
-        return field_73064_N.contains( tempEntry );
-    }
-
-    @Override
-    protected void updateWeather()
-    {
-    	// Vanilla code replaced to fix storms not relaying state to clients and a couple of other little oddities like the state
-    	// changes for weather not being communicated immeditately
-    	
-        super.updateWeather();
-
-        if ( worldInfo.m_bPreviouslyRaining != worldInfo.isRaining() )
-        {
-            if ( worldInfo.isRaining() )
-            {
-                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 1, 0 ) );
-            }
-            else
-            {
-                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 2, 0 ) );
-            }
-            
-            worldInfo.m_bPreviouslyRaining = worldInfo.isRaining();
-        }
-        
-        if ( worldInfo.m_bPreviouslyThundering != worldInfo.isThundering() )
-        {
-            if ( worldInfo.isThundering() )
-            {
-                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 7, 0 ) );
-            }
-            else
-            {
-                mcServer.getConfigurationManager().sendPacketToAllPlayers( new Packet70GameEvent( 8, 0 ) );
-            }
-            
-            worldInfo.m_bPreviouslyThundering = worldInfo.isThundering();
-        }
-    }
-    
-    private void ModUpdateTick()
-    {
-    	ValidateMagneticPointList();
-    	
-    	ValidateLootingBeaconList();
-    	
-    	ValidateSpawnLocationList();
-    }
-    
-    private void ValidateMagneticPointList()
-    {
-    	// periodically check the magnetic point list for dead points
-    	
-    	int iTimeFactor = (int)getWorldTime();
-    	
-    	if ( ( iTimeFactor & 15 ) == 0 )
-    	{
-    		int iListLength = m_MagneticPointList.m_MagneticPoints.size();
-    		
-    		if ( iListLength > 0 )
-    		{
-        		iTimeFactor = iTimeFactor >> 4;
-                
-    			int iTempIndex = (int)( iTimeFactor % iListLength );
-    			
-    			FCMagneticPoint tempPoint = (FCMagneticPoint)m_MagneticPointList.m_MagneticPoints.get( iTempIndex );
-    			
-    	        if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
-    	        {
-    	        	// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
-    	        	
-    	        	if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
-    	        	{
-    	        		m_MagneticPointList.m_MagneticPoints.remove( iTempIndex );
-    	        		
-    	        	}
-    	        }    			
-    		}
-    	}
-    }
-    
-    private void ValidateLootingBeaconList()
-    {
-    	// periodically check the looting beacon list for dead points
-    	
-    	int iTimeFactor = (int)getWorldTime();
-    	
-    	if ( ( iTimeFactor & 15 ) == 0 )
-    	{
-    		int iListLength = m_LootingBeaconLocationList.m_EffectLocations.size();
-    		
-    		if ( iListLength > 0 )
-    		{
-        		iTimeFactor = iTimeFactor >> 4;
-                
-    			int iTempIndex = (int)( iTimeFactor % iListLength );
-    			
-    			FCBeaconEffectLocation tempPoint = (FCBeaconEffectLocation)m_LootingBeaconLocationList.m_EffectLocations.get( iTempIndex );
-    			
-    	        if ( checkChunksExist( tempPoint.m_iIPos, 0, tempPoint.m_iKPos, tempPoint.m_iIPos, 0, tempPoint.m_iKPos ) )
-    	        {
-    	        	// just check if the point has an associated beacon.  If it does, the beacon itself can validate its precise state
-    	        	
-    	        	if ( getBlockId( tempPoint.m_iIPos, tempPoint.m_iJPos, tempPoint.m_iKPos ) != Block.beacon.blockID )
-    	        	{
-    	        		m_LootingBeaconLocationList.m_EffectLocations.remove( iTempIndex );
-    	        		
-    	        	}
-    	        }    			
-    		}
-    	}
-    }
-    
-    private void ValidateSpawnLocationList()
-    {
-    	// periodically check the list for dead points
-    	
-    	long lWorldTime = getWorldTime();
-    	
-    	if ( ( lWorldTime & 15 ) == 0 )
-    	{
-        	Iterator tempIterator = m_SpawnLocationList.m_SpawnLocations.iterator();
-        	
-        	while ( tempIterator.hasNext() )
-        	{
-        		FCSpawnLocation tempPoint = (FCSpawnLocation)tempIterator.next();
-        		
-        		if ( lWorldTime < tempPoint.m_lSpawnTime || lWorldTime - tempPoint.m_lSpawnTime > FCUtilsHardcoreSpawn.m_iHardcoreSpawnTimeBetweenReassignments )
-        		{        			
-        			tempIterator.remove();
-        		}        		
-        	}
-    	}
-    }
-    
-    protected void AdjustLightningPosForSurroundings( FCUtilsBlockPos strikePos )
-    {
-    	int iHighJ = strikePos.j;
-    	
-    	// store bounds variables since strikePos changes during search
-    	
-    	int iMinI = strikePos.i - 16;
-    	int iMinK = strikePos.k - 16;
-    	
-    	int iMaxI = strikePos.i + 16;
-    	int iMaxK = strikePos.k + 16;
-    	
-    	for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
-    	{
-        	for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
-        	{
-                int iTempJ = getPrecipitationHeight( iTempI, iTempK );
-                
-                if ( iTempJ > iHighJ )
-                {
-                    if ( CanLightningStrikeAtPos( iTempI, iTempJ, iTempK ) )
-                    {
-	                	strikePos.i = iTempI;
-	                	iHighJ = strikePos.j = iTempJ;
-	                	strikePos.k = iTempK;
-                    }
-                }
-        	}
-    	}    	
-    	
-    	// check entities
-    	
-        List<Entity> entityList = getEntitiesWithinAABB( Entity.class, AxisAlignedBB.getAABBPool().getAABB( 
-        	iMinI, iHighJ, iMinK, iMaxI + 1D, 256D, iMaxK + 1D ) );
-    	
-        Iterator<Entity> entityIterator = entityList.iterator();
-
-        while ( entityIterator.hasNext() )
-        {
-            Entity tempEntity = entityIterator.next();
-            
-            if ( tempEntity.isEntityAlive() && tempEntity.AttractsLightning() )
-            {
-            	int iEntityMaxJ = (int)tempEntity.boundingBox.maxY + 1;
-            	
-            	if ( iEntityMaxJ > iHighJ )
-            	{            	
-	            	int iEntityI = MathHelper.floor_double( tempEntity.posX );
-	            	int iEntityK = MathHelper.floor_double( tempEntity.posZ );
-	            	
-	                int iPrecipitationJ = getPrecipitationHeight( iEntityI, iEntityK );
-	                
-	                if ( iPrecipitationJ <= iEntityMaxJ &&
-	                	CanLightningStrikeAtPos( iEntityI, iPrecipitationJ, iEntityK ) )
-	                {
-	                	strikePos.i = iEntityI;
-	                	iHighJ = strikePos.j = iPrecipitationJ;
-	                	strikePos.k = iEntityK;
-	                }	                
-            	}                
-            }
-        }
-
-        // secondary search for lightning rods in a larger area around new strike pos
-        
-        if ( IsBlockPosActive( strikePos.i, strikePos.j, strikePos.k ) )
-        {
-        	iMinI = strikePos.i - 16;
-        	iMinK = strikePos.k - 16;
-        	
-        	iMaxI = strikePos.i + 16;
-        	iMaxK = strikePos.k + 16;
-        	
-        	for ( int iTempI = iMinI; iTempI <= iMaxI; iTempI++ )
-        	{
-            	for ( int iTempK = iMinK; iTempK <= iMaxK; iTempK++ )
-            	{
-                    int iTempJ = getPrecipitationHeight( iTempI, iTempK );
-                    
-                    if ( iTempJ > iHighJ && getBlockId( iTempI, iTempJ - 1, iTempK ) == 
-                    	FCBetterThanWolves.fcBlockLightningRod.blockID )
-                    {
-                    	// intentionally don't test CanLightningStrikeAtPos() so that
-                    	// rods in non-lightning biomes can still attract lightning to them
-                    	
-	                	strikePos.i = iTempI;
-	                	iHighJ = strikePos.j = iTempJ;
-	                	strikePos.k = iTempK;
-                    }
-            	}
-        	}        	
-        }
-    }
-    
-    @Override
-    public int GetClampedViewDistanceInChunks()
-    {
-    	int iRange = getMinecraftServer().getConfigurationManager().getViewDistance();
-    	
-    	return MathHelper.clamp_int( iRange, 3, 15 );
-    }
-    
-    @Override
-    protected void UpdateActiveChunkMap()
-    {
-    	super.UpdateActiveChunkMap();
-    	
-    	UpdateServerIdleState();    	
-    	
-    	// FCCHUNK: Decide on updates around original spawn
-    	
-    	if ( provider.dimensionId == 0 && !IsServerIdle() )
-    	{
-	        ChunkCoordinates originalSpawn = getSpawnPoint();
-	        
-	        AddAreaAroundChunkToActiveChunkMap( originalSpawn.posX >> 4, 
-	        	originalSpawn.posZ >> 4 );
-    	}
-    }
-    
-    public FCChunkTracker GetChunkTracker()
-    {
-        return m_chunkTracker;
-    }    
-
-    protected void UpdateServerIdleState()
-    {
-        if ( !AreAnyPlayersOnServer() )
-        {
-        	m_lNoPlayersOnServerTickCount++;
-        }
-        else
-        {
-        	m_lNoPlayersOnServerTickCount = 0;
-        }
-    }
-    
-    protected boolean IsServerIdle()
-    {
-        return m_lNoPlayersOnServerTickCount >= 1200L;
-    }
-    
-    protected boolean AreAnyPlayersOnServer()
-    {
-    	return mcServer.getCurrentPlayerCount() > 0;
-    }
-    // END FCMOD
 }
